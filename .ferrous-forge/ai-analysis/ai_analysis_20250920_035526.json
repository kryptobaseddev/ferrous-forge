{
  "metadata": {
    "timestamp": "2025-09-20T03:55:26.013118626+00:00",
    "total_violations": 225,
    "analyzable_violations": 100,
    "project_path": "/mnt/projects/ferrous-forge",
    "analysis_depth": "Semantic"
  },
  "violation_analyses": [
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 304,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    } else if imports.iter().any(|i| i.contains(\"thiserror\")) {",
          "        ErrorHandlingStyle::ThiserrorCustom",
          "    } else if content.contains(\"Result<\") {",
          "        ErrorHandlingStyle::StdResult",
          "    } else if content.contains(\"Option<\") {",
          "        ErrorHandlingStyle::OptionBased",
          "    } else if content.contains(\"panic!\") || content.contains(\".unwrap()\") {",
          "        ErrorHandlingStyle::Panic",
          "    } else {",
          "        ErrorHandlingStyle::Unknown",
          "    }"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 304: ErrorHandlingStyle::OptionBased"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "code_context": [
            209
          ],
          "semantic_analysis": [
            210
          ],
          "violation_line": [
            234,
            329
          ],
          "error_handling_style": [
            257
          ],
          "side_effects": [
            214
          ],
          "name": [
            279
          ],
          "end": [
            238
          ],
          "return_type": [
            281
          ],
          "is_async": [
            285
          ],
          "imports": [
            250,
            841
          ],
          "is_generic": [
            286
          ],
          "variable_usage": [
            339
          ],
          "line": [
            361
          ],
          "Some(var_name)": [
            406
          ],
          "fix_strategies": [
            182
          ],
          "style": [
            843
          ],
          "error_handling_pattern": [
            583
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "semantic": [
            861
          ],
          "Some(ast)": [
            243
          ],
          "function_calls": [
            342
          ],
          "start": [
            237
          ],
          "confidence": [
            871
          ],
          "architectural_style": [
            580
          ],
          "ast": [
            207
          ],
          "code_patterns": [
            181
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "content": [
            842
          ],
          "data_flow": [
            335
          ],
          "file_content": [
            204
          ],
          "\")": [
            405
          ],
          "unwrap_count": [
            560
          ],
          "Ok(analysis)": [
            175
          ],
          "Some(start)": [
            416,
            499
          ],
          "prompt": [
            674
          ],
          "confidence_score": [
            215
          ],
          "rest": [
            417,
            500
          ],
          "fix_complexity": [
            211
          ],
          "actual_type": [
            331
          ],
          "violations_of_complexity": [
            787
          ],
          "surrounding_code": [
            239
          ],
          "control_flow": [
            336
          ],
          "error_propagation_path": [
            345
          ],
          "ai_instructions": [
            183
          ],
          "dependencies": [
            213
          ],
          "Some(dep)": [
            486
          ],
          "system_prompt": [
            655
          ],
          "(function_name,": [
            242
          ],
          "Item": [
            277
          ],
          "expected_type": [
            332
          ],
          "lines": [
            233,
            313,
            328
          ],
          "signature": [
            280
          ],
          "context": [
            849
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 358,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "        variable_usage,",
          "        function_calls,",
          "        error_propagation_path,",
          "    })",
          "}",
          "",
          "fn infer_actual_type(lines: &[&str], line_idx: usize) -> Option<String> {",
          "    // Simplified type inference",
          "    if line_idx < lines.len() {",
          "        let line = lines[line_idx];",
          "        if line.contains(\"Result<\") {"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 358: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "name": [
            279
          ],
          "code_context": [
            209
          ],
          "Item": [
            277
          ],
          "end": [
            238
          ],
          "semantic_analysis": [
            210
          ],
          "variable_usage": [
            339
          ],
          "expected_type": [
            332
          ],
          "file_content": [
            204
          ],
          "error_handling_pattern": [
            583
          ],
          "style": [
            843
          ],
          "dependencies": [
            213
          ],
          "data_flow": [
            335
          ],
          "system_prompt": [
            655
          ],
          "actual_type": [
            331
          ],
          "line": [
            361
          ],
          "Ok(analysis)": [
            175
          ],
          "\")": [
            405
          ],
          "control_flow": [
            336
          ],
          "rest": [
            417,
            500
          ],
          "imports": [
            250,
            841
          ],
          "ast": [
            207
          ],
          "error_propagation_path": [
            345
          ],
          "Some(dep)": [
            486
          ],
          "violations_of_complexity": [
            787
          ],
          "semantic": [
            861
          ],
          "error_handling_style": [
            257
          ],
          "Some(ast)": [
            243
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "context": [
            849
          ],
          "fix_complexity": [
            211
          ],
          "prompt": [
            674
          ],
          "start": [
            237
          ],
          "unwrap_count": [
            560
          ],
          "violation_line": [
            234,
            329
          ],
          "surrounding_code": [
            239
          ],
          "is_async": [
            285
          ],
          "return_type": [
            281
          ],
          "code_patterns": [
            181
          ],
          "ai_instructions": [
            183
          ],
          "confidence_score": [
            215
          ],
          "(function_name,": [
            242
          ],
          "is_generic": [
            286
          ],
          "Some(start)": [
            416,
            499
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "architectural_style": [
            580
          ],
          "content": [
            842
          ],
          "fix_strategies": [
            182
          ],
          "confidence": [
            871
          ],
          "lines": [
            233,
            313,
            328
          ],
          "signature": [
            280
          ],
          "function_calls": [
            342
          ],
          "Some(var_name)": [
            406
          ],
          "side_effects": [
            214
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 374,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "        }",
          "    } else {",
          "        None",
          "    }",
          "}",
          "",
          "fn infer_expected_type(violation_type: &ViolationType) -> Option<String> {",
          "    match violation_type {",
          "        ViolationType::UnwrapInProduction => Some(\"Result or Option\".to_string()),",
          "        _ => None,",
          "    }"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 374: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "imports": [
            250,
            841
          ],
          "architectural_style": [
            580
          ],
          "data_flow": [
            335
          ],
          "\")": [
            405
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "code_context": [
            209
          ],
          "prompt": [
            674
          ],
          "(function_name,": [
            242
          ],
          "confidence": [
            871
          ],
          "code_patterns": [
            181
          ],
          "Item": [
            277
          ],
          "Some(ast)": [
            243
          ],
          "semantic_analysis": [
            210
          ],
          "start": [
            237
          ],
          "line": [
            361
          ],
          "dependencies": [
            213
          ],
          "lines": [
            233,
            313,
            328
          ],
          "signature": [
            280
          ],
          "end": [
            238
          ],
          "error_handling_style": [
            257
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "function_calls": [
            342
          ],
          "actual_type": [
            331
          ],
          "expected_type": [
            332
          ],
          "fix_strategies": [
            182
          ],
          "error_propagation_path": [
            345
          ],
          "rest": [
            417,
            500
          ],
          "name": [
            279
          ],
          "Some(dep)": [
            486
          ],
          "unwrap_count": [
            560
          ],
          "violations_of_complexity": [
            787
          ],
          "semantic": [
            861
          ],
          "control_flow": [
            336
          ],
          "return_type": [
            281
          ],
          "surrounding_code": [
            239
          ],
          "Ok(analysis)": [
            175
          ],
          "Some(var_name)": [
            406
          ],
          "system_prompt": [
            655
          ],
          "ai_instructions": [
            183
          ],
          "ast": [
            207
          ],
          "fix_complexity": [
            211
          ],
          "violation_line": [
            234,
            329
          ],
          "variable_usage": [
            339
          ],
          "content": [
            842
          ],
          "side_effects": [
            214
          ],
          "confidence_score": [
            215
          ],
          "Some(start)": [
            416,
            499
          ],
          "error_handling_pattern": [
            583
          ],
          "style": [
            843
          ],
          "context": [
            849
          ],
          "is_generic": [
            286
          ],
          "is_async": [
            285
          ],
          "file_content": [
            204
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 381,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "    match violation_type {",
          "        ViolationType::UnwrapInProduction => Some(\"Result or Option\".to_string()),",
          "        _ => None,",
          "    }",
          "}",
          "",
          "fn trace_data_flow(lines: &[&str], line_idx: usize) -> Vec<String> {",
          "    // Simplified data flow tracing",
          "    let mut flow = Vec::new();",
          "    if line_idx < lines.len() {",
          "        flow.push(format!(\"Line {}: {}\", line_idx + 1, lines[line_idx].trim()));"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 381: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "semantic_analysis": [
            210
          ],
          "side_effects": [
            214
          ],
          "name": [
            279
          ],
          "function_calls": [
            342
          ],
          "file_content": [
            204
          ],
          "expected_type": [
            332
          ],
          "data_flow": [
            335
          ],
          "code_context": [
            209
          ],
          "fix_strategies": [
            182
          ],
          "lines": [
            233,
            313,
            328
          ],
          "Some(var_name)": [
            406
          ],
          "confidence_score": [
            215
          ],
          "is_async": [
            285
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "unwrap_count": [
            560
          ],
          "error_handling_pattern": [
            583
          ],
          "surrounding_code": [
            239
          ],
          "Item": [
            277
          ],
          "Ok(analysis)": [
            175
          ],
          "code_patterns": [
            181
          ],
          "ast": [
            207
          ],
          "fix_complexity": [
            211
          ],
          "dependencies": [
            213
          ],
          "start": [
            237
          ],
          "imports": [
            250,
            841
          ],
          "return_type": [
            281
          ],
          "actual_type": [
            331
          ],
          "rest": [
            417,
            500
          ],
          "error_propagation_path": [
            345
          ],
          "prompt": [
            674
          ],
          "system_prompt": [
            655
          ],
          "Some(ast)": [
            243
          ],
          "content": [
            842
          ],
          "violation_line": [
            234,
            329
          ],
          "end": [
            238
          ],
          "style": [
            843
          ],
          "error_handling_style": [
            257
          ],
          "context": [
            849
          ],
          "Some(dep)": [
            486
          ],
          "semantic": [
            861
          ],
          "confidence": [
            871
          ],
          "variable_usage": [
            339
          ],
          "violations_of_complexity": [
            787
          ],
          "Some(start)": [
            416,
            499
          ],
          "ai_instructions": [
            183
          ],
          "control_flow": [
            336
          ],
          "is_generic": [
            286
          ],
          "signature": [
            280
          ],
          "line": [
            361
          ],
          "architectural_style": [
            580
          ],
          "\")": [
            405
          ],
          "(function_name,": [
            242
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 390,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "    if line_idx < lines.len() {",
          "        flow.push(format!(\"Line {}: {}\", line_idx + 1, lines[line_idx].trim()));",
          "    }",
          "    flow",
          "}",
          "",
          "fn trace_control_flow(lines: &[&str], line_idx: usize) -> Vec<String> {",
          "    // Simplified control flow tracing",
          "    let mut flow = Vec::new();",
          "    for (i, line) in lines.iter().enumerate() {",
          "        if line.contains(\"if \") || line.contains(\"match \") || line.contains(\"for \") {"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 390: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "code_patterns": [
            181
          ],
          "lines": [
            233,
            313,
            328
          ],
          "name": [
            279
          ],
          "Item": [
            277
          ],
          "expected_type": [
            332
          ],
          "semantic": [
            861
          ],
          "return_type": [
            281
          ],
          "error_handling_style": [
            257
          ],
          "control_flow": [
            336
          ],
          "rest": [
            417,
            500
          ],
          "\")": [
            405
          ],
          "is_generic": [
            286
          ],
          "surrounding_code": [
            239
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "content": [
            842
          ],
          "ai_instructions": [
            183
          ],
          "end": [
            238
          ],
          "code_context": [
            209
          ],
          "side_effects": [
            214
          ],
          "confidence_score": [
            215
          ],
          "Ok(analysis)": [
            175
          ],
          "(function_name,": [
            242
          ],
          "imports": [
            250,
            841
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "fix_complexity": [
            211
          ],
          "actual_type": [
            331
          ],
          "data_flow": [
            335
          ],
          "signature": [
            280
          ],
          "variable_usage": [
            339
          ],
          "Some(var_name)": [
            406
          ],
          "unwrap_count": [
            560
          ],
          "architectural_style": [
            580
          ],
          "error_handling_pattern": [
            583
          ],
          "Some(dep)": [
            486
          ],
          "system_prompt": [
            655
          ],
          "prompt": [
            674
          ],
          "Some(ast)": [
            243
          ],
          "semantic_analysis": [
            210
          ],
          "confidence": [
            871
          ],
          "ast": [
            207
          ],
          "is_async": [
            285
          ],
          "function_calls": [
            342
          ],
          "file_content": [
            204
          ],
          "violation_line": [
            234,
            329
          ],
          "start": [
            237
          ],
          "dependencies": [
            213
          ],
          "violations_of_complexity": [
            787
          ],
          "Some(start)": [
            416,
            499
          ],
          "fix_strategies": [
            182
          ],
          "style": [
            843
          ],
          "error_propagation_path": [
            345
          ],
          "line": [
            361
          ],
          "context": [
            849
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 438,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "            }",
          "        }",
          "    }",
          "    calls",
          "}",
          "",
          "fn trace_error_propagation(lines: &[&str], line_idx: usize) -> Vec<String> {",
          "    // Simplified error propagation tracing",
          "    let mut path = Vec::new();",
          "    for (i, line) in lines.iter().enumerate() {",
          "        if line.contains('?') || line.contains(\".unwrap()\") || line.contains(\".expect(\") {"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 438: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "architectural_style": [
            580
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "ast": [
            207
          ],
          "content": [
            842
          ],
          "imports": [
            250,
            841
          ],
          "Item": [
            277
          ],
          "Some(var_name)": [
            406
          ],
          "rest": [
            417,
            500
          ],
          "error_handling_pattern": [
            583
          ],
          "confidence": [
            871
          ],
          "ai_instructions": [
            183
          ],
          "code_patterns": [
            181
          ],
          "code_context": [
            209
          ],
          "confidence_score": [
            215
          ],
          "fix_complexity": [
            211
          ],
          "surrounding_code": [
            239
          ],
          "is_generic": [
            286
          ],
          "start": [
            237
          ],
          "variable_usage": [
            339
          ],
          "Some(dep)": [
            486
          ],
          "unwrap_count": [
            560
          ],
          "lines": [
            233,
            313,
            328
          ],
          "signature": [
            280
          ],
          "system_prompt": [
            655
          ],
          "violations_of_complexity": [
            787
          ],
          "name": [
            279
          ],
          "function_calls": [
            342
          ],
          "line": [
            361
          ],
          "\")": [
            405
          ],
          "context": [
            849
          ],
          "is_async": [
            285
          ],
          "violation_line": [
            234,
            329
          ],
          "end": [
            238
          ],
          "Some(ast)": [
            243
          ],
          "error_handling_style": [
            257
          ],
          "actual_type": [
            331
          ],
          "expected_type": [
            332
          ],
          "Some(start)": [
            416,
            499
          ],
          "error_propagation_path": [
            345
          ],
          "dependencies": [
            213
          ],
          "return_type": [
            281
          ],
          "prompt": [
            674
          ],
          "style": [
            843
          ],
          "control_flow": [
            336
          ],
          "semantic_analysis": [
            210
          ],
          "semantic": [
            861
          ],
          "(function_name,": [
            242
          ],
          "side_effects": [
            214
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "Ok(analysis)": [
            175
          ],
          "file_content": [
            204
          ],
          "data_flow": [
            335
          ],
          "fix_strategies": [
            182
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 442,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "}",
          "",
          "fn trace_error_propagation(lines: &[&str], line_idx: usize) -> Vec<String> {",
          "    // Simplified error propagation tracing",
          "    let mut path = Vec::new();",
          "    for (i, line) in lines.iter().enumerate() {",
          "        if line.contains('?') || line.contains(\".unwrap()\") || line.contains(\".expect(\") {",
          "            path.push(format!(\"Line {}: Error handling point\", i + 1));",
          "        }",
          "    }",
          "    path"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 442: for (i, line) in lines.iter().enumerate() {"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "unwrap_count": [
            560
          ],
          "violation_line": [
            234,
            329
          ],
          "variable_usage": [
            339
          ],
          "Some(start)": [
            416,
            499
          ],
          "error_handling_pattern": [
            583
          ],
          "lines": [
            233,
            313,
            328
          ],
          "Some(ast)": [
            243
          ],
          "error_handling_style": [
            257
          ],
          "control_flow": [
            336
          ],
          "\")": [
            405
          ],
          "style": [
            843
          ],
          "architectural_style": [
            580
          ],
          "semantic_analysis": [
            210
          ],
          "context": [
            849
          ],
          "file_content": [
            204
          ],
          "confidence_score": [
            215
          ],
          "prompt": [
            674
          ],
          "Ok(analysis)": [
            175
          ],
          "ai_instructions": [
            183
          ],
          "is_generic": [
            286
          ],
          "end": [
            238
          ],
          "Item": [
            277
          ],
          "line": [
            361
          ],
          "system_prompt": [
            655
          ],
          "semantic": [
            861
          ],
          "(function_name,": [
            242
          ],
          "ast": [
            207
          ],
          "start": [
            237
          ],
          "fix_complexity": [
            211
          ],
          "dependencies": [
            213
          ],
          "fix_strategies": [
            182
          ],
          "surrounding_code": [
            239
          ],
          "data_flow": [
            335
          ],
          "function_calls": [
            342
          ],
          "Some(var_name)": [
            406
          ],
          "confidence": [
            871
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "actual_type": [
            331
          ],
          "expected_type": [
            332
          ],
          "rest": [
            417,
            500
          ],
          "is_async": [
            285
          ],
          "code_patterns": [
            181
          ],
          "code_context": [
            209
          ],
          "imports": [
            250,
            841
          ],
          "signature": [
            280
          ],
          "return_type": [
            281
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "violations_of_complexity": [
            787
          ],
          "Some(dep)": [
            486
          ],
          "name": [
            279
          ],
          "error_propagation_path": [
            345
          ],
          "content": [
            842
          ],
          "side_effects": [
            214
          ]
        },
        "function_calls": [
          "for",
          "iter",
          "enumerate"
        ],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn",
        "for",
        "iter",
        "enumerate"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 442,
        "message": "BANNED: .expect() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "}",
          "",
          "fn trace_error_propagation(lines: &[&str], line_idx: usize) -> Vec<String> {",
          "    // Simplified error propagation tracing",
          "    let mut path = Vec::new();",
          "    for (i, line) in lines.iter().enumerate() {",
          "        if line.contains('?') || line.contains(\".unwrap()\") || line.contains(\".expect(\") {",
          "            path.push(format!(\"Line {}: Error handling point\", i + 1));",
          "        }",
          "    }",
          "    path"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 442: for (i, line) in lines.iter().enumerate() {"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "violation_line": [
            234,
            329
          ],
          "\")": [
            405
          ],
          "prompt": [
            674
          ],
          "violations_of_complexity": [
            787
          ],
          "fix_strategies": [
            182
          ],
          "content": [
            842
          ],
          "style": [
            843
          ],
          "context": [
            849
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "end": [
            238
          ],
          "Some(ast)": [
            243
          ],
          "name": [
            279
          ],
          "Item": [
            277
          ],
          "return_type": [
            281
          ],
          "surrounding_code": [
            239
          ],
          "error_handling_style": [
            257
          ],
          "dependencies": [
            213
          ],
          "control_flow": [
            336
          ],
          "is_generic": [
            286
          ],
          "rest": [
            417,
            500
          ],
          "semantic": [
            861
          ],
          "ai_instructions": [
            183
          ],
          "start": [
            237
          ],
          "signature": [
            280
          ],
          "imports": [
            250,
            841
          ],
          "confidence": [
            871
          ],
          "file_content": [
            204
          ],
          "unwrap_count": [
            560
          ],
          "code_context": [
            209
          ],
          "data_flow": [
            335
          ],
          "actual_type": [
            331
          ],
          "error_propagation_path": [
            345
          ],
          "function_calls": [
            342
          ],
          "lines": [
            233,
            313,
            328
          ],
          "ast": [
            207
          ],
          "Some(start)": [
            416,
            499
          ],
          "variable_usage": [
            339
          ],
          "is_async": [
            285
          ],
          "side_effects": [
            214
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "expected_type": [
            332
          ],
          "architectural_style": [
            580
          ],
          "Ok(analysis)": [
            175
          ],
          "confidence_score": [
            215
          ],
          "line": [
            361
          ],
          "Some(var_name)": [
            406
          ],
          "error_handling_pattern": [
            583
          ],
          "(function_name,": [
            242
          ],
          "system_prompt": [
            655
          ],
          "fix_complexity": [
            211
          ],
          "semantic_analysis": [
            210
          ],
          "code_patterns": [
            181
          ],
          "Some(dep)": [
            486
          ]
        },
        "function_calls": [
          "for",
          "iter",
          "enumerate"
        ],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn",
        "for",
        "iter",
        "enumerate"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 575,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "            locations: violations",
          "                .iter()",
          "                .filter(|v| matches!(v.violation_type, ViolationType::UnwrapInProduction))",
          "                .map(|v| format!(\"{}:{}\", v.file.display(), v.line))",
          "                .take(5)",
          "                .collect(),",
          "            description: \"Heavy use of .unwrap() indicates poor error handling\".to_string(),",
          "        });",
          "    }",
          "",
          "    // Detect architectural style (simplified)"
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 575: .collect(),"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "content": [
            842
          ],
          "code_patterns": [
            181
          ],
          "Item": [
            277
          ],
          "Some(start)": [
            416,
            499
          ],
          "lines": [
            233,
            313,
            328
          ],
          "Some(dep)": [
            486
          ],
          "data_flow": [
            335
          ],
          "name": [
            279
          ],
          "expected_type": [
            332
          ],
          "semantic": [
            861
          ],
          "surrounding_code": [
            239
          ],
          "confidence_score": [
            215
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "is_generic": [
            286
          ],
          "error_propagation_path": [
            345
          ],
          "style": [
            843
          ],
          "context": [
            849
          ],
          "confidence": [
            871
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "violations_of_complexity": [
            787
          ],
          "imports": [
            250,
            841
          ],
          "ast": [
            207
          ],
          "semantic_analysis": [
            210
          ],
          "fix_strategies": [
            182
          ],
          "file_content": [
            204
          ],
          "start": [
            237
          ],
          "error_handling_style": [
            257
          ],
          "\")": [
            405
          ],
          "violation_line": [
            234,
            329
          ],
          "signature": [
            280
          ],
          "actual_type": [
            331
          ],
          "side_effects": [
            214
          ],
          "return_type": [
            281
          ],
          "function_calls": [
            342
          ],
          "code_context": [
            209
          ],
          "dependencies": [
            213
          ],
          "Some(var_name)": [
            406
          ],
          "fix_complexity": [
            211
          ],
          "(function_name,": [
            242
          ],
          "unwrap_count": [
            560
          ],
          "control_flow": [
            336
          ],
          "error_handling_pattern": [
            583
          ],
          "rest": [
            417,
            500
          ],
          "is_async": [
            285
          ],
          "variable_usage": [
            339
          ],
          "end": [
            238
          ],
          "line": [
            361
          ],
          "architectural_style": [
            580
          ],
          "ai_instructions": [
            183
          ],
          "Some(ast)": [
            243
          ],
          "system_prompt": [
            655
          ],
          "prompt": [
            674
          ],
          "Ok(analysis)": [
            175
          ]
        },
        "function_calls": [
          "collect"
        ],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn",
        "collect"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/ai_analyzer.rs",
        "line": 608,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "analyze_violations_for_ai",
        "function_signature": "# [doc = \" Performs deep AI-powered analysis of violations\"] pub async fn analyze_violations_for_ai (violations : & [Violation] , project_path : & Path ,) -> anyhow :: Result < AIAnalysisReport > { println ! (\"🤖 Performing AI-powered code analysis...\") ; let mut violation_analyses = Vec :: new () ; let mut analyzed_count = 0 ; for violation in violations . iter () . take (100) { if let Ok (analysis) = analyze_single_violation (violation , project_path) . await { violation_analyses . push (analysis) ; analyzed_count += 1 ; } } let code_patterns = detect_code_patterns (project_path , violations) ? ; let fix_strategies = generate_fix_strategies (violations , & code_patterns) ; let ai_instructions = generate_ai_instructions (& violation_analyses , & fix_strategies) ; Ok (AIAnalysisReport { metadata : AnalysisMetadata { timestamp : chrono :: Utc :: now () . to_rfc3339 () , total_violations : violations . len () , analyzable_violations : analyzed_count , project_path : project_path . display () . to_string () , analysis_depth : AnalysisDepth :: Semantic , } , violation_analyses , code_patterns , fix_strategies , ai_instructions , }) } . sig",
        "return_type": "anyhow :: Result < AIAnalysisReport >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "        if lines[i].contains(\"impl\") && lines[i].contains(\"for\") {",
        "surrounding_code": [
          "        violation_type: \"UnwrapInProduction\".to_string(),",
          "        strategy_name: \"Progressive Error Handling Migration\".to_string(),",
          "        description: \"Gradually replace unwrap() with proper error handling\".to_string(),",
          "        steps: vec![",
          "            \"1. Identify function return types\".to_string(),",
          "            \"2. Add Result return types where missing\".to_string(),",
          "            \"3. Replace .unwrap() with ? operator\".to_string(),",
          "            \"4. Add context with anyhow::Context trait\".to_string(),",
          "            \"5. Implement custom error types for domain errors\".to_string(),",
          "        ],",
          "        prerequisites: vec!["
        ],
        "imports": [
          "use crate::validation::{Violation, ViolationType};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use syn::{parse_file, Item, ItemFn, ReturnType, Type};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 608: \"2. Add Result return types where missing\".to_string(),"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 4: Control structure",
          "Line 14: Control structure",
          "Line 25: Control structure",
          "Line 174: Control structure",
          "Line 175: Control structure",
          "Line 176: Control structure",
          "Line 207: Control structure",
          "Line 242: Control structure",
          "Line 244: Control structure",
          "Line 277: Control structure",
          "Line 278: Control structure",
          "Line 282: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 301: Control structure",
          "Line 303: Control structure",
          "Line 305: Control structure",
          "Line 315: Control structure",
          "Line 316: Control structure",
          "Line 361: Control structure",
          "Line 363: Control structure",
          "Line 365: Control structure",
          "Line 376: Control structure",
          "Line 385: Control structure",
          "Line 394: Control structure",
          "Line 395: Control structure",
          "Line 405: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 417: Control structure",
          "Line 419: Control structure",
          "Line 429: Control structure",
          "Line 430: Control structure",
          "Line 431: Control structure",
          "Line 442: Control structure",
          "Line 443: Control structure",
          "Line 455: Control structure",
          "Line 457: Control structure",
          "Line 463: Control structure",
          "Line 470: Control structure",
          "Line 486: Control structure",
          "Line 487: Control structure",
          "Line 500: Control structure",
          "Line 502: Control structure",
          "Line 512: Control structure",
          "Line 513: Control structure",
          "Line 532: Control structure",
          "Line 533: Control structure",
          "Line 536: Control structure",
          "Line 539: Control structure",
          "Line 542: Control structure",
          "Line 566: Control structure",
          "Line 584: Control structure",
          "Line 601: Control structure",
          "Line 611: Control structure",
          "Line 618: Control structure",
          "Line 625: Control structure",
          "Line 631: Control structure",
          "Line 635: Control structure",
          "Line 642: Control structure",
          "Line 643: Control structure",
          "Line 663: Control structure",
          "Line 674: Control structure",
          "Line 704: Control structure",
          "Line 725: Control structure",
          "Line 745: Control structure",
          "Line 757: Control structure",
          "Line 781: Control structure",
          "Line 791: Control structure",
          "Line 794: Control structure",
          "Line 801: Control structure",
          "Line 815: Control structure",
          "Line 829: Control structure"
        ],
        "variable_usage": {
          "confidence_score": [
            215
          ],
          "semantic_analysis": [
            210
          ],
          "confidence": [
            871
          ],
          "unwrap_count": [
            560
          ],
          "fix_strategies": [
            182
          ],
          "control_flow": [
            336
          ],
          "is_async": [
            285
          ],
          "dependencies": [
            213
          ],
          "surrounding_code": [
            239
          ],
          "name": [
            279
          ],
          "Item": [
            277
          ],
          "line": [
            361
          ],
          "rest": [
            417,
            500
          ],
          "error_handling_style": [
            257
          ],
          "violations_of_complexity": [
            787
          ],
          "ai_instructions": [
            183
          ],
          "context": [
            849
          ],
          "return_type": [
            281
          ],
          "Some(ast)": [
            243
          ],
          "error_handling_pattern": [
            583
          ],
          "\")": [
            405
          ],
          "code_context": [
            209
          ],
          "violation_line": [
            234,
            329
          ],
          "Ok(analysis)": [
            175
          ],
          "Some(var_name)": [
            406
          ],
          "actual_type": [
            331
          ],
          "end": [
            238
          ],
          "error_propagation_path": [
            345
          ],
          "semantic": [
            861
          ],
          "is_generic": [
            286
          ],
          "side_effects": [
            214
          ],
          "Some(end)": [
            418,
            430,
            501
          ],
          "style": [
            843
          ],
          "variable_usage": [
            339
          ],
          "ast": [
            207
          ],
          "lines": [
            233,
            313,
            328
          ],
          "mut": [
            170,
            171,
            383,
            392,
            403,
            427,
            440,
            482,
            509,
            529,
            556,
            557,
            598,
            671,
            748
          ],
          "code_patterns": [
            181
          ],
          "data_flow": [
            335
          ],
          "expected_type": [
            332
          ],
          "imports": [
            250,
            841
          ],
          "file_content": [
            204
          ],
          "function_calls": [
            342
          ],
          "Some(start)": [
            416,
            499
          ],
          "(function_name,": [
            242
          ],
          "system_prompt": [
            655
          ],
          "signature": [
            280
          ],
          "Some(dep)": [
            486
          ],
          "fix_complexity": [
            211
          ],
          "start": [
            237
          ],
          "prompt": [
            674
          ],
          "architectural_style": [
            580
          ],
          "content": [
            842
          ]
        },
        "function_calls": [
          "to_string"
        ],
        "error_propagation_path": [
          "Line 182: Error handling point",
          "Line 205: Error handling point",
          "Line 210: Error handling point",
          "Line 211: Error handling point",
          "Line 305: Error handling point",
          "Line 443: Error handling point",
          "Line 576: Error handling point",
          "Line 609: Error handling point",
          "Line 714: Error handling point",
          "Line 717: Error handling point",
          "Line 718: Error handling point",
          "Line 719: Error handling point",
          "Line 720: Error handling point",
          "Line 729: Error handling point",
          "Line 796: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std",
        "std",
        "syn",
        "to_string"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/edition.rs",
        "line": 232,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "handle_check",
        "function_signature": "# [doc = \" Handle edition check command\"] pub async fn handle_check (path : & Path) -> Result < () > { let spinner = ProgressBar :: new_spinner () ; spinner . set_style (ProgressStyle :: default_spinner () . template (\"{spinner:.green} {msg}\") . unwrap_or_else (| _ | ProgressStyle :: default_spinner ()) ,) ; spinner . set_message (\"Checking edition compliance...\") ; spinner . enable_steady_tick (std :: time :: Duration :: from_millis (100)) ; let status = check_compliance (path) . await ? ; spinner . finish_and_clear () ; println ! (\"📚 Edition Compliance Status\\n\") ; println ! (\"  Project:  {}\" , style (path . display ()) . dim ()) ; println ! (\"  Manifest: {}\" , style (status . manifest_path . display ()) . dim ()) ; println ! () ; let current_style = if status . is_latest { style (status . current . to_string ()) . green () } else { style (status . current . to_string ()) . yellow () } ; println ! (\"  Current:  {}\" , current_style) ; println ! (\"  Latest:   {}\" , style (status . latest . to_string ()) . green ()) ; println ! () ; if status . is_latest { println ! (\"{}\" , style (\"✅ Your project is using the latest edition!\") . green () . bold ()) ; } else { println ! (\"{}\" , style (\"⚠️  An edition update is available\") . yellow () . bold ()) ; if ! status . migration_path . is_empty () { println ! (\"\\nMigration path:\") ; let path_str = status . migration_path . iter () . map (| e | e . to_string ()) . collect :: < Vec < _ > > () . join (\" → \") ; println ! (\"  {} → {}\" , status . current , style (path_str) . cyan ()) ; } } println ! (\"\\n📋 Recommendations:\") ; for recommendation in get_migration_recommendations (& status) { println ! (\"  • {}\" , recommendation) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    println!(\"  4. Commit the changes to version control\");",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Handle edition analyze command",
          "pub async fn handle_analyze(path: &Path, edition_str: &str) -> Result<()> {",
          "    let target_edition = Edition::parse_edition(edition_str)?;",
          "",
          "    println!(\"🔍 Edition Compatibility Analysis\\n\");",
          "    println!(\"  Project:  {}\", style(path.display()).dim());"
        ],
        "imports": [
          "use crate::edition::{",
          "use crate::Result;",
          "use console::style;",
          "use indicatif::{ProgressBar, ProgressStyle};",
          "use std::path::Path;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 232: /// Handle edition analyze command"
        ],
        "control_flow": [
          "Line 35: Control structure",
          "Line 46: Control structure",
          "Line 59: Control structure",
          "Line 72: Control structure",
          "Line 96: Control structure",
          "Line 116: Control structure",
          "Line 131: Control structure",
          "Line 153: Control structure",
          "Line 162: Control structure",
          "Line 187: Control structure",
          "Line 189: Control structure",
          "Line 195: Control structure",
          "Line 197: Control structure",
          "Line 203: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 258: Control structure",
          "Line 266: Control structure",
          "Line 274: Control structure",
          "Line 276: Control structure",
          "Line 277: Control structure",
          "Line 285: Control structure",
          "Line 287: Control structure",
          "Line 297: Control structure",
          "Line 299: Control structure",
          "Line 305: Control structure",
          "Line 307: Control structure",
          "Line 314: Control structure",
          "Line 317: Control structure"
        ],
        "variable_usage": {
          "current_style": [
            34
          ],
          "Some(file)": [
            284
          ],
          "Some(backup_path)": [
            209
          ],
          "Some(line)": [
            286
          ],
          "target_edition": [
            85,
            233
          ],
          "current_edition": [
            93
          ],
          "options": [
            138
          ],
          "analyzer": [
            248
          ],
          "severity_style": [
            276
          ],
          "spinner": [
            13,
            145,
            239
          ],
          "result": [
            157
          ],
          "path_str": [
            60
          ],
          "project_path": [
            86
          ],
          "status": [
            22
          ],
          "report": [
            249
          ],
          "migrator": [
            136
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 23: Error handling point",
          "Line 86: Error handling point",
          "Line 87: Error handling point",
          "Line 94: Error handling point",
          "Line 158: Error handling point",
          "Line 234: Error handling point",
          "Line 250: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "crate",
        "console",
        "indicatif",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 470,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        has_anyhow_import,",
          "        has_thiserror_import,",
          "        function_signatures,",
          "    }",
          "}",
          "",
          "fn parse_function_signature(line: &str, line_num: usize) -> Option<FunctionSignature> {",
          "    let trimmed = line.trim();",
          "",
          "    if !trimmed.starts_with(\"fn \")",
          "        && !trimmed.starts_with(\"pub fn \")"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 470: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "Some(skip)": [
            317
          ],
          "line_idx": [
            386
          ],
          "trimmed": [
            471
          ],
          "unfixed_violations": [
            187
          ],
          "project_path": [
            34
          ],
          "Some(end)": [
            546
          ],
          "is_test": [
            488
          ],
          "rest": [
            600
          ],
          "orchestrator_instructions": [
            228
          ],
          "before": [
            548
          ],
          "is_bin_file": [
            445
          ],
          "has_anyhow_import": [
            448
          ],
          "only_types": [
            50
          ],
          "Some(rest)": [
            599
          ],
          "original_line": [
            387
          ],
          "message": [
            547
          ],
          "expr": [
            613
          ],
          "name": [
            483
          ],
          "Some(only)": [
            310
          ],
          "has_thiserror_import": [
            449
          ],
          "instructions_path": [
            231
          ],
          "reports_dir": [
            215
          ],
          "violation": [
            645,
            666
          ],
          "validator": [
            57
          ],
          "Some(start)": [
            545
          ],
          "_": [
            596,
            597
          ],
          "timestamp": [
            218
          ],
          "violation_type": [
            307
          ],
          "is_main": [
            489
          ],
          "violations_by_file": [
            93
          ],
          "violations_to_fix": [
            61
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "violations": [
            58
          ],
          "context": [
            643,
            664,
            701
          ],
          "returns_option": [
            487
          ],
          "lines": [
            440
          ],
          "high_confidence": [
            254
          ],
          "indent": [
            614
          ],
          "fn_start": [
            481
          ],
          "fixed_content": [
            404,
            406
          ],
          "after": [
            549
          ],
          "line": [
            644,
            665
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "Some(sig)": [
            455
          ],
          "value": [
            655
          ],
          "report_json": [
            221
          ],
          "report_path": [
            219
          ],
          "is_example_file": [
            444
          ],
          "can_use_question_mark": [
            523
          ],
          "Some(limit)": [
            330
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "file_context": [
            379
          ],
          "skip_types": [
            53
          ],
          "Err(e)": [
            623
          ],
          "fn_end": [
            482
          ],
          "is_test_file": [
            443
          ],
          "returns_result": [
            486
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 515,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        ViolationType::UnwrapInProduction => fix_unwrap_in_line(line, violation, context),",
          "        ViolationType::UnderscoreBandaid => fix_underscore_in_line(line, violation, context),",
          "        _ => FixResult::NotApplicable,",
          "    }",
          "}",
          "",
          "fn fix_unwrap_in_line(line: &str, _violation: &Violation, context: &FileContext) -> FixResult {",
          "    // Skip fixes in test code",
          "    if context.is_test_file && line.contains(\"#[test]\") {",
          "        return FixResult::Skipped(\"Test code can use unwrap\".to_string());",
          "    }"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 515: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "has_anyhow_import": [
            448
          ],
          "line": [
            644,
            665
          ],
          "report_json": [
            221
          ],
          "trimmed": [
            471
          ],
          "is_test_file": [
            443
          ],
          "Some(start)": [
            545
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "violations_to_fix": [
            61
          ],
          "Some(sig)": [
            455
          ],
          "Some(skip)": [
            317
          ],
          "Err(e)": [
            623
          ],
          "before": [
            548
          ],
          "has_thiserror_import": [
            449
          ],
          "original_line": [
            387
          ],
          "violation_type": [
            307
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "is_bin_file": [
            445
          ],
          "indent": [
            614
          ],
          "violations_by_file": [
            93
          ],
          "is_test": [
            488
          ],
          "name": [
            483
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "orchestrator_instructions": [
            228
          ],
          "lines": [
            440
          ],
          "report_path": [
            219
          ],
          "Some(only)": [
            310
          ],
          "message": [
            547
          ],
          "violation": [
            645,
            666
          ],
          "instructions_path": [
            231
          ],
          "only_types": [
            50
          ],
          "after": [
            549
          ],
          "project_path": [
            34
          ],
          "unfixed_violations": [
            187
          ],
          "_": [
            596,
            597
          ],
          "high_confidence": [
            254
          ],
          "fn_start": [
            481
          ],
          "Some(end)": [
            546
          ],
          "file_context": [
            379
          ],
          "is_main": [
            489
          ],
          "reports_dir": [
            215
          ],
          "Some(limit)": [
            330
          ],
          "returns_option": [
            487
          ],
          "returns_result": [
            486
          ],
          "can_use_question_mark": [
            523
          ],
          "skip_types": [
            53
          ],
          "context": [
            643,
            664,
            701
          ],
          "value": [
            655
          ],
          "line_idx": [
            386
          ],
          "fixed_content": [
            404,
            406
          ],
          "is_example_file": [
            444
          ],
          "violations": [
            58
          ],
          "fn_end": [
            482
          ],
          "expr": [
            613
          ],
          "validator": [
            57
          ],
          "rest": [
            600
          ],
          "timestamp": [
            218
          ],
          "Some(rest)": [
            599
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 521,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "fn fix_unwrap_in_line(line: &str, _violation: &Violation, context: &FileContext) -> FixResult {",
          "    // Skip fixes in test code",
          "    if context.is_test_file && line.contains(\"#[test]\") {",
          "        return FixResult::Skipped(\"Test code can use unwrap\".to_string());",
          "    }",
          "",
          "    if line.contains(\".unwrap()\") {",
          "        // Check if we're in a function that can use ?",
          "        let can_use_question_mark = check_can_use_question_mark(line, context);",
          "",
          "        if !can_use_question_mark {"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 521: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "has_thiserror_import": [
            449
          ],
          "fn_start": [
            481
          ],
          "returns_option": [
            487
          ],
          "fn_end": [
            482
          ],
          "Some(end)": [
            546
          ],
          "Err(e)": [
            623
          ],
          "has_anyhow_import": [
            448
          ],
          "Some(skip)": [
            317
          ],
          "high_confidence": [
            254
          ],
          "only_types": [
            50
          ],
          "skip_types": [
            53
          ],
          "returns_result": [
            486
          ],
          "lines": [
            440
          ],
          "message": [
            547
          ],
          "before": [
            548
          ],
          "file_context": [
            379
          ],
          "Some(sig)": [
            455
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "original_line": [
            387
          ],
          "Some(limit)": [
            330
          ],
          "Some(rest)": [
            599
          ],
          "fixed_content": [
            404,
            406
          ],
          "trimmed": [
            471
          ],
          "violation": [
            645,
            666
          ],
          "value": [
            655
          ],
          "Some(only)": [
            310
          ],
          "report_json": [
            221
          ],
          "context": [
            643,
            664,
            701
          ],
          "unfixed_violations": [
            187
          ],
          "after": [
            549
          ],
          "violations_to_fix": [
            61
          ],
          "timestamp": [
            218
          ],
          "rest": [
            600
          ],
          "indent": [
            614
          ],
          "is_example_file": [
            444
          ],
          "is_test_file": [
            443
          ],
          "violations_by_file": [
            93
          ],
          "name": [
            483
          ],
          "can_use_question_mark": [
            523
          ],
          "reports_dir": [
            215
          ],
          "expr": [
            613
          ],
          "project_path": [
            34
          ],
          "instructions_path": [
            231
          ],
          "is_main": [
            489
          ],
          "_": [
            596,
            597
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "line": [
            644,
            665
          ],
          "violations": [
            58
          ],
          "is_test": [
            488
          ],
          "is_bin_file": [
            445
          ],
          "violation_type": [
            307
          ],
          "report_path": [
            219
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "orchestrator_instructions": [
            228
          ],
          "validator": [
            57
          ],
          "Some(start)": [
            545
          ],
          "line_idx": [
            386
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 528,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        // Check if we're in a function that can use ?",
          "        let can_use_question_mark = check_can_use_question_mark(line, context);",
          "",
          "        if !can_use_question_mark {",
          "            // Try to use expect with a meaningful message instead",
          "            if context.is_example_file || context.is_bin_file {",
          "                let fixed = line.replace(\".unwrap()\", \".expect(\\\"Failed to process\\\")\");",
          "                return FixResult::Fixed(fixed);",
          "            }",
          "            return FixResult::Skipped(\"Cannot use ? operator in this context\".to_string());",
          "        }"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 528: if context.is_example_file || context.is_bin_file {"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "Err(e)": [
            623
          ],
          "fn_start": [
            481
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "value": [
            655
          ],
          "is_bin_file": [
            445
          ],
          "is_test": [
            488
          ],
          "violations_to_fix": [
            61
          ],
          "is_test_file": [
            443
          ],
          "is_example_file": [
            444
          ],
          "Some(rest)": [
            599
          ],
          "line_idx": [
            386
          ],
          "high_confidence": [
            254
          ],
          "_": [
            596,
            597
          ],
          "context": [
            643,
            664,
            701
          ],
          "violations_by_file": [
            93
          ],
          "lines": [
            440
          ],
          "can_use_question_mark": [
            523
          ],
          "has_anyhow_import": [
            448
          ],
          "reports_dir": [
            215
          ],
          "name": [
            483
          ],
          "timestamp": [
            218
          ],
          "Some(only)": [
            310
          ],
          "file_context": [
            379
          ],
          "original_line": [
            387
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "Some(end)": [
            546
          ],
          "Some(start)": [
            545
          ],
          "rest": [
            600
          ],
          "report_json": [
            221
          ],
          "fixed_content": [
            404,
            406
          ],
          "validator": [
            57
          ],
          "violation_type": [
            307
          ],
          "fn_end": [
            482
          ],
          "trimmed": [
            471
          ],
          "indent": [
            614
          ],
          "returns_result": [
            486
          ],
          "is_main": [
            489
          ],
          "has_thiserror_import": [
            449
          ],
          "before": [
            548
          ],
          "Some(sig)": [
            455
          ],
          "line": [
            644,
            665
          ],
          "orchestrator_instructions": [
            228
          ],
          "expr": [
            613
          ],
          "instructions_path": [
            231
          ],
          "report_path": [
            219
          ],
          "project_path": [
            34
          ],
          "unfixed_violations": [
            187
          ],
          "Some(limit)": [
            330
          ],
          "returns_option": [
            487
          ],
          "Some(skip)": [
            317
          ],
          "violations": [
            58
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "after": [
            549
          ],
          "skip_types": [
            53
          ],
          "violation": [
            645,
            666
          ],
          "only_types": [
            50
          ],
          "message": [
            547
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 528,
        "message": "BANNED: .expect() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        // Check if we're in a function that can use ?",
          "        let can_use_question_mark = check_can_use_question_mark(line, context);",
          "",
          "        if !can_use_question_mark {",
          "            // Try to use expect with a meaningful message instead",
          "            if context.is_example_file || context.is_bin_file {",
          "                let fixed = line.replace(\".unwrap()\", \".expect(\\\"Failed to process\\\")\");",
          "                return FixResult::Fixed(fixed);",
          "            }",
          "            return FixResult::Skipped(\"Cannot use ? operator in this context\".to_string());",
          "        }"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 528: if context.is_example_file || context.is_bin_file {"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "is_test_file": [
            443
          ],
          "Some(end)": [
            546
          ],
          "is_main": [
            489
          ],
          "line": [
            644,
            665
          ],
          "violation_type": [
            307
          ],
          "is_test": [
            488
          ],
          "has_anyhow_import": [
            448
          ],
          "before": [
            548
          ],
          "Some(limit)": [
            330
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "returns_option": [
            487
          ],
          "Some(start)": [
            545
          ],
          "_": [
            596,
            597
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "Some(sig)": [
            455
          ],
          "message": [
            547
          ],
          "fixed_content": [
            404,
            406
          ],
          "instructions_path": [
            231
          ],
          "project_path": [
            34
          ],
          "returns_result": [
            486
          ],
          "expr": [
            613
          ],
          "has_thiserror_import": [
            449
          ],
          "fn_end": [
            482
          ],
          "fn_start": [
            481
          ],
          "validator": [
            57
          ],
          "Some(skip)": [
            317
          ],
          "can_use_question_mark": [
            523
          ],
          "unfixed_violations": [
            187
          ],
          "is_example_file": [
            444
          ],
          "Err(e)": [
            623
          ],
          "lines": [
            440
          ],
          "trimmed": [
            471
          ],
          "report_path": [
            219
          ],
          "file_context": [
            379
          ],
          "Some(rest)": [
            599
          ],
          "violations_to_fix": [
            61
          ],
          "reports_dir": [
            215
          ],
          "after": [
            549
          ],
          "high_confidence": [
            254
          ],
          "Some(only)": [
            310
          ],
          "line_idx": [
            386
          ],
          "name": [
            483
          ],
          "violations_by_file": [
            93
          ],
          "context": [
            643,
            664,
            701
          ],
          "original_line": [
            387
          ],
          "rest": [
            600
          ],
          "only_types": [
            50
          ],
          "timestamp": [
            218
          ],
          "skip_types": [
            53
          ],
          "violation": [
            645,
            666
          ],
          "violations": [
            58
          ],
          "indent": [
            614
          ],
          "is_bin_file": [
            445
          ],
          "orchestrator_instructions": [
            228
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "report_json": [
            221
          ],
          "value": [
            655
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 535,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "                return FixResult::Fixed(fixed);",
          "            }",
          "            return FixResult::Skipped(\"Cannot use ? operator in this context\".to_string());",
          "        }",
          "",
          "        // Safe to replace with ?",
          "        return FixResult::Fixed(line.replace(\".unwrap()\", \"?\"));",
          "    }",
          "",
          "    if line.contains(\".expect(\") {",
          "        // Only fix if we have anyhow for context"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 535: // Safe to replace with ?"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "can_use_question_mark": [
            523
          ],
          "skip_types": [
            53
          ],
          "is_test_file": [
            443
          ],
          "timestamp": [
            218
          ],
          "is_test": [
            488
          ],
          "Err(e)": [
            623
          ],
          "has_thiserror_import": [
            449
          ],
          "Some(skip)": [
            317
          ],
          "fixed_content": [
            404,
            406
          ],
          "fn_end": [
            482
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "Some(rest)": [
            599
          ],
          "unfixed_violations": [
            187
          ],
          "returns_option": [
            487
          ],
          "Some(limit)": [
            330
          ],
          "fn_start": [
            481
          ],
          "report_json": [
            221
          ],
          "line_idx": [
            386
          ],
          "has_anyhow_import": [
            448
          ],
          "orchestrator_instructions": [
            228
          ],
          "lines": [
            440
          ],
          "indent": [
            614
          ],
          "report_path": [
            219
          ],
          "Some(end)": [
            546
          ],
          "name": [
            483
          ],
          "violation": [
            645,
            666
          ],
          "Some(sig)": [
            455
          ],
          "violations_to_fix": [
            61
          ],
          "original_line": [
            387
          ],
          "trimmed": [
            471
          ],
          "instructions_path": [
            231
          ],
          "Some(only)": [
            310
          ],
          "violation_type": [
            307
          ],
          "_": [
            596,
            597
          ],
          "after": [
            549
          ],
          "is_example_file": [
            444
          ],
          "returns_result": [
            486
          ],
          "violations": [
            58
          ],
          "Some(start)": [
            545
          ],
          "only_types": [
            50
          ],
          "validator": [
            57
          ],
          "violations_by_file": [
            93
          ],
          "value": [
            655
          ],
          "before": [
            548
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "is_main": [
            489
          ],
          "line": [
            644,
            665
          ],
          "message": [
            547
          ],
          "is_bin_file": [
            445
          ],
          "high_confidence": [
            254
          ],
          "reports_dir": [
            215
          ],
          "project_path": [
            34
          ],
          "expr": [
            613
          ],
          "context": [
            643,
            664,
            701
          ],
          "rest": [
            600
          ],
          "file_context": [
            379
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 538,
        "message": "BANNED: .expect() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        }",
          "",
          "        // Safe to replace with ?",
          "        return FixResult::Fixed(line.replace(\".unwrap()\", \"?\"));",
          "    }",
          "",
          "    if line.contains(\".expect(\") {",
          "        // Only fix if we have anyhow for context",
          "        if !context.has_anyhow_import {",
          "            return FixResult::Skipped(\"No anyhow import for .context()\".to_string());",
          "        }"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 538: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "file_context": [
            379
          ],
          "unfixed_violations": [
            187
          ],
          "has_thiserror_import": [
            449
          ],
          "Err(e)": [
            623
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "violation_type": [
            307
          ],
          "violations_by_file": [
            93
          ],
          "context": [
            643,
            664,
            701
          ],
          "is_test_file": [
            443
          ],
          "is_bin_file": [
            445
          ],
          "message": [
            547
          ],
          "report_path": [
            219
          ],
          "is_example_file": [
            444
          ],
          "line": [
            644,
            665
          ],
          "can_use_question_mark": [
            523
          ],
          "Some(only)": [
            310
          ],
          "violations_to_fix": [
            61
          ],
          "name": [
            483
          ],
          "has_anyhow_import": [
            448
          ],
          "is_test": [
            488
          ],
          "Some(sig)": [
            455
          ],
          "Some(end)": [
            546
          ],
          "fn_end": [
            482
          ],
          "reports_dir": [
            215
          ],
          "returns_result": [
            486
          ],
          "_": [
            596,
            597
          ],
          "violations": [
            58
          ],
          "report_json": [
            221
          ],
          "before": [
            548
          ],
          "after": [
            549
          ],
          "Some(rest)": [
            599
          ],
          "only_types": [
            50
          ],
          "lines": [
            440
          ],
          "indent": [
            614
          ],
          "Some(skip)": [
            317
          ],
          "expr": [
            613
          ],
          "project_path": [
            34
          ],
          "timestamp": [
            218
          ],
          "rest": [
            600
          ],
          "high_confidence": [
            254
          ],
          "skip_types": [
            53
          ],
          "instructions_path": [
            231
          ],
          "Some(start)": [
            545
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "fixed_content": [
            404,
            406
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "value": [
            655
          ],
          "validator": [
            57
          ],
          "line_idx": [
            386
          ],
          "orchestrator_instructions": [
            228
          ],
          "returns_option": [
            487
          ],
          "fn_start": [
            481
          ],
          "is_main": [
            489
          ],
          "original_line": [
            387
          ],
          "violation": [
            645,
            666
          ],
          "Some(limit)": [
            330
          ],
          "trimmed": [
            471
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 545,
        "message": "BANNED: .expect() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        // Only fix if we have anyhow for context",
          "        if !context.has_anyhow_import {",
          "            return FixResult::Skipped(\"No anyhow import for .context()\".to_string());",
          "        }",
          "",
          "        // Extract the expect message and convert to context",
          "        if let Some(start) = line.find(\".expect(\\\"\") {",
          "            if let Some(end) = line[start + 9..].find(\"\\\")\") {",
          "                let message = &line[start + 9..start + 9 + end];",
          "                let before = &line[..start];",
          "                let after = &line[start + 9 + end + 2..];"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 545: // Extract the expect message and convert to context"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "indent": [
            614
          ],
          "_": [
            596,
            597
          ],
          "file_context": [
            379
          ],
          "high_confidence": [
            254
          ],
          "violations_to_fix": [
            61
          ],
          "unfixed_violations": [
            187
          ],
          "returns_option": [
            487
          ],
          "fn_end": [
            482
          ],
          "value": [
            655
          ],
          "is_main": [
            489
          ],
          "lines": [
            440
          ],
          "is_bin_file": [
            445
          ],
          "name": [
            483
          ],
          "Some(end)": [
            546
          ],
          "violations_by_file": [
            93
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "instructions_path": [
            231
          ],
          "violations": [
            58
          ],
          "Some(sig)": [
            455
          ],
          "original_line": [
            387
          ],
          "violation_type": [
            307
          ],
          "is_test_file": [
            443
          ],
          "context": [
            643,
            664,
            701
          ],
          "fixed_content": [
            404,
            406
          ],
          "only_types": [
            50
          ],
          "line_idx": [
            386
          ],
          "timestamp": [
            218
          ],
          "trimmed": [
            471
          ],
          "Some(only)": [
            310
          ],
          "project_path": [
            34
          ],
          "can_use_question_mark": [
            523
          ],
          "report_json": [
            221
          ],
          "returns_result": [
            486
          ],
          "has_anyhow_import": [
            448
          ],
          "fn_start": [
            481
          ],
          "Some(skip)": [
            317
          ],
          "report_path": [
            219
          ],
          "Some(limit)": [
            330
          ],
          "violation": [
            645,
            666
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "message": [
            547
          ],
          "is_example_file": [
            444
          ],
          "before": [
            548
          ],
          "skip_types": [
            53
          ],
          "orchestrator_instructions": [
            228
          ],
          "after": [
            549
          ],
          "validator": [
            57
          ],
          "line": [
            644,
            665
          ],
          "expr": [
            613
          ],
          "is_test": [
            488
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "Some(start)": [
            545
          ],
          "has_thiserror_import": [
            449
          ],
          "rest": [
            600
          ],
          "Err(e)": [
            623
          ],
          "Some(rest)": [
            599
          ],
          "reports_dir": [
            215
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 596,
        "message": "BANNED: Underscore assignment (let _ =) - handle errors properly",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "",
          "        // For now, just warn about underscore parameters",
          "        // Proper fix would require analyzing if the parameter is actually needed",
          "        return FixResult::Skipped(\"Underscore parameters need manual review\".to_string());",
          "    }",
          "",
          "    // Fix let _ = assignments",
          "    if line.trim_start().starts_with(\"let _ =\") {",
          "        // Check if the expression likely returns Result",
          "        if let Some(rest) = line.trim_start().strip_prefix(\"let _ =\") {",
          "            let rest = rest.trim();"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 596: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "violations_by_file": [
            93
          ],
          "returns_result": [
            486
          ],
          "fn_end": [
            482
          ],
          "Some(skip)": [
            317
          ],
          "line": [
            644,
            665
          ],
          "orchestrator_instructions": [
            228
          ],
          "Some(sig)": [
            455
          ],
          "context": [
            643,
            664,
            701
          ],
          "trimmed": [
            471
          ],
          "is_test": [
            488
          ],
          "Err(e)": [
            623
          ],
          "reports_dir": [
            215
          ],
          "line_idx": [
            386
          ],
          "name": [
            483
          ],
          "Some(limit)": [
            330
          ],
          "Some(rest)": [
            599
          ],
          "timestamp": [
            218
          ],
          "report_json": [
            221
          ],
          "violation_type": [
            307
          ],
          "report_path": [
            219
          ],
          "unfixed_violations": [
            187
          ],
          "violations_to_fix": [
            61
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "file_context": [
            379
          ],
          "is_example_file": [
            444
          ],
          "fn_start": [
            481
          ],
          "fixed_content": [
            404,
            406
          ],
          "is_main": [
            489
          ],
          "Some(only)": [
            310
          ],
          "project_path": [
            34
          ],
          "rest": [
            600
          ],
          "original_line": [
            387
          ],
          "Some(end)": [
            546
          ],
          "has_anyhow_import": [
            448
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "violations": [
            58
          ],
          "only_types": [
            50
          ],
          "indent": [
            614
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "value": [
            655
          ],
          "_": [
            596,
            597
          ],
          "is_test_file": [
            443
          ],
          "Some(start)": [
            545
          ],
          "lines": [
            440
          ],
          "after": [
            549
          ],
          "expr": [
            613
          ],
          "message": [
            547
          ],
          "violation": [
            645,
            666
          ],
          "has_thiserror_import": [
            449
          ],
          "skip_types": [
            53
          ],
          "validator": [
            57
          ],
          "can_use_question_mark": [
            523
          ],
          "instructions_path": [
            231
          ],
          "before": [
            548
          ],
          "is_bin_file": [
            445
          ],
          "returns_option": [
            487
          ],
          "high_confidence": [
            254
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 597,
        "message": "BANNED: Underscore assignment (let _ =) - handle errors properly",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        // For now, just warn about underscore parameters",
          "        // Proper fix would require analyzing if the parameter is actually needed",
          "        return FixResult::Skipped(\"Underscore parameters need manual review\".to_string());",
          "    }",
          "",
          "    // Fix let _ = assignments",
          "    if line.trim_start().starts_with(\"let _ =\") {",
          "        // Check if the expression likely returns Result",
          "        if let Some(rest) = line.trim_start().strip_prefix(\"let _ =\") {",
          "            let rest = rest.trim();",
          ""
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 597: // Fix let _ = assignments"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "violation": [
            645,
            666
          ],
          "name": [
            483
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "report_json": [
            221
          ],
          "has_anyhow_import": [
            448
          ],
          "violation_type": [
            307
          ],
          "indent": [
            614
          ],
          "lines": [
            440
          ],
          "skip_types": [
            53
          ],
          "line_idx": [
            386
          ],
          "only_types": [
            50
          ],
          "Some(limit)": [
            330
          ],
          "trimmed": [
            471
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "is_bin_file": [
            445
          ],
          "Some(skip)": [
            317
          ],
          "Some(sig)": [
            455
          ],
          "Some(end)": [
            546
          ],
          "report_path": [
            219
          ],
          "returns_option": [
            487
          ],
          "has_thiserror_import": [
            449
          ],
          "Some(start)": [
            545
          ],
          "project_path": [
            34
          ],
          "fixed_content": [
            404,
            406
          ],
          "orchestrator_instructions": [
            228
          ],
          "is_test_file": [
            443
          ],
          "expr": [
            613
          ],
          "instructions_path": [
            231
          ],
          "fn_start": [
            481
          ],
          "_": [
            596,
            597
          ],
          "is_main": [
            489
          ],
          "returns_result": [
            486
          ],
          "line": [
            644,
            665
          ],
          "violations": [
            58
          ],
          "reports_dir": [
            215
          ],
          "message": [
            547
          ],
          "after": [
            549
          ],
          "Some(only)": [
            310
          ],
          "before": [
            548
          ],
          "is_example_file": [
            444
          ],
          "original_line": [
            387
          ],
          "fn_end": [
            482
          ],
          "file_context": [
            379
          ],
          "Err(e)": [
            623
          ],
          "context": [
            643,
            664,
            701
          ],
          "high_confidence": [
            254
          ],
          "is_test": [
            488
          ],
          "violations_to_fix": [
            61
          ],
          "timestamp": [
            218
          ],
          "violations_by_file": [
            93
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "rest": [
            600
          ],
          "can_use_question_mark": [
            523
          ],
          "validator": [
            57
          ],
          "unfixed_violations": [
            187
          ],
          "Some(rest)": [
            599
          ],
          "value": [
            655
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/fix.rs",
        "line": 599,
        "message": "BANNED: Underscore assignment (let _ =) - handle errors properly",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the fix command\"] pub async fn execute (path : Option < PathBuf > , only : Option < String > , skip : Option < String > , dry_run : bool , limit : Option < usize > ,) -> Result < () > { execute_with_ai (path , only , skip , dry_run , limit , false) . await } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "//! This module implements intelligent auto-fixing for common Rust anti-patterns.",
        "surrounding_code": [
          "        return FixResult::Skipped(\"Underscore parameters need manual review\".to_string());",
          "    }",
          "",
          "    // Fix let _ = assignments",
          "    if line.trim_start().starts_with(\"let _ =\") {",
          "        // Check if the expression likely returns Result",
          "        if let Some(rest) = line.trim_start().strip_prefix(\"let _ =\") {",
          "            let rest = rest.trim();",
          "",
          "            // Don't fix if it's a drop pattern",
          "            if rest.contains(\"drop(\") || rest.contains(\"mem::drop\") {"
        ],
        "imports": [
          "use crate::ai_analyzer;",
          "use crate::validation::{RustValidator, Violation, ViolationType};",
          "use crate::Result;",
          "use anyhow::Context;",
          "use console::style;",
          "use std::collections::{HashMap, HashSet};",
          "use std::fs;",
          "use std::path::{Path, PathBuf};",
          "use anyhow::Result;",
          "use thiserror::Error;"
        ],
        "error_handling_style": "Anyhow"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 599: // Check if the expression likely returns Result"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 43: Control structure",
          "Line 64: Control structure",
          "Line 86: Control structure",
          "Line 93: Control structure",
          "Line 100: Control structure",
          "Line 101: Control structure",
          "Line 105: Control structure",
          "Line 113: Control structure",
          "Line 136: Control structure",
          "Line 142: Control structure",
          "Line 151: Control structure",
          "Line 160: Control structure",
          "Line 168: Control structure",
          "Line 173: Control structure",
          "Line 176: Control structure",
          "Line 177: Control structure",
          "Line 196: Control structure",
          "Line 198: Control structure",
          "Line 245: Control structure",
          "Line 250: Control structure",
          "Line 261: Control structure",
          "Line 268: Control structure",
          "Line 281: Control structure",
          "Line 283: Control structure",
          "Line 311: Control structure",
          "Line 312: Control structure",
          "Line 318: Control structure",
          "Line 319: Control structure",
          "Line 330: Control structure",
          "Line 331: Control structure",
          "Line 339: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 360: Control structure",
          "Line 379: Control structure",
          "Line 382: Control structure",
          "Line 383: Control structure",
          "Line 390: Control structure",
          "Line 392: Control structure",
          "Line 404: Control structure",
          "Line 406: Control structure",
          "Line 407: Control structure",
          "Line 448: Control structure",
          "Line 455: Control structure",
          "Line 456: Control structure",
          "Line 474: Control structure",
          "Line 509: Control structure",
          "Line 518: Control structure",
          "Line 522: Control structure",
          "Line 523: Control structure",
          "Line 526: Control structure",
          "Line 528: Control structure",
          "Line 539: Control structure",
          "Line 540: Control structure",
          "Line 541: Control structure",
          "Line 542: Control structure",
          "Line 546: Control structure",
          "Line 547: Control structure",
          "Line 563: Control structure",
          "Line 568: Control structure",
          "Line 572: Control structure",
          "Line 574: Control structure",
          "Line 575: Control structure",
          "Line 580: Control structure",
          "Line 586: Control structure",
          "Line 587: Control structure",
          "Line 588: Control structure",
          "Line 593: Control structure",
          "Line 598: Control structure",
          "Line 599: Control structure",
          "Line 600: Control structure",
          "Line 603: Control structure",
          "Line 604: Control structure",
          "Line 608: Control structure",
          "Line 609: Control structure",
          "Line 613: Control structure",
          "Line 617: Control structure",
          "Line 618: Control structure",
          "Line 624: Control structure",
          "Line 654: Control structure",
          "Line 675: Control structure"
        ],
        "variable_usage": {
          "Some(limit)": [
            330
          ],
          "report_path": [
            219
          ],
          "_": [
            596,
            597
          ],
          "timestamp": [
            218
          ],
          "before": [
            548
          ],
          "Some(start)": [
            545
          ],
          "high_confidence": [
            254
          ],
          "returns_option": [
            487
          ],
          "violations_by_file": [
            93
          ],
          "is_test": [
            488
          ],
          "violation": [
            645,
            666
          ],
          "Some(sig)": [
            455
          ],
          "skip_types": [
            53
          ],
          "content": [
            371,
            642,
            663,
            684
          ],
          "after": [
            549
          ],
          "value": [
            655
          ],
          "context": [
            643,
            664,
            701
          ],
          "Err(e)": [
            623
          ],
          "Some(end)": [
            546
          ],
          "line_idx": [
            386
          ],
          "has_thiserror_import": [
            449
          ],
          "violation_type": [
            307
          ],
          "unfixed_violations": [
            187
          ],
          "instructions_path": [
            231
          ],
          "original_line": [
            387
          ],
          "fixed_content": [
            404,
            406
          ],
          "Some(skip)": [
            317
          ],
          "expr": [
            613
          ],
          "line": [
            644,
            665
          ],
          "has_anyhow_import": [
            448
          ],
          "Some(only)": [
            310
          ],
          "only_types": [
            50
          ],
          "is_example_file": [
            444
          ],
          "reports_dir": [
            215
          ],
          "fn_end": [
            482
          ],
          "fixed": [
            528,
            551,
            618,
            622
          ],
          "project_path": [
            34
          ],
          "mut": [
            95,
            96,
            97,
            243,
            304,
            349,
            374,
            375,
            376,
            453
          ],
          "rest": [
            600
          ],
          "message": [
            547
          ],
          "validator": [
            57
          ],
          "Some(rest)": [
            599
          ],
          "indent": [
            614
          ],
          "violations_to_fix": [
            61
          ],
          "returns_result": [
            486
          ],
          "trimmed": [
            471
          ],
          "orchestrator_instructions": [
            228
          ],
          "lines": [
            440
          ],
          "is_main": [
            489
          ],
          "is_test_file": [
            443
          ],
          "name": [
            483
          ],
          "can_use_question_mark": [
            523
          ],
          "fn_start": [
            481
          ],
          "report_json": [
            221
          ],
          "is_bin_file": [
            445
          ],
          "file_context": [
            379
          ],
          "violations": [
            58
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 58: Error handling point",
          "Line 59: Error handling point",
          "Line 217: Error handling point",
          "Line 222: Error handling point",
          "Line 223: Error handling point",
          "Line 230: Error handling point",
          "Line 234: Error handling point",
          "Line 247: Error handling point",
          "Line 308: Error handling point",
          "Line 373: Error handling point",
          "Line 413: Error handling point",
          "Line 482: Error handling point",
          "Line 483: Error handling point",
          "Line 522: Error handling point",
          "Line 523: Error handling point",
          "Line 529: Error handling point",
          "Line 532: Error handling point",
          "Line 535: Error handling point",
          "Line 536: Error handling point",
          "Line 539: Error handling point",
          "Line 546: Error handling point",
          "Line 552: Error handling point",
          "Line 562: Error handling point",
          "Line 567: Error handling point",
          "Line 580: Error handling point",
          "Line 617: Error handling point",
          "Line 619: Error handling point",
          "Line 643: Error handling point",
          "Line 645: Error handling point",
          "Line 656: Error handling point",
          "Line 664: Error handling point",
          "Line 666: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "crate",
        "crate",
        "anyhow",
        "console",
        "std",
        "std",
        "std",
        "anyhow",
        "thiserror"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/rust.rs",
        "line": 143,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "handle_check",
        "function_signature": "# [doc = \" Handle rust version check command\"] pub async fn handle_check (verbose : bool) -> Result < () > { let spinner = ProgressBar :: new_spinner () ; spinner . set_style (ProgressStyle :: default_spinner () . template (\"{spinner:.green} {msg}\") . unwrap_or_else (| _ | ProgressStyle :: default_spinner ()) ,) ; spinner . set_message (\"Checking Rust version...\") ; spinner . enable_steady_tick (std :: time :: Duration :: from_millis (100)) ; let manager = VersionManager :: new () ? ; let current = manager . check_current () . await ? ; spinner . set_message (\"Fetching latest release information...\") ; let latest = match manager . get_latest_stable () . await { Ok (release) => release , Err (Error :: RateLimited (retry_after)) => { spinner . finish_and_clear () ; println ! (\"{}\" , style (format ! (\"⚠️  GitHub API rate limited. Please try again in {} seconds.\" , retry_after)) . yellow ()) ; return Ok (()) ; } Err (e) => { spinner . finish_and_clear () ; println ! (\"{}\" , style (format ! (\"⚠️  Could not fetch latest release: {}. Using cached data if available.\" , e)) . yellow ()) ; println ! (\"\\nCurrent version: {}\" , style (current . to_string ()) . cyan ()) ; return Ok (()) ; } } ; spinner . finish_and_clear () ; println ! (\"🦀 Rust Version Status\\n\") ; println ! (\"  Current: {}\" , style (format ! (\"rustc {}\" , current . version)) . cyan ()) ; println ! (\"  Channel: {}\" , style (current . channel . to_string ()) . dim ()) ; println ! (\"  Host:    {}\" , style (current . host) . dim ()) ; if verbose { println ! (\"  Commit:  {}\" , style (current . commit_hash) . dim ()) ; println ! (\"  Date:    {}\" , style (current . commit_date . to_string ()) . dim ()) ; } println ! (\"\\n  Latest:  {}\" , style (format ! (\"rustc {}\" , latest . version)) . green ()) ; let recommendation = manager . get_recommendation () . await ? ; println ! () ; match recommendation { UpdateRecommendation :: UpToDate => { println ! (\"{}\" , style (\"✅ You're up to date!\") . green () . bold ()) ; } UpdateRecommendation :: MinorUpdate { current : _ , latest , release_url , } => { println ! (\"{}\" , style (\"📦 Update available!\") . yellow () . bold ()) ; println ! (\"\\n  Version {} is now available\" , style (latest) . yellow ()) ; println ! (\"  Release: {}\" , release_url) ; println ! (\"\\n  Run {} to update\" , style (\"rustup update stable\") . cyan ()) ; } UpdateRecommendation :: MajorUpdate { current : _ , latest , release_url , } => { println ! (\"{}\" , style (\"🚀 Major update available!\") . yellow () . bold ()) ; println ! (\"\\n  Version {} includes major changes\" , style (latest) . yellow ()) ; println ! (\"  Release: {}\" , release_url) ; println ! (\"\\n  Review release notes before updating:\") ; println ! (\"  {}\" , release_url) ; println ! (\"\\n  Run {} to update\" , style (\"rustup update stable\") . cyan ()) ; } UpdateRecommendation :: SecurityUpdate { current : _ , latest , release_url , details , } => { println ! (\"{}\" , style (\"🚨 SECURITY UPDATE AVAILABLE!\") . red () . bold ()) ; println ! (\"\\n  Version {} includes security fixes\" , style (latest) . red ()) ; if ! details . is_empty () { println ! (\"\\n  Security details:\") ; for line in details . lines () { println ! (\"    {}\" , line) ; } } println ! (\"\\n  Release: {}\" , release_url) ; println ! (\"\\n  {} {}\" , style (\"Strongly recommended:\") . red () . bold () , style (\"rustup update stable\") . cyan ()) ; } } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    }",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Handle rust version recommend command",
          "pub async fn handle_recommend(stable_only: bool) -> Result<()> {",
          "    let spinner = ProgressBar::new_spinner();",
          "    spinner.set_style(",
          "        ProgressStyle::default_spinner()",
          "            .template(\"{spinner:.green} {msg}\")"
        ],
        "imports": [
          "use crate::rust_version::{UpdateRecommendation, VersionManager};",
          "use crate::{Error, Result};",
          "use console::style;",
          "use indicatif::{ProgressBar, ProgressStyle};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 143: /// Handle rust version recommend command"
        ],
        "control_flow": [
          "Line 26: Control structure",
          "Line 45: Control structure",
          "Line 66: Control structure",
          "Line 83: Control structure",
          "Line 124: Control structure",
          "Line 126: Control structure",
          "Line 166: Control structure",
          "Line 176: Control structure",
          "Line 220: Control structure",
          "Line 224: Control structure",
          "Line 249: Control structure",
          "Line 254: Control structure",
          "Line 255: Control structure",
          "Line 271: Control structure",
          "Line 276: Control structure",
          "Line 277: Control structure"
        ],
        "variable_usage": {
          "Some(first_line)": [
            275
          ],
          "version_style": [
            254
          ],
          "current": [
            21,
            154
          ],
          "releases": [
            242
          ],
          "spinner": [
            9,
            144,
            232
          ],
          "recommendation": [
            79,
            155
          ],
          "manager": [
            18,
            153,
            241
          ],
          "latest": [
            25
          ],
          "truncated": [
            276
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 19: Error handling point",
          "Line 22: Error handling point",
          "Line 80: Error handling point",
          "Line 154: Error handling point",
          "Line 155: Error handling point",
          "Line 156: Error handling point",
          "Line 242: Error handling point",
          "Line 243: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "crate",
        "console",
        "indicatif"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/safety.rs",
        "line": 9,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "handle_install",
        "function_signature": "# [doc = \" Handle safety install command\"] pub async fn handle_install (force : bool , project_path : & Path) -> Result < () > { println ! (\"🔧 Installing Ferrous Forge Safety Pipeline Git Hooks\") ; println ! (\"{}\" , \"=\" . repeat (50)) ; let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (crate :: error :: Error :: Config (\"Not a git repository. Run 'git init' first.\" . to_string () ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) ? ; let pre_commit_path = hooks_dir . join (\"pre-commit\") ; let pre_commit_exists = pre_commit_path . exists () ; if pre_commit_exists && ! force { println ! (\"⚠️  Pre-commit hook already exists. Use --force to overwrite.\") ; } else { let pre_commit_content = r#\"#!/bin/bash\n# Ferrous Forge Safety Pipeline - Pre-Commit Hook\n\necho \"🦀 Running Ferrous Forge safety checks...\"\nferrous-forge safety check --stage pre-commit\n\nif [ $? -ne 0 ]; then\n    echo \"❌ Safety checks failed. Please fix the issues before committing.\"\n    exit 1\nfi\n\necho \"✅ All safety checks passed!\"\nexit 0\n\"# ; fs :: write (& pre_commit_path , pre_commit_content) ? ; # [cfg (unix)] { use std :: os :: unix :: fs :: PermissionsExt ; let mut perms = fs :: metadata (& pre_commit_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& pre_commit_path , perms) ? ; } println ! (\"✅ Installed pre-commit hook\") ; } let pre_push_path = hooks_dir . join (\"pre-push\") ; let pre_push_exists = pre_push_path . exists () ; if pre_push_exists && ! force { println ! (\"⚠️  Pre-push hook already exists. Use --force to overwrite.\") ; } else { let pre_push_content = r#\"#!/bin/bash\n# Ferrous Forge Safety Pipeline - Pre-Push Hook\n\necho \"🦀 Running Ferrous Forge safety checks...\"\nferrous-forge safety check --stage pre-push\n\nif [ $? -ne 0 ]; then\n    echo \"❌ Safety checks failed. Please fix the issues before pushing.\"\n    exit 1\nfi\n\necho \"✅ All safety checks passed!\"\nexit 0\n\"# ; fs :: write (& pre_push_path , pre_push_content) ? ; # [cfg (unix)] { use std :: os :: unix :: fs :: PermissionsExt ; let mut perms = fs :: metadata (& pre_push_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& pre_push_path , perms) ? ; } println ! (\"✅ Installed pre-push hook\") ; } println ! (\"\\n🎉 Safety pipeline git hooks installed successfully!\") ; println ! (\"\\n📝 Next steps:\") ; println ! (\"   1. The pre-commit hook will run before each commit\") ; println ! (\"   2. The pre-push hook will run before each push\") ; println ! (\"   3. To bypass temporarily: git commit --no-verify\") ; println ! (\"   4. To uninstall: Remove .git/hooks/pre-commit and pre-push\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::Result;",
          "use console::style;",
          "use std::fs;",
          "use std::path::Path;",
          "",
          "/// Handle safety install command",
          "pub async fn handle_install(force: bool, project_path: &Path) -> Result<()> {",
          "    println!(\"🔧 Installing Ferrous Forge Safety Pipeline Git Hooks\");",
          "    println!(\"{}\", \"=\".repeat(50));",
          "",
          "    // Check if it's a git repository"
        ],
        "imports": [
          "use crate::safety::{PipelineStage, SafetyPipeline};",
          "use crate::Result;",
          "use console::style;",
          "use std::fs;",
          "use std::path::Path;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 9: /// Handle safety install command"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 16: Control structure",
          "Line 29: Control structure",
          "Line 38: Control structure",
          "Line 61: Control structure",
          "Line 70: Control structure",
          "Line 109: Control structure",
          "Line 115: Control structure",
          "Line 140: Control structure",
          "Line 141: Control structure",
          "Line 144: Control structure",
          "Line 147: Control structure",
          "Line 153: Control structure",
          "Line 162: Control structure",
          "Line 171: Control structure",
          "Line 182: Control structure",
          "Line 184: Control structure",
          "Line 195: Control structure",
          "Line 197: Control structure",
          "Line 205: Control structure",
          "Line 213: Control structure"
        ],
        "variable_usage": {
          "pre_push_exists": [
            58
          ],
          "pre_push_path": [
            57
          ],
          "stage": [
            100
          ],
          "pre_push_hook": [
            200
          ],
          "mut": [
            49,
            81
          ],
          "hooks_dir": [
            21
          ],
          "git_dir": [
            14,
            195
          ],
          "pipeline": [
            105
          ],
          "report": [
            106
          ],
          "pre_commit_path": [
            25
          ],
          "pre_commit_hook": [
            199
          ],
          "pre_push_content": [
            63
          ],
          "pre_commit_exists": [
            26
          ],
          "pre_commit_content": [
            31
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 23: Error handling point",
          "Line 38: Error handling point",
          "Line 46: Error handling point",
          "Line 50: Error handling point",
          "Line 52: Error handling point",
          "Line 70: Error handling point",
          "Line 78: Error handling point",
          "Line 82: Error handling point",
          "Line 84: Error handling point",
          "Line 101: Error handling point",
          "Line 106: Error handling point",
          "Line 107: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "crate",
        "console",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/safety.rs",
        "line": 99,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "handle_install",
        "function_signature": "# [doc = \" Handle safety install command\"] pub async fn handle_install (force : bool , project_path : & Path) -> Result < () > { println ! (\"🔧 Installing Ferrous Forge Safety Pipeline Git Hooks\") ; println ! (\"{}\" , \"=\" . repeat (50)) ; let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (crate :: error :: Error :: Config (\"Not a git repository. Run 'git init' first.\" . to_string () ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) ? ; let pre_commit_path = hooks_dir . join (\"pre-commit\") ; let pre_commit_exists = pre_commit_path . exists () ; if pre_commit_exists && ! force { println ! (\"⚠️  Pre-commit hook already exists. Use --force to overwrite.\") ; } else { let pre_commit_content = r#\"#!/bin/bash\n# Ferrous Forge Safety Pipeline - Pre-Commit Hook\n\necho \"🦀 Running Ferrous Forge safety checks...\"\nferrous-forge safety check --stage pre-commit\n\nif [ $? -ne 0 ]; then\n    echo \"❌ Safety checks failed. Please fix the issues before committing.\"\n    exit 1\nfi\n\necho \"✅ All safety checks passed!\"\nexit 0\n\"# ; fs :: write (& pre_commit_path , pre_commit_content) ? ; # [cfg (unix)] { use std :: os :: unix :: fs :: PermissionsExt ; let mut perms = fs :: metadata (& pre_commit_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& pre_commit_path , perms) ? ; } println ! (\"✅ Installed pre-commit hook\") ; } let pre_push_path = hooks_dir . join (\"pre-push\") ; let pre_push_exists = pre_push_path . exists () ; if pre_push_exists && ! force { println ! (\"⚠️  Pre-push hook already exists. Use --force to overwrite.\") ; } else { let pre_push_content = r#\"#!/bin/bash\n# Ferrous Forge Safety Pipeline - Pre-Push Hook\n\necho \"🦀 Running Ferrous Forge safety checks...\"\nferrous-forge safety check --stage pre-push\n\nif [ $? -ne 0 ]; then\n    echo \"❌ Safety checks failed. Please fix the issues before pushing.\"\n    exit 1\nfi\n\necho \"✅ All safety checks passed!\"\nexit 0\n\"# ; fs :: write (& pre_push_path , pre_push_content) ? ; # [cfg (unix)] { use std :: os :: unix :: fs :: PermissionsExt ; let mut perms = fs :: metadata (& pre_push_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& pre_push_path , perms) ? ; } println ! (\"✅ Installed pre-push hook\") ; } println ! (\"\\n🎉 Safety pipeline git hooks installed successfully!\") ; println ! (\"\\n📝 Next steps:\") ; println ! (\"   1. The pre-commit hook will run before each commit\") ; println ! (\"   2. The pre-push hook will run before each push\") ; println ! (\"   3. To bypass temporarily: git commit --no-verify\") ; println ! (\"   4. To uninstall: Remove .git/hooks/pre-commit and pre-push\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    println!(\"   4. To uninstall: Remove .git/hooks/pre-commit and pre-push\");",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Handle safety check command",
          "pub async fn handle_check(stage_str: &str, project_path: &Path, verbose: bool) -> Result<()> {",
          "    let stage = stage_str.parse::<PipelineStage>()?;",
          "",
          "    println!(\"🧪 Testing Safety Pipeline - {}\", stage.display_name());",
          "    println!(\"{}\", \"=\".repeat(50));"
        ],
        "imports": [
          "use crate::safety::{PipelineStage, SafetyPipeline};",
          "use crate::Result;",
          "use console::style;",
          "use std::fs;",
          "use std::path::Path;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 99: /// Handle safety check command"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 16: Control structure",
          "Line 29: Control structure",
          "Line 38: Control structure",
          "Line 61: Control structure",
          "Line 70: Control structure",
          "Line 109: Control structure",
          "Line 115: Control structure",
          "Line 140: Control structure",
          "Line 141: Control structure",
          "Line 144: Control structure",
          "Line 147: Control structure",
          "Line 153: Control structure",
          "Line 162: Control structure",
          "Line 171: Control structure",
          "Line 182: Control structure",
          "Line 184: Control structure",
          "Line 195: Control structure",
          "Line 197: Control structure",
          "Line 205: Control structure",
          "Line 213: Control structure"
        ],
        "variable_usage": {
          "pipeline": [
            105
          ],
          "report": [
            106
          ],
          "pre_push_exists": [
            58
          ],
          "pre_commit_path": [
            25
          ],
          "git_dir": [
            14,
            195
          ],
          "pre_push_path": [
            57
          ],
          "pre_push_content": [
            63
          ],
          "pre_commit_content": [
            31
          ],
          "pre_commit_exists": [
            26
          ],
          "mut": [
            49,
            81
          ],
          "stage": [
            100
          ],
          "hooks_dir": [
            21
          ],
          "pre_commit_hook": [
            199
          ],
          "pre_push_hook": [
            200
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 23: Error handling point",
          "Line 38: Error handling point",
          "Line 46: Error handling point",
          "Line 50: Error handling point",
          "Line 52: Error handling point",
          "Line 70: Error handling point",
          "Line 78: Error handling point",
          "Line 82: Error handling point",
          "Line 84: Error handling point",
          "Line 101: Error handling point",
          "Line 106: Error handling point",
          "Line 107: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "crate",
        "console",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/safety.rs",
        "line": 226,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "handle_install",
        "function_signature": "# [doc = \" Handle safety install command\"] pub async fn handle_install (force : bool , project_path : & Path) -> Result < () > { println ! (\"🔧 Installing Ferrous Forge Safety Pipeline Git Hooks\") ; println ! (\"{}\" , \"=\" . repeat (50)) ; let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (crate :: error :: Error :: Config (\"Not a git repository. Run 'git init' first.\" . to_string () ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) ? ; let pre_commit_path = hooks_dir . join (\"pre-commit\") ; let pre_commit_exists = pre_commit_path . exists () ; if pre_commit_exists && ! force { println ! (\"⚠️  Pre-commit hook already exists. Use --force to overwrite.\") ; } else { let pre_commit_content = r#\"#!/bin/bash\n# Ferrous Forge Safety Pipeline - Pre-Commit Hook\n\necho \"🦀 Running Ferrous Forge safety checks...\"\nferrous-forge safety check --stage pre-commit\n\nif [ $? -ne 0 ]; then\n    echo \"❌ Safety checks failed. Please fix the issues before committing.\"\n    exit 1\nfi\n\necho \"✅ All safety checks passed!\"\nexit 0\n\"# ; fs :: write (& pre_commit_path , pre_commit_content) ? ; # [cfg (unix)] { use std :: os :: unix :: fs :: PermissionsExt ; let mut perms = fs :: metadata (& pre_commit_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& pre_commit_path , perms) ? ; } println ! (\"✅ Installed pre-commit hook\") ; } let pre_push_path = hooks_dir . join (\"pre-push\") ; let pre_push_exists = pre_push_path . exists () ; if pre_push_exists && ! force { println ! (\"⚠️  Pre-push hook already exists. Use --force to overwrite.\") ; } else { let pre_push_content = r#\"#!/bin/bash\n# Ferrous Forge Safety Pipeline - Pre-Push Hook\n\necho \"🦀 Running Ferrous Forge safety checks...\"\nferrous-forge safety check --stage pre-push\n\nif [ $? -ne 0 ]; then\n    echo \"❌ Safety checks failed. Please fix the issues before pushing.\"\n    exit 1\nfi\n\necho \"✅ All safety checks passed!\"\nexit 0\n\"# ; fs :: write (& pre_push_path , pre_push_content) ? ; # [cfg (unix)] { use std :: os :: unix :: fs :: PermissionsExt ; let mut perms = fs :: metadata (& pre_push_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& pre_push_path , perms) ? ; } println ! (\"✅ Installed pre-push hook\") ; } println ! (\"\\n🎉 Safety pipeline git hooks installed successfully!\") ; println ! (\"\\n📝 Next steps:\") ; println ! (\"   1. The pre-commit hook will run before each commit\") ; println ! (\"   2. The pre-push hook will run before each push\") ; println ! (\"   3. To bypass temporarily: git commit --no-verify\") ; println ! (\"   4. To uninstall: Remove .git/hooks/pre-commit and pre-push\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    }",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Test individual safety checks",
          "pub async fn test_individual_checks(project_path: &Path) -> Result<()> {",
          "    crate::safety::checks::test_runner::test_safety_checks(project_path).await",
          "}"
        ],
        "imports": [
          "use crate::safety::{PipelineStage, SafetyPipeline};",
          "use crate::Result;",
          "use console::style;",
          "use std::fs;",
          "use std::path::Path;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 226: /// Test individual safety checks"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 16: Control structure",
          "Line 29: Control structure",
          "Line 38: Control structure",
          "Line 61: Control structure",
          "Line 70: Control structure",
          "Line 109: Control structure",
          "Line 115: Control structure",
          "Line 140: Control structure",
          "Line 141: Control structure",
          "Line 144: Control structure",
          "Line 147: Control structure",
          "Line 153: Control structure",
          "Line 162: Control structure",
          "Line 171: Control structure",
          "Line 182: Control structure",
          "Line 184: Control structure",
          "Line 195: Control structure",
          "Line 197: Control structure",
          "Line 205: Control structure",
          "Line 213: Control structure"
        ],
        "variable_usage": {
          "pre_push_content": [
            63
          ],
          "pipeline": [
            105
          ],
          "mut": [
            49,
            81
          ],
          "pre_push_hook": [
            200
          ],
          "git_dir": [
            14,
            195
          ],
          "pre_push_exists": [
            58
          ],
          "pre_commit_exists": [
            26
          ],
          "pre_commit_content": [
            31
          ],
          "pre_commit_hook": [
            199
          ],
          "stage": [
            100
          ],
          "report": [
            106
          ],
          "hooks_dir": [
            21
          ],
          "pre_commit_path": [
            25
          ],
          "pre_push_path": [
            57
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 23: Error handling point",
          "Line 38: Error handling point",
          "Line 46: Error handling point",
          "Line 50: Error handling point",
          "Line 52: Error handling point",
          "Line 70: Error handling point",
          "Line 78: Error handling point",
          "Line 82: Error handling point",
          "Line 84: Error handling point",
          "Line 101: Error handling point",
          "Line 106: Error handling point",
          "Line 107: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "crate",
        "console",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/update.rs",
        "line": 6,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the update command\"] pub async fn execute (channel : String , rules_only : bool , dry_run : bool) -> Result < () > { if dry_run { println ! (\"{}\" , style (\"🔍 Dry run mode - showing what would be updated\") . bold () . yellow ()) ; } else { println ! (\"{}\" , style (\"🔄 Updating Ferrous Forge...\") . bold () . cyan ()) ; } if rules_only { update_rules (& channel , dry_run) . await ? ; } else { update_binary (& channel , dry_run) . await ? ; update_rules (& channel , dry_run) . await ? ; } if ! dry_run { println ! (\"{}\" , style (\"✅ Update complete!\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "//! Update command implementation",
          "",
          "use crate::Result;",
          "use console::style;",
          "",
          "/// Execute the update command",
          "pub async fn execute(channel: String, rules_only: bool, dry_run: bool) -> Result<()> {",
          "    if dry_run {",
          "        println!(",
          "            \"{}\",",
          "            style(\"🔍 Dry run mode - showing what would be updated\")"
        ],
        "imports": [
          "use crate::Result;",
          "use console::style;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 6: /// Execute the update command"
        ],
        "control_flow": [
          "Line 8: Control structure",
          "Line 19: Control structure",
          "Line 26: Control structure",
          "Line 34: Control structure",
          "Line 36: Control structure",
          "Line 37: Control structure",
          "Line 50: Control structure",
          "Line 52: Control structure"
        ],
        "variable_usage": {},
        "function_calls": [],
        "error_propagation_path": [
          "Line 20: Error handling point",
          "Line 22: Error handling point",
          "Line 23: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "console"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/update.rs",
        "line": 32,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the update command\"] pub async fn execute (channel : String , rules_only : bool , dry_run : bool) -> Result < () > { if dry_run { println ! (\"{}\" , style (\"🔍 Dry run mode - showing what would be updated\") . bold () . yellow ()) ; } else { println ! (\"{}\" , style (\"🔄 Updating Ferrous Forge...\") . bold () . cyan ()) ; } if rules_only { update_rules (& channel , dry_run) . await ? ; } else { update_binary (& channel , dry_run) . await ? ; update_rules (& channel , dry_run) . await ? ; } if ! dry_run { println ! (\"{}\" , style (\"✅ Update complete!\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        println!(\"{}\", style(\"✅ Update complete!\").bold().green());",
          "    }",
          "",
          "    Ok(())",
          "}",
          "",
          "async fn update_binary(channel: &str, dry_run: bool) -> Result<()> {",
          "    println!(\"📦 Checking for binary updates on {} channel...\", channel);",
          "",
          "    if dry_run {",
          "        println!(\"  Would check GitHub releases for newer version\");"
        ],
        "imports": [
          "use crate::Result;",
          "use console::style;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 32: "
        ],
        "control_flow": [
          "Line 8: Control structure",
          "Line 19: Control structure",
          "Line 26: Control structure",
          "Line 34: Control structure",
          "Line 36: Control structure",
          "Line 37: Control structure",
          "Line 50: Control structure",
          "Line 52: Control structure"
        ],
        "variable_usage": {},
        "function_calls": [],
        "error_propagation_path": [
          "Line 20: Error handling point",
          "Line 22: Error handling point",
          "Line 23: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "console"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/update.rs",
        "line": 48,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the update command\"] pub async fn execute (channel : String , rules_only : bool , dry_run : bool) -> Result < () > { if dry_run { println ! (\"{}\" , style (\"🔍 Dry run mode - showing what would be updated\") . bold () . yellow ()) ; } else { println ! (\"{}\" , style (\"🔄 Updating Ferrous Forge...\") . bold () . cyan ()) ; } if rules_only { update_rules (& channel , dry_run) . await ? ; } else { update_binary (& channel , dry_run) . await ? ; update_rules (& channel , dry_run) . await ? ; } if ! dry_run { println ! (\"{}\" , style (\"✅ Update complete!\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    println!(\"  ⚠️  Binary updates not yet implemented\");",
          "    println!(\"  Please update manually: cargo install ferrous-forge\");",
          "",
          "    Ok(())",
          "}",
          "",
          "async fn update_rules(channel: &str, dry_run: bool) -> Result<()> {",
          "    println!(\"📋 Checking for rules updates on {} channel...\", channel);",
          "",
          "    if dry_run {",
          "        println!(\"  Would fetch latest clippy rules from repository\");"
        ],
        "imports": [
          "use crate::Result;",
          "use console::style;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 48: "
        ],
        "control_flow": [
          "Line 8: Control structure",
          "Line 19: Control structure",
          "Line 26: Control structure",
          "Line 34: Control structure",
          "Line 36: Control structure",
          "Line 37: Control structure",
          "Line 50: Control structure",
          "Line 52: Control structure"
        ],
        "variable_usage": {},
        "function_calls": [],
        "error_propagation_path": [
          "Line 20: Error handling point",
          "Line 22: Error handling point",
          "Line 23: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "console"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/validate.rs",
        "line": 182,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the validate command\"] pub async fn execute (path : Option < PathBuf > , ai_report : bool , _compare_previous : bool ,) -> Result < () > { let project_path = path . unwrap_or_else (| | std :: env :: current_dir () . unwrap_or_default ()) ; println ! (\"{}\" , style (\"🦀 Running Ferrous Forge validation...\") . bold () . cyan ()) ; println ! (\"📁 Project: {}\" , project_path . display ()) ; println ! () ; let validator = RustValidator :: new (project_path . clone ()) ? ; let violations = validator . validate_project () . await ? ; let report = validator . generate_report (& violations) ; println ! (\"{}\" , report) ; if ai_report { println ! (\"\\n🤖 Generating AI-friendly compliance report...\") ; generate_ai_report (& project_path , & violations) . await ? ; } println ! (\"{}\" , style (\"🔧 Running Clippy with strict configuration...\") . bold () . yellow ()) ; let clippy_result = validator . run_clippy () . await ? ; if ! clippy_result . success { println ! (\"{}\" , style (\"❌ Clippy found issues:\") . red ()) ; println ! (\"{}\" , clippy_result . output) ; } else { println ! (\"{}\" , style (\"✅ Clippy validation passed!\") . green ()) ; } println ! () ; println ! (\"{}\" , style (\"📚 Checking documentation coverage...\") . bold () . yellow ()) ; match doc_coverage :: check_documentation_coverage (& project_path) . await { Ok (coverage) => { println ! (\"{}\" , coverage . report ()) ; if coverage . coverage_percent < 80.0 { println ! (\"{}\" , style (\"⚠️  Documentation coverage below 80%\") . yellow ()) ; } } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check documentation: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"📝 Checking code formatting...\") . bold () . yellow ()) ; match formatting :: check_formatting (& project_path) . await { Ok (format_result) => { println ! (\"{}\" , format_result . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check formatting: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"🔒 Running security audit...\") . bold () . yellow ()) ; match security :: run_security_audit (& project_path) . await { Ok (audit_report) => { println ! (\"{}\" , audit_report . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not run security audit: {}\" , e)) . yellow ()) ; } } if ! violations . is_empty () || ! clippy_result . success { std :: process :: exit (1) ; } else { println ! () ; println ! (\"{}\" , style (\"🎉 All validations passed! Code meets Ferrous Forge standards.\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    }",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Generate AI-friendly compliance report",
          "async fn generate_ai_report(project_path: &PathBuf, violations: &[Violation]) -> Result<()> {",
          "    use chrono::Utc;",
          "",
          "    // Create reports directory",
          "    let reports_dir = project_path.join(\".ferrous-forge\").join(\"reports\");"
        ],
        "imports": [
          "use crate::{",
          "use console::style;",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::path::PathBuf;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 182: /// Generate AI-friendly compliance report"
        ],
        "control_flow": [
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 103: Control structure",
          "Line 118: Control structure",
          "Line 121: Control structure",
          "Line 139: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure",
          "Line 196: Control structure",
          "Line 204: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 212: Control structure",
          "Line 263: Control structure",
          "Line 264: Control structure",
          "Line 300: Control structure",
          "Line 351: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 366: Control structure",
          "Line 377: Control structure",
          "Line 380: Control structure",
          "Line 381: Control structure",
          "Line 407: Control structure",
          "Line 409: Control structure",
          "Line 417: Control structure",
          "Line 421: Control structure"
        ],
        "variable_usage": {
          "(strategy,": [
            263
          ],
          "json_content": [
            330
          ],
          "clippy_result": [
            100
          ],
          "timestamp": [
            190
          ],
          "md_content": [
            336
          ],
          "validator": [
            78
          ],
          "violations": [
            81
          ],
          "timestamp_str": [
            191
          ],
          "mut": [
            194,
            202,
            261,
            374,
            377,
            391
          ],
          "code_snippet": [
            205
          ],
          "latest_md": [
            341
          ],
          "contents": [
            362
          ],
          "compliance_percentage": [
            299
          ],
          "_": [
            219
          ],
          "Some(ext)": [
            379
          ],
          "files_with_violations": [
            293
          ],
          "(suggested_fix,": [
            209
          ],
          "report": [
            84,
            306
          ],
          "lines": [
            363
          ],
          "total_files": [
            292
          ],
          "Some(entry)": [
            378
          ],
          "latest_json": [
            340
          ],
          "project_path": [
            66
          ],
          "json_path": [
            329
          ],
          "reports_dir": [
            186
          ],
          "md_path": [
            335
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 79: Error handling point",
          "Line 82: Error handling point",
          "Line 91: Error handling point",
          "Line 101: Error handling point",
          "Line 188: Error handling point",
          "Line 198: Error handling point",
          "Line 220: Error handling point",
          "Line 227: Error handling point",
          "Line 250: Error handling point",
          "Line 271: Error handling point",
          "Line 272: Error handling point",
          "Line 293: Error handling point",
          "Line 332: Error handling point",
          "Line 333: Error handling point",
          "Line 338: Error handling point",
          "Line 343: Error handling point",
          "Line 344: Error handling point",
          "Line 363: Error handling point",
          "Line 378: Error handling point",
          "Line 379: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "console",
        "serde",
        "std",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/validate.rs",
        "line": 219,
        "message": "BANNED: Underscore assignment (let _ =) - handle errors properly",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the validate command\"] pub async fn execute (path : Option < PathBuf > , ai_report : bool , _compare_previous : bool ,) -> Result < () > { let project_path = path . unwrap_or_else (| | std :: env :: current_dir () . unwrap_or_default ()) ; println ! (\"{}\" , style (\"🦀 Running Ferrous Forge validation...\") . bold () . cyan ()) ; println ! (\"📁 Project: {}\" , project_path . display ()) ; println ! () ; let validator = RustValidator :: new (project_path . clone ()) ? ; let violations = validator . validate_project () . await ? ; let report = validator . generate_report (& violations) ; println ! (\"{}\" , report) ; if ai_report { println ! (\"\\n🤖 Generating AI-friendly compliance report...\") ; generate_ai_report (& project_path , & violations) . await ? ; } println ! (\"{}\" , style (\"🔧 Running Clippy with strict configuration...\") . bold () . yellow ()) ; let clippy_result = validator . run_clippy () . await ? ; if ! clippy_result . success { println ! (\"{}\" , style (\"❌ Clippy found issues:\") . red ()) ; println ! (\"{}\" , clippy_result . output) ; } else { println ! (\"{}\" , style (\"✅ Clippy validation passed!\") . green ()) ; } println ! () ; println ! (\"{}\" , style (\"📚 Checking documentation coverage...\") . bold () . yellow ()) ; match doc_coverage :: check_documentation_coverage (& project_path) . await { Ok (coverage) => { println ! (\"{}\" , coverage . report ()) ; if coverage . coverage_percent < 80.0 { println ! (\"{}\" , style (\"⚠️  Documentation coverage below 80%\") . yellow ()) ; } } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check documentation: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"📝 Checking code formatting...\") . bold () . yellow ()) ; match formatting :: check_formatting (& project_path) . await { Ok (format_result) => { println ! (\"{}\" , format_result . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check formatting: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"🔒 Running security audit...\") . bold () . yellow ()) ; match security :: run_security_audit (& project_path) . await { Ok (audit_report) => { println ! (\"{}\" , audit_report . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not run security audit: {}\" , e)) . yellow ()) ; } } if ! violations . is_empty () || ! clippy_result . success { std :: process :: exit (1) ; } else { println ! () ; println ! (\"{}\" , style (\"🎉 All validations passed! Code meets Ferrous Forge standards.\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "                        \"Remove unused parameter or implement missing functionality\".to_string(),",
          "                        false,",
          "                        2,",
          "                    )",
          "                } else {",
          "                    (",
          "                        \"Replace `let _ =` with proper error handling using `?`\".to_string(),",
          "                        true,",
          "                        1,",
          "                    )",
          "                }"
        ],
        "imports": [
          "use crate::{",
          "use console::style;",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::path::PathBuf;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 219: ("
        ],
        "control_flow": [
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 103: Control structure",
          "Line 118: Control structure",
          "Line 121: Control structure",
          "Line 139: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure",
          "Line 196: Control structure",
          "Line 204: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 212: Control structure",
          "Line 263: Control structure",
          "Line 264: Control structure",
          "Line 300: Control structure",
          "Line 351: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 366: Control structure",
          "Line 377: Control structure",
          "Line 380: Control structure",
          "Line 381: Control structure",
          "Line 407: Control structure",
          "Line 409: Control structure",
          "Line 417: Control structure",
          "Line 421: Control structure"
        ],
        "variable_usage": {
          "code_snippet": [
            205
          ],
          "(suggested_fix,": [
            209
          ],
          "compliance_percentage": [
            299
          ],
          "md_content": [
            336
          ],
          "latest_json": [
            340
          ],
          "timestamp_str": [
            191
          ],
          "reports_dir": [
            186
          ],
          "latest_md": [
            341
          ],
          "contents": [
            362
          ],
          "files_with_violations": [
            293
          ],
          "Some(entry)": [
            378
          ],
          "Some(ext)": [
            379
          ],
          "total_files": [
            292
          ],
          "mut": [
            194,
            202,
            261,
            374,
            377,
            391
          ],
          "timestamp": [
            190
          ],
          "clippy_result": [
            100
          ],
          "validator": [
            78
          ],
          "json_content": [
            330
          ],
          "md_path": [
            335
          ],
          "lines": [
            363
          ],
          "report": [
            84,
            306
          ],
          "project_path": [
            66
          ],
          "(strategy,": [
            263
          ],
          "json_path": [
            329
          ],
          "_": [
            219
          ],
          "violations": [
            81
          ]
        },
        "function_calls": [
          ""
        ],
        "error_propagation_path": [
          "Line 79: Error handling point",
          "Line 82: Error handling point",
          "Line 91: Error handling point",
          "Line 101: Error handling point",
          "Line 188: Error handling point",
          "Line 198: Error handling point",
          "Line 220: Error handling point",
          "Line 227: Error handling point",
          "Line 250: Error handling point",
          "Line 271: Error handling point",
          "Line 272: Error handling point",
          "Line 293: Error handling point",
          "Line 332: Error handling point",
          "Line 333: Error handling point",
          "Line 338: Error handling point",
          "Line 343: Error handling point",
          "Line 344: Error handling point",
          "Line 363: Error handling point",
          "Line 378: Error handling point",
          "Line 379: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "console",
        "serde",
        "std",
        "std",
        "tokio",
        ""
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/validate.rs",
        "line": 226,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the validate command\"] pub async fn execute (path : Option < PathBuf > , ai_report : bool , _compare_previous : bool ,) -> Result < () > { let project_path = path . unwrap_or_else (| | std :: env :: current_dir () . unwrap_or_default ()) ; println ! (\"{}\" , style (\"🦀 Running Ferrous Forge validation...\") . bold () . cyan ()) ; println ! (\"📁 Project: {}\" , project_path . display ()) ; println ! () ; let validator = RustValidator :: new (project_path . clone ()) ? ; let violations = validator . validate_project () . await ? ; let report = validator . generate_report (& violations) ; println ! (\"{}\" , report) ; if ai_report { println ! (\"\\n🤖 Generating AI-friendly compliance report...\") ; generate_ai_report (& project_path , & violations) . await ? ; } println ! (\"{}\" , style (\"🔧 Running Clippy with strict configuration...\") . bold () . yellow ()) ; let clippy_result = validator . run_clippy () . await ? ; if ! clippy_result . success { println ! (\"{}\" , style (\"❌ Clippy found issues:\") . red ()) ; println ! (\"{}\" , clippy_result . output) ; } else { println ! (\"{}\" , style (\"✅ Clippy validation passed!\") . green ()) ; } println ! () ; println ! (\"{}\" , style (\"📚 Checking documentation coverage...\") . bold () . yellow ()) ; match doc_coverage :: check_documentation_coverage (& project_path) . await { Ok (coverage) => { println ! (\"{}\" , coverage . report ()) ; if coverage . coverage_percent < 80.0 { println ! (\"{}\" , style (\"⚠️  Documentation coverage below 80%\") . yellow ()) ; } } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check documentation: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"📝 Checking code formatting...\") . bold () . yellow ()) ; match formatting :: check_formatting (& project_path) . await { Ok (format_result) => { println ! (\"{}\" , format_result . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check formatting: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"🔒 Running security audit...\") . bold () . yellow ()) ; match security :: run_security_audit (& project_path) . await { Ok (audit_report) => { println ! (\"{}\" , audit_report . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not run security audit: {}\" , e)) . yellow ()) ; } } if ! violations . is_empty () || ! clippy_result . success { std :: process :: exit (1) ; } else { println ! () ; println ! (\"{}\" , style (\"🎉 All validations passed! Code meets Ferrous Forge standards.\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "                        true,",
          "                        1,",
          "                    )",
          "                }",
          "            }",
          "            crate::validation::ViolationType::UnwrapInProduction => (",
          "                \"Replace `.unwrap()` with `?` or proper error handling\".to_string(),",
          "                true,",
          "                1,",
          "            ),",
          "            crate::validation::ViolationType::FileTooLarge => ("
        ],
        "imports": [
          "use crate::{",
          "use console::style;",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::path::PathBuf;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 226: crate::validation::ViolationType::UnwrapInProduction => ("
        ],
        "control_flow": [
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 103: Control structure",
          "Line 118: Control structure",
          "Line 121: Control structure",
          "Line 139: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure",
          "Line 196: Control structure",
          "Line 204: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 212: Control structure",
          "Line 263: Control structure",
          "Line 264: Control structure",
          "Line 300: Control structure",
          "Line 351: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 366: Control structure",
          "Line 377: Control structure",
          "Line 380: Control structure",
          "Line 381: Control structure",
          "Line 407: Control structure",
          "Line 409: Control structure",
          "Line 417: Control structure",
          "Line 421: Control structure"
        ],
        "variable_usage": {
          "latest_md": [
            341
          ],
          "files_with_violations": [
            293
          ],
          "md_content": [
            336
          ],
          "Some(ext)": [
            379
          ],
          "latest_json": [
            340
          ],
          "violations": [
            81
          ],
          "timestamp_str": [
            191
          ],
          "mut": [
            194,
            202,
            261,
            374,
            377,
            391
          ],
          "contents": [
            362
          ],
          "report": [
            84,
            306
          ],
          "clippy_result": [
            100
          ],
          "lines": [
            363
          ],
          "project_path": [
            66
          ],
          "code_snippet": [
            205
          ],
          "Some(entry)": [
            378
          ],
          "total_files": [
            292
          ],
          "validator": [
            78
          ],
          "(strategy,": [
            263
          ],
          "(suggested_fix,": [
            209
          ],
          "json_path": [
            329
          ],
          "json_content": [
            330
          ],
          "md_path": [
            335
          ],
          "_": [
            219
          ],
          "compliance_percentage": [
            299
          ],
          "timestamp": [
            190
          ],
          "reports_dir": [
            186
          ]
        },
        "function_calls": [
          "crate::validation::ViolationType::UnwrapInProduction =>"
        ],
        "error_propagation_path": [
          "Line 79: Error handling point",
          "Line 82: Error handling point",
          "Line 91: Error handling point",
          "Line 101: Error handling point",
          "Line 188: Error handling point",
          "Line 198: Error handling point",
          "Line 220: Error handling point",
          "Line 227: Error handling point",
          "Line 250: Error handling point",
          "Line 271: Error handling point",
          "Line 272: Error handling point",
          "Line 293: Error handling point",
          "Line 332: Error handling point",
          "Line 333: Error handling point",
          "Line 338: Error handling point",
          "Line 343: Error handling point",
          "Line 344: Error handling point",
          "Line 363: Error handling point",
          "Line 378: Error handling point",
          "Line 379: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "console",
        "serde",
        "std",
        "std",
        "tokio",
        "crate::validation::ViolationType::UnwrapInProduction =>"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/validate.rs",
        "line": 266,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the validate command\"] pub async fn execute (path : Option < PathBuf > , ai_report : bool , _compare_previous : bool ,) -> Result < () > { let project_path = path . unwrap_or_else (| | std :: env :: current_dir () . unwrap_or_default ()) ; println ! (\"{}\" , style (\"🦀 Running Ferrous Forge validation...\") . bold () . cyan ()) ; println ! (\"📁 Project: {}\" , project_path . display ()) ; println ! () ; let validator = RustValidator :: new (project_path . clone ()) ? ; let violations = validator . validate_project () . await ? ; let report = validator . generate_report (& violations) ; println ! (\"{}\" , report) ; if ai_report { println ! (\"\\n🤖 Generating AI-friendly compliance report...\") ; generate_ai_report (& project_path , & violations) . await ? ; } println ! (\"{}\" , style (\"🔧 Running Clippy with strict configuration...\") . bold () . yellow ()) ; let clippy_result = validator . run_clippy () . await ? ; if ! clippy_result . success { println ! (\"{}\" , style (\"❌ Clippy found issues:\") . red ()) ; println ! (\"{}\" , clippy_result . output) ; } else { println ! (\"{}\" , style (\"✅ Clippy validation passed!\") . green ()) ; } println ! () ; println ! (\"{}\" , style (\"📚 Checking documentation coverage...\") . bold () . yellow ()) ; match doc_coverage :: check_documentation_coverage (& project_path) . await { Ok (coverage) => { println ! (\"{}\" , coverage . report ()) ; if coverage . coverage_percent < 80.0 { println ! (\"{}\" , style (\"⚠️  Documentation coverage below 80%\") . yellow ()) ; } } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check documentation: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"📝 Checking code formatting...\") . bold () . yellow ()) ; match formatting :: check_formatting (& project_path) . await { Ok (format_result) => { println ! (\"{}\" , format_result . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check formatting: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"🔒 Running security audit...\") . bold () . yellow ()) ; match security :: run_security_audit (& project_path) . await { Ok (audit_report) => { println ! (\"{}\" , audit_report . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not run security audit: {}\" , e)) . yellow ()) ; } } if ! violations . is_empty () || ! clippy_result . success { std :: process :: exit (1) ; } else { println ! () ; println ! (\"{}\" , style (\"🎉 All validations passed! Code meets Ferrous Forge standards.\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    // Generate fix instructions",
          "    let mut fix_instructions = Vec::new();",
          "    for (vtype, count) in violation_counts {",
          "        let (strategy, example, effort) = match vtype.as_str() {",
          "            \"UnderscoreBandaid\" => (",
          "                \"1. Identify what functionality the parameter should provide\\n2. Either implement the functionality or remove the parameter\\n3. Update function signature and callers\".to_string(),",
          "                \"// Before: fn process(_unused: String, data: Data)\\n// After: fn process(data: Data) or implement the unused parameter\".to_string(),",
          "                \"Moderate\".to_string(),",
          "            ),",
          "            \"UnwrapInProduction\" => (",
          "                \"1. Change function to return Result<T, Error>\\n2. Replace ? with ?\\n3. Handle errors at call sites\".to_string(),"
        ],
        "imports": [
          "use crate::{",
          "use console::style;",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::path::PathBuf;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 266: \"1. Identify what functionality the parameter should provide\\n2. Either implement the functionality or remove the parameter\\n3. Update function signature and callers\".to_string(),"
        ],
        "control_flow": [
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 103: Control structure",
          "Line 118: Control structure",
          "Line 121: Control structure",
          "Line 139: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure",
          "Line 196: Control structure",
          "Line 204: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 212: Control structure",
          "Line 263: Control structure",
          "Line 264: Control structure",
          "Line 300: Control structure",
          "Line 351: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 366: Control structure",
          "Line 377: Control structure",
          "Line 380: Control structure",
          "Line 381: Control structure",
          "Line 407: Control structure",
          "Line 409: Control structure",
          "Line 417: Control structure",
          "Line 421: Control structure"
        ],
        "variable_usage": {
          "validator": [
            78
          ],
          "files_with_violations": [
            293
          ],
          "(suggested_fix,": [
            209
          ],
          "_": [
            219
          ],
          "violations": [
            81
          ],
          "report": [
            84,
            306
          ],
          "project_path": [
            66
          ],
          "clippy_result": [
            100
          ],
          "json_content": [
            330
          ],
          "timestamp_str": [
            191
          ],
          "compliance_percentage": [
            299
          ],
          "total_files": [
            292
          ],
          "md_content": [
            336
          ],
          "latest_json": [
            340
          ],
          "latest_md": [
            341
          ],
          "lines": [
            363
          ],
          "mut": [
            194,
            202,
            261,
            374,
            377,
            391
          ],
          "Some(ext)": [
            379
          ],
          "(strategy,": [
            263
          ],
          "contents": [
            362
          ],
          "timestamp": [
            190
          ],
          "md_path": [
            335
          ],
          "reports_dir": [
            186
          ],
          "Some(entry)": [
            378
          ],
          "code_snippet": [
            205
          ],
          "json_path": [
            329
          ]
        },
        "function_calls": [
          "to_string"
        ],
        "error_propagation_path": [
          "Line 79: Error handling point",
          "Line 82: Error handling point",
          "Line 91: Error handling point",
          "Line 101: Error handling point",
          "Line 188: Error handling point",
          "Line 198: Error handling point",
          "Line 220: Error handling point",
          "Line 227: Error handling point",
          "Line 250: Error handling point",
          "Line 271: Error handling point",
          "Line 272: Error handling point",
          "Line 293: Error handling point",
          "Line 332: Error handling point",
          "Line 333: Error handling point",
          "Line 338: Error handling point",
          "Line 343: Error handling point",
          "Line 344: Error handling point",
          "Line 363: Error handling point",
          "Line 378: Error handling point",
          "Line 379: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "console",
        "serde",
        "std",
        "std",
        "tokio",
        "to_string"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/commands/validate.rs",
        "line": 271,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the validate command\"] pub async fn execute (path : Option < PathBuf > , ai_report : bool , _compare_previous : bool ,) -> Result < () > { let project_path = path . unwrap_or_else (| | std :: env :: current_dir () . unwrap_or_default ()) ; println ! (\"{}\" , style (\"🦀 Running Ferrous Forge validation...\") . bold () . cyan ()) ; println ! (\"📁 Project: {}\" , project_path . display ()) ; println ! () ; let validator = RustValidator :: new (project_path . clone ()) ? ; let violations = validator . validate_project () . await ? ; let report = validator . generate_report (& violations) ; println ! (\"{}\" , report) ; if ai_report { println ! (\"\\n🤖 Generating AI-friendly compliance report...\") ; generate_ai_report (& project_path , & violations) . await ? ; } println ! (\"{}\" , style (\"🔧 Running Clippy with strict configuration...\") . bold () . yellow ()) ; let clippy_result = validator . run_clippy () . await ? ; if ! clippy_result . success { println ! (\"{}\" , style (\"❌ Clippy found issues:\") . red ()) ; println ! (\"{}\" , clippy_result . output) ; } else { println ! (\"{}\" , style (\"✅ Clippy validation passed!\") . green ()) ; } println ! () ; println ! (\"{}\" , style (\"📚 Checking documentation coverage...\") . bold () . yellow ()) ; match doc_coverage :: check_documentation_coverage (& project_path) . await { Ok (coverage) => { println ! (\"{}\" , coverage . report ()) ; if coverage . coverage_percent < 80.0 { println ! (\"{}\" , style (\"⚠️  Documentation coverage below 80%\") . yellow ()) ; } } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check documentation: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"📝 Checking code formatting...\") . bold () . yellow ()) ; match formatting :: check_formatting (& project_path) . await { Ok (format_result) => { println ! (\"{}\" , format_result . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check formatting: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"🔒 Running security audit...\") . bold () . yellow ()) ; match security :: run_security_audit (& project_path) . await { Ok (audit_report) => { println ! (\"{}\" , audit_report . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not run security audit: {}\" , e)) . yellow ()) ; } } if ! violations . is_empty () || ! clippy_result . success { std :: process :: exit (1) ; } else { println ! () ; println ! (\"{}\" , style (\"🎉 All validations passed! Code meets Ferrous Forge standards.\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "                \"// Before: fn process(_unused: String, data: Data)\\n// After: fn process(data: Data) or implement the unused parameter\".to_string(),",
        "surrounding_code": [
          "                \"1. Identify what functionality the parameter should provide\\n2. Either implement the functionality or remove the parameter\\n3. Update function signature and callers\".to_string(),",
          "                \"// Before: fn process(_unused: String, data: Data)\\n// After: fn process(data: Data) or implement the unused parameter\".to_string(),",
          "                \"Moderate\".to_string(),",
          "            ),",
          "            \"UnwrapInProduction\" => (",
          "                \"1. Change function to return Result<T, Error>\\n2. Replace ? with ?\\n3. Handle errors at call sites\".to_string(),",
          "                \"// Before: value.unwrap()\\n// After: value?\".to_string(),",
          "                \"Easy\".to_string(),",
          "            ),",
          "            \"FileTooLarge\" => (",
          "                \"1. Identify logical boundaries in the file\\n2. Create new module directory\\n3. Split into focused modules\\n4. Update imports\".to_string(),"
        ],
        "imports": [
          "use crate::{",
          "use console::style;",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::path::PathBuf;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": "Result",
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 271: \"1. Change function to return Result<T, Error>\\n2. Replace ? with ?\\n3. Handle errors at call sites\".to_string(),"
        ],
        "control_flow": [
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 103: Control structure",
          "Line 118: Control structure",
          "Line 121: Control structure",
          "Line 139: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure",
          "Line 196: Control structure",
          "Line 204: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 212: Control structure",
          "Line 263: Control structure",
          "Line 264: Control structure",
          "Line 300: Control structure",
          "Line 351: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 366: Control structure",
          "Line 377: Control structure",
          "Line 380: Control structure",
          "Line 381: Control structure",
          "Line 407: Control structure",
          "Line 409: Control structure",
          "Line 417: Control structure",
          "Line 421: Control structure"
        ],
        "variable_usage": {
          "mut": [
            194,
            202,
            261,
            374,
            377,
            391
          ],
          "md_path": [
            335
          ],
          "md_content": [
            336
          ],
          "report": [
            84,
            306
          ],
          "latest_json": [
            340
          ],
          "violations": [
            81
          ],
          "_": [
            219
          ],
          "latest_md": [
            341
          ],
          "lines": [
            363
          ],
          "Some(entry)": [
            378
          ],
          "Some(ext)": [
            379
          ],
          "contents": [
            362
          ],
          "reports_dir": [
            186
          ],
          "compliance_percentage": [
            299
          ],
          "clippy_result": [
            100
          ],
          "code_snippet": [
            205
          ],
          "(suggested_fix,": [
            209
          ],
          "timestamp": [
            190
          ],
          "timestamp_str": [
            191
          ],
          "(strategy,": [
            263
          ],
          "validator": [
            78
          ],
          "files_with_violations": [
            293
          ],
          "json_path": [
            329
          ],
          "project_path": [
            66
          ],
          "total_files": [
            292
          ],
          "json_content": [
            330
          ]
        },
        "function_calls": [
          "to_string"
        ],
        "error_propagation_path": [
          "Line 79: Error handling point",
          "Line 82: Error handling point",
          "Line 91: Error handling point",
          "Line 101: Error handling point",
          "Line 188: Error handling point",
          "Line 198: Error handling point",
          "Line 220: Error handling point",
          "Line 227: Error handling point",
          "Line 250: Error handling point",
          "Line 271: Error handling point",
          "Line 272: Error handling point",
          "Line 293: Error handling point",
          "Line 332: Error handling point",
          "Line 333: Error handling point",
          "Line 338: Error handling point",
          "Line 343: Error handling point",
          "Line 344: Error handling point",
          "Line 363: Error handling point",
          "Line 378: Error handling point",
          "Line 379: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "console",
        "serde",
        "std",
        "std",
        "tokio",
        "to_string"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/validate.rs",
        "line": 357,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the validate command\"] pub async fn execute (path : Option < PathBuf > , ai_report : bool , _compare_previous : bool ,) -> Result < () > { let project_path = path . unwrap_or_else (| | std :: env :: current_dir () . unwrap_or_default ()) ; println ! (\"{}\" , style (\"🦀 Running Ferrous Forge validation...\") . bold () . cyan ()) ; println ! (\"📁 Project: {}\" , project_path . display ()) ; println ! () ; let validator = RustValidator :: new (project_path . clone ()) ? ; let violations = validator . validate_project () . await ? ; let report = validator . generate_report (& violations) ; println ! (\"{}\" , report) ; if ai_report { println ! (\"\\n🤖 Generating AI-friendly compliance report...\") ; generate_ai_report (& project_path , & violations) . await ? ; } println ! (\"{}\" , style (\"🔧 Running Clippy with strict configuration...\") . bold () . yellow ()) ; let clippy_result = validator . run_clippy () . await ? ; if ! clippy_result . success { println ! (\"{}\" , style (\"❌ Clippy found issues:\") . red ()) ; println ! (\"{}\" , clippy_result . output) ; } else { println ! (\"{}\" , style (\"✅ Clippy validation passed!\") . green ()) ; } println ! () ; println ! (\"{}\" , style (\"📚 Checking documentation coverage...\") . bold () . yellow ()) ; match doc_coverage :: check_documentation_coverage (& project_path) . await { Ok (coverage) => { println ! (\"{}\" , coverage . report ()) ; if coverage . coverage_percent < 80.0 { println ! (\"{}\" , style (\"⚠️  Documentation coverage below 80%\") . yellow ()) ; } } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check documentation: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"📝 Checking code formatting...\") . bold () . yellow ()) ; match formatting :: check_formatting (& project_path) . await { Ok (format_result) => { println ! (\"{}\" , format_result . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check formatting: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"🔒 Running security audit...\") . bold () . yellow ()) ; match security :: run_security_audit (& project_path) . await { Ok (audit_report) => { println ! (\"{}\" , audit_report . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not run security audit: {}\" , e)) . yellow ()) ; } } if ! violations . is_empty () || ! clippy_result . success { std :: process :: exit (1) ; } else { println ! () ; println ! (\"{}\" , style (\"🎉 All validations passed! Code meets Ferrous Forge standards.\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "                \"// Before: fn process(_unused: String, data: Data)\\n// After: fn process(data: Data) or implement the unused parameter\".to_string(),",
        "surrounding_code": [
          "    println!(\"   Use the JSON file for automated processing and fix suggestions\");",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Get code snippet around a violation",
          "async fn get_code_snippet(file_path: &PathBuf, line: usize) -> Result<String> {",
          "    if !file_path.exists() {",
          "        return Ok(\"File not found\".to_string());",
          "    }",
          ""
        ],
        "imports": [
          "use crate::{",
          "use console::style;",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::path::PathBuf;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 357: /// Get code snippet around a violation"
        ],
        "control_flow": [
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 103: Control structure",
          "Line 118: Control structure",
          "Line 121: Control structure",
          "Line 139: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure",
          "Line 196: Control structure",
          "Line 204: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 212: Control structure",
          "Line 263: Control structure",
          "Line 264: Control structure",
          "Line 300: Control structure",
          "Line 351: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 366: Control structure",
          "Line 377: Control structure",
          "Line 380: Control structure",
          "Line 381: Control structure",
          "Line 407: Control structure",
          "Line 409: Control structure",
          "Line 417: Control structure",
          "Line 421: Control structure"
        ],
        "variable_usage": {
          "json_path": [
            329
          ],
          "files_with_violations": [
            293
          ],
          "mut": [
            194,
            202,
            261,
            374,
            377,
            391
          ],
          "md_content": [
            336
          ],
          "latest_json": [
            340
          ],
          "project_path": [
            66
          ],
          "timestamp": [
            190
          ],
          "lines": [
            363
          ],
          "Some(ext)": [
            379
          ],
          "_": [
            219
          ],
          "(strategy,": [
            263
          ],
          "validator": [
            78
          ],
          "timestamp_str": [
            191
          ],
          "code_snippet": [
            205
          ],
          "(suggested_fix,": [
            209
          ],
          "Some(entry)": [
            378
          ],
          "reports_dir": [
            186
          ],
          "total_files": [
            292
          ],
          "json_content": [
            330
          ],
          "compliance_percentage": [
            299
          ],
          "md_path": [
            335
          ],
          "clippy_result": [
            100
          ],
          "latest_md": [
            341
          ],
          "violations": [
            81
          ],
          "contents": [
            362
          ],
          "report": [
            84,
            306
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 79: Error handling point",
          "Line 82: Error handling point",
          "Line 91: Error handling point",
          "Line 101: Error handling point",
          "Line 188: Error handling point",
          "Line 198: Error handling point",
          "Line 220: Error handling point",
          "Line 227: Error handling point",
          "Line 250: Error handling point",
          "Line 271: Error handling point",
          "Line 272: Error handling point",
          "Line 293: Error handling point",
          "Line 332: Error handling point",
          "Line 333: Error handling point",
          "Line 338: Error handling point",
          "Line 343: Error handling point",
          "Line 344: Error handling point",
          "Line 363: Error handling point",
          "Line 378: Error handling point",
          "Line 379: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "console",
        "serde",
        "std",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/commands/validate.rs",
        "line": 373,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "execute",
        "function_signature": "# [doc = \" Execute the validate command\"] pub async fn execute (path : Option < PathBuf > , ai_report : bool , _compare_previous : bool ,) -> Result < () > { let project_path = path . unwrap_or_else (| | std :: env :: current_dir () . unwrap_or_default ()) ; println ! (\"{}\" , style (\"🦀 Running Ferrous Forge validation...\") . bold () . cyan ()) ; println ! (\"📁 Project: {}\" , project_path . display ()) ; println ! () ; let validator = RustValidator :: new (project_path . clone ()) ? ; let violations = validator . validate_project () . await ? ; let report = validator . generate_report (& violations) ; println ! (\"{}\" , report) ; if ai_report { println ! (\"\\n🤖 Generating AI-friendly compliance report...\") ; generate_ai_report (& project_path , & violations) . await ? ; } println ! (\"{}\" , style (\"🔧 Running Clippy with strict configuration...\") . bold () . yellow ()) ; let clippy_result = validator . run_clippy () . await ? ; if ! clippy_result . success { println ! (\"{}\" , style (\"❌ Clippy found issues:\") . red ()) ; println ! (\"{}\" , clippy_result . output) ; } else { println ! (\"{}\" , style (\"✅ Clippy validation passed!\") . green ()) ; } println ! () ; println ! (\"{}\" , style (\"📚 Checking documentation coverage...\") . bold () . yellow ()) ; match doc_coverage :: check_documentation_coverage (& project_path) . await { Ok (coverage) => { println ! (\"{}\" , coverage . report ()) ; if coverage . coverage_percent < 80.0 { println ! (\"{}\" , style (\"⚠️  Documentation coverage below 80%\") . yellow ()) ; } } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check documentation: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"📝 Checking code formatting...\") . bold () . yellow ()) ; match formatting :: check_formatting (& project_path) . await { Ok (format_result) => { println ! (\"{}\" , format_result . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not check formatting: {}\" , e)) . yellow ()) ; } } println ! () ; println ! (\"{}\" , style (\"🔒 Running security audit...\") . bold () . yellow ()) ; match security :: run_security_audit (& project_path) . await { Ok (audit_report) => { println ! (\"{}\" , audit_report . report ()) ; } Err (e) => { println ! (\"{}\" , style (format ! (\"⚠️  Could not run security audit: {}\" , e)) . yellow ()) ; } } if ! violations . is_empty () || ! clippy_result . success { std :: process :: exit (1) ; } else { println ! () ; println ! (\"{}\" , style (\"🎉 All validations passed! Code meets Ferrous Forge standards.\") . bold () . green ()) ; } Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "                \"// Before: fn process(_unused: String, data: Data)\\n// After: fn process(data: Data) or implement the unused parameter\".to_string(),",
        "surrounding_code": [
          "    } else {",
          "        Ok(\"Line not found\".to_string())",
          "    }",
          "}",
          "",
          "/// Count Rust files in project",
          "async fn count_rust_files(project_path: &PathBuf) -> Result<usize> {",
          "    let mut count = 0;",
          "",
          "    // Simple count for now - would need recursive implementation for full accuracy",
          "    let mut entries = fs::read_dir(project_path).await?;"
        ],
        "imports": [
          "use crate::{",
          "use console::style;",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::HashMap;",
          "use std::path::PathBuf;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 373: /// Count Rust files in project"
        ],
        "control_flow": [
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 103: Control structure",
          "Line 118: Control structure",
          "Line 121: Control structure",
          "Line 139: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure",
          "Line 196: Control structure",
          "Line 204: Control structure",
          "Line 205: Control structure",
          "Line 210: Control structure",
          "Line 212: Control structure",
          "Line 263: Control structure",
          "Line 264: Control structure",
          "Line 300: Control structure",
          "Line 351: Control structure",
          "Line 352: Control structure",
          "Line 359: Control structure",
          "Line 366: Control structure",
          "Line 377: Control structure",
          "Line 380: Control structure",
          "Line 381: Control structure",
          "Line 407: Control structure",
          "Line 409: Control structure",
          "Line 417: Control structure",
          "Line 421: Control structure"
        ],
        "variable_usage": {
          "clippy_result": [
            100
          ],
          "timestamp": [
            190
          ],
          "json_content": [
            330
          ],
          "Some(entry)": [
            378
          ],
          "latest_json": [
            340
          ],
          "total_files": [
            292
          ],
          "md_path": [
            335
          ],
          "timestamp_str": [
            191
          ],
          "violations": [
            81
          ],
          "files_with_violations": [
            293
          ],
          "contents": [
            362
          ],
          "Some(ext)": [
            379
          ],
          "lines": [
            363
          ],
          "mut": [
            194,
            202,
            261,
            374,
            377,
            391
          ],
          "project_path": [
            66
          ],
          "md_content": [
            336
          ],
          "compliance_percentage": [
            299
          ],
          "reports_dir": [
            186
          ],
          "code_snippet": [
            205
          ],
          "report": [
            84,
            306
          ],
          "validator": [
            78
          ],
          "_": [
            219
          ],
          "(suggested_fix,": [
            209
          ],
          "json_path": [
            329
          ],
          "latest_md": [
            341
          ],
          "(strategy,": [
            263
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 79: Error handling point",
          "Line 82: Error handling point",
          "Line 91: Error handling point",
          "Line 101: Error handling point",
          "Line 188: Error handling point",
          "Line 198: Error handling point",
          "Line 220: Error handling point",
          "Line 227: Error handling point",
          "Line 250: Error handling point",
          "Line 271: Error handling point",
          "Line 272: Error handling point",
          "Line 293: Error handling point",
          "Line 332: Error handling point",
          "Line 333: Error handling point",
          "Line 338: Error handling point",
          "Line 343: Error handling point",
          "Line 344: Error handling point",
          "Line 363: Error handling point",
          "Line 378: Error handling point",
          "Line 379: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "console",
        "serde",
        "std",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/doc_coverage.rs",
        "line": 26,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_documentation_coverage",
        "function_signature": "# [doc = \" Check documentation coverage for a Rust project\"] pub async fn check_documentation_coverage (project_path : & Path) -> Result < DocCoverage > { let output = Command :: new (\"cargo\") . args (& [\"doc\" , \"--no-deps\" , \"--document-private-items\" , \"--message-format=json\" ,]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo doc: {}\" , e))) ? ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let mut missing = Vec :: new () ; for line in stdout . lines () { if line . contains (\"missing_docs\") { if let Ok (json) = serde_json :: from_str :: < serde_json :: Value > (line) { if let Some (message) = json [\"message\"] [\"rendered\"] . as_str () { if let Some (item_match) = extract_item_name (message) { missing . push (item_match) ; } } } } } let warning_re = Regex :: new (r\"warning: missing documentation for (.+)\") . map_err (| e | Error :: validation (format ! (\"Invalid regex: {}\" , e))) ? ; for cap in warning_re . captures_iter (& stderr) { missing . push (cap [1] . to_string ()) ; } let (total , documented) = count_documentation_items (project_path) . await ? ; let coverage_percent = if total > 0 { (documented as f32 / total as f32) * 100.0 } else { 100.0 } ; Ok (DocCoverage { total_items : total , documented_items : documented , coverage_percent , missing , }) } . sig",
        "return_type": "Result < DocCoverage >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    /// List of items missing documentation",
          "    pub missing: Vec<String>,",
          "}",
          "",
          "impl DocCoverage {",
          "    /// Check if coverage meets minimum threshold",
          "    pub fn meets_threshold(&self, min_coverage: f32) -> bool {",
          "        self.coverage_percent >= min_coverage",
          "    }",
          "",
          "    /// Generate a human-readable report"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use regex::Regex;",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 26: /// Check if coverage meets minimum threshold"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 26: Control structure",
          "Line 35: Control structure",
          "Line 37: Control structure",
          "Line 49: Control structure",
          "Line 51: Control structure",
          "Line 54: Control structure",
          "Line 66: Control structure",
          "Line 83: Control structure",
          "Line 86: Control structure",
          "Line 87: Control structure",
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 100: Control structure",
          "Line 103: Control structure",
          "Line 110: Control structure",
          "Line 138: Control structure",
          "Line 157: Control structure",
          "Line 158: Control structure",
          "Line 161: Control structure",
          "Line 162: Control structure",
          "Line 177: Control structure",
          "Line 178: Control structure",
          "Line 179: Control structure",
          "Line 180: Control structure",
          "Line 186: Control structure",
          "Line 193: Control structure",
          "Line 195: Control structure"
        ],
        "variable_usage": {
          "content": [
            138,
            241
          ],
          "Ok(json)": [
            87
          ],
          "walker": [
            129
          ],
          "mut": [
            32,
            83,
            125,
            126,
            149,
            150
          ],
          "(total,": [
            107,
            252
          ],
          "Some(message)": [
            88
          ],
          "stderr": [
            79
          ],
          "output": [
            68
          ],
          "Some(pos)": [
            185
          ],
          "(file_total,": [
            139
          ],
          "coverage": [
            259
          ],
          "Some(item_match)": [
            90
          ],
          "Some(end)": [
            179
          ],
          "lines": [
            151
          ],
          "coverage_percent": [
            109
          ],
          "Some(start)": [
            178
          ],
          "stdout": [
            80
          ],
          "warning_re": [
            99
          ],
          "pub_item_re": [
            153
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 78: Error handling point",
          "Line 101: Error handling point",
          "Line 108: Error handling point",
          "Line 139: Error handling point",
          "Line 140: Error handling point",
          "Line 155: Error handling point",
          "Line 253: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "regex",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/doc_coverage.rs",
        "line": 66,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_documentation_coverage",
        "function_signature": "# [doc = \" Check documentation coverage for a Rust project\"] pub async fn check_documentation_coverage (project_path : & Path) -> Result < DocCoverage > { let output = Command :: new (\"cargo\") . args (& [\"doc\" , \"--no-deps\" , \"--document-private-items\" , \"--message-format=json\" ,]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo doc: {}\" , e))) ? ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let mut missing = Vec :: new () ; for line in stdout . lines () { if line . contains (\"missing_docs\") { if let Ok (json) = serde_json :: from_str :: < serde_json :: Value > (line) { if let Some (message) = json [\"message\"] [\"rendered\"] . as_str () { if let Some (item_match) = extract_item_name (message) { missing . push (item_match) ; } } } } } let warning_re = Regex :: new (r\"warning: missing documentation for (.+)\") . map_err (| e | Error :: validation (format ! (\"Invalid regex: {}\" , e))) ? ; for cap in warning_re . captures_iter (& stderr) { missing . push (cap [1] . to_string ()) ; } let (total , documented) = count_documentation_items (project_path) . await ? ; let coverage_percent = if total > 0 { (documented as f32 / total as f32) * 100.0 } else { 100.0 } ; Ok (DocCoverage { total_items : total , documented_items : documented , coverage_percent , missing , }) } . sig",
        "return_type": "Result < DocCoverage >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "",
          "        report",
          "    }",
          "}",
          "",
          "/// Check documentation coverage for a Rust project",
          "pub async fn check_documentation_coverage(project_path: &Path) -> Result<DocCoverage> {",
          "    // Run cargo doc with JSON output to get warnings",
          "    let output = Command::new(\"cargo\")",
          "        .args(&[",
          "            \"doc\","
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use regex::Regex;",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 66: /// Check documentation coverage for a Rust project"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 26: Control structure",
          "Line 35: Control structure",
          "Line 37: Control structure",
          "Line 49: Control structure",
          "Line 51: Control structure",
          "Line 54: Control structure",
          "Line 66: Control structure",
          "Line 83: Control structure",
          "Line 86: Control structure",
          "Line 87: Control structure",
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 100: Control structure",
          "Line 103: Control structure",
          "Line 110: Control structure",
          "Line 138: Control structure",
          "Line 157: Control structure",
          "Line 158: Control structure",
          "Line 161: Control structure",
          "Line 162: Control structure",
          "Line 177: Control structure",
          "Line 178: Control structure",
          "Line 179: Control structure",
          "Line 180: Control structure",
          "Line 186: Control structure",
          "Line 193: Control structure",
          "Line 195: Control structure"
        ],
        "variable_usage": {
          "(file_total,": [
            139
          ],
          "lines": [
            151
          ],
          "warning_re": [
            99
          ],
          "stderr": [
            79
          ],
          "stdout": [
            80
          ],
          "coverage_percent": [
            109
          ],
          "Some(message)": [
            88
          ],
          "Some(item_match)": [
            90
          ],
          "Ok(json)": [
            87
          ],
          "Some(end)": [
            179
          ],
          "(total,": [
            107,
            252
          ],
          "pub_item_re": [
            153
          ],
          "Some(start)": [
            178
          ],
          "content": [
            138,
            241
          ],
          "walker": [
            129
          ],
          "coverage": [
            259
          ],
          "output": [
            68
          ],
          "Some(pos)": [
            185
          ],
          "mut": [
            32,
            83,
            125,
            126,
            149,
            150
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 78: Error handling point",
          "Line 101: Error handling point",
          "Line 108: Error handling point",
          "Line 139: Error handling point",
          "Line 140: Error handling point",
          "Line 155: Error handling point",
          "Line 253: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "regex",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/doc_coverage.rs",
        "line": 124,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_documentation_coverage",
        "function_signature": "# [doc = \" Check documentation coverage for a Rust project\"] pub async fn check_documentation_coverage (project_path : & Path) -> Result < DocCoverage > { let output = Command :: new (\"cargo\") . args (& [\"doc\" , \"--no-deps\" , \"--document-private-items\" , \"--message-format=json\" ,]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo doc: {}\" , e))) ? ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let mut missing = Vec :: new () ; for line in stdout . lines () { if line . contains (\"missing_docs\") { if let Ok (json) = serde_json :: from_str :: < serde_json :: Value > (line) { if let Some (message) = json [\"message\"] [\"rendered\"] . as_str () { if let Some (item_match) = extract_item_name (message) { missing . push (item_match) ; } } } } } let warning_re = Regex :: new (r\"warning: missing documentation for (.+)\") . map_err (| e | Error :: validation (format ! (\"Invalid regex: {}\" , e))) ? ; for cap in warning_re . captures_iter (& stderr) { missing . push (cap [1] . to_string ()) ; } let (total , documented) = count_documentation_items (project_path) . await ? ; let coverage_percent = if total > 0 { (documented as f32 / total as f32) * 100.0 } else { 100.0 } ; Ok (DocCoverage { total_items : total , documented_items : documented , coverage_percent , missing , }) } . sig",
        "return_type": "Result < DocCoverage >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        coverage_percent,",
          "        missing,",
          "    })",
          "}",
          "",
          "/// Count documentation items in the project",
          "async fn count_documentation_items(project_path: &Path) -> Result<(usize, usize)> {",
          "    let mut total = 0;",
          "    let mut documented = 0;",
          "",
          "    // Walk through all Rust files"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use regex::Regex;",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 124: /// Count documentation items in the project"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 26: Control structure",
          "Line 35: Control structure",
          "Line 37: Control structure",
          "Line 49: Control structure",
          "Line 51: Control structure",
          "Line 54: Control structure",
          "Line 66: Control structure",
          "Line 83: Control structure",
          "Line 86: Control structure",
          "Line 87: Control structure",
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 100: Control structure",
          "Line 103: Control structure",
          "Line 110: Control structure",
          "Line 138: Control structure",
          "Line 157: Control structure",
          "Line 158: Control structure",
          "Line 161: Control structure",
          "Line 162: Control structure",
          "Line 177: Control structure",
          "Line 178: Control structure",
          "Line 179: Control structure",
          "Line 180: Control structure",
          "Line 186: Control structure",
          "Line 193: Control structure",
          "Line 195: Control structure"
        ],
        "variable_usage": {
          "coverage": [
            259
          ],
          "output": [
            68
          ],
          "warning_re": [
            99
          ],
          "walker": [
            129
          ],
          "lines": [
            151
          ],
          "Some(end)": [
            179
          ],
          "Some(item_match)": [
            90
          ],
          "stdout": [
            80
          ],
          "stderr": [
            79
          ],
          "mut": [
            32,
            83,
            125,
            126,
            149,
            150
          ],
          "Ok(json)": [
            87
          ],
          "(total,": [
            107,
            252
          ],
          "coverage_percent": [
            109
          ],
          "pub_item_re": [
            153
          ],
          "Some(start)": [
            178
          ],
          "Some(message)": [
            88
          ],
          "(file_total,": [
            139
          ],
          "Some(pos)": [
            185
          ],
          "content": [
            138,
            241
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 78: Error handling point",
          "Line 101: Error handling point",
          "Line 108: Error handling point",
          "Line 139: Error handling point",
          "Line 140: Error handling point",
          "Line 155: Error handling point",
          "Line 253: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "regex",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/doc_coverage.rs",
        "line": 193,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_documentation_coverage",
        "function_signature": "# [doc = \" Check documentation coverage for a Rust project\"] pub async fn check_documentation_coverage (project_path : & Path) -> Result < DocCoverage > { let output = Command :: new (\"cargo\") . args (& [\"doc\" , \"--no-deps\" , \"--document-private-items\" , \"--message-format=json\" ,]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo doc: {}\" , e))) ? ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let mut missing = Vec :: new () ; for line in stdout . lines () { if line . contains (\"missing_docs\") { if let Ok (json) = serde_json :: from_str :: < serde_json :: Value > (line) { if let Some (message) = json [\"message\"] [\"rendered\"] . as_str () { if let Some (item_match) = extract_item_name (message) { missing . push (item_match) ; } } } } } let warning_re = Regex :: new (r\"warning: missing documentation for (.+)\") . map_err (| e | Error :: validation (format ! (\"Invalid regex: {}\" , e))) ? ; for cap in warning_re . captures_iter (& stderr) { missing . push (cap [1] . to_string ()) ; } let (total , documented) = count_documentation_items (project_path) . await ? ; let coverage_percent = if total > 0 { (documented as f32 / total as f32) * 100.0 } else { 100.0 } ; Ok (DocCoverage { total_items : total , documented_items : documented , coverage_percent , missing , }) } . sig",
        "return_type": "Result < DocCoverage >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    } else {",
          "        None",
          "    }",
          "}",
          "",
          "/// Suggest documentation for missing items",
          "pub fn suggest_documentation(item_type: &str, item_name: &str) -> String {",
          "    match item_type {",
          "        \"fn\" | \"function\" => format!(",
          "            \"/// TODO: Document function `{}`.\\n\\",
          "             ///\\n\\"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use regex::Regex;",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 193: /// Suggest documentation for missing items"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 26: Control structure",
          "Line 35: Control structure",
          "Line 37: Control structure",
          "Line 49: Control structure",
          "Line 51: Control structure",
          "Line 54: Control structure",
          "Line 66: Control structure",
          "Line 83: Control structure",
          "Line 86: Control structure",
          "Line 87: Control structure",
          "Line 88: Control structure",
          "Line 89: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 100: Control structure",
          "Line 103: Control structure",
          "Line 110: Control structure",
          "Line 138: Control structure",
          "Line 157: Control structure",
          "Line 158: Control structure",
          "Line 161: Control structure",
          "Line 162: Control structure",
          "Line 177: Control structure",
          "Line 178: Control structure",
          "Line 179: Control structure",
          "Line 180: Control structure",
          "Line 186: Control structure",
          "Line 193: Control structure",
          "Line 195: Control structure"
        ],
        "variable_usage": {
          "(file_total,": [
            139
          ],
          "pub_item_re": [
            153
          ],
          "coverage_percent": [
            109
          ],
          "lines": [
            151
          ],
          "warning_re": [
            99
          ],
          "Some(start)": [
            178
          ],
          "content": [
            138,
            241
          ],
          "Some(end)": [
            179
          ],
          "coverage": [
            259
          ],
          "Some(message)": [
            88
          ],
          "Ok(json)": [
            87
          ],
          "Some(item_match)": [
            90
          ],
          "(total,": [
            107,
            252
          ],
          "stdout": [
            80
          ],
          "output": [
            68
          ],
          "stderr": [
            79
          ],
          "mut": [
            32,
            83,
            125,
            126,
            149,
            150
          ],
          "Some(pos)": [
            185
          ],
          "walker": [
            129
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 78: Error handling point",
          "Line 101: Error handling point",
          "Line 108: Error handling point",
          "Line 139: Error handling point",
          "Line 140: Error handling point",
          "Line 155: Error handling point",
          "Line 253: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "regex",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/analyzer.rs",
        "line": 16,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "pub struct EditionAnalyzer {",
          "    project_path: std::path::PathBuf,",
          "}",
          "",
          "impl EditionAnalyzer {",
          "    /// Create a new edition analyzer",
          "    pub fn new(project_path: impl AsRef<Path>) -> Self {",
          "        Self {",
          "            project_path: project_path.as_ref().to_path_buf(),",
          "        }",
          "    }"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use std::process::Command;",
          "use walkdir::WalkDir;",
          "use super::Edition;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 16: /// Create a new edition analyzer"
        ],
        "control_flow": [
          "Line 10: Control structure",
          "Line 23: Control structure",
          "Line 34: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 66: Control structure",
          "Line 70: Control structure",
          "Line 75: Control structure",
          "Line 83: Control structure",
          "Line 84: Control structure",
          "Line 85: Control structure",
          "Line 90: Control structure",
          "Line 103: Control structure",
          "Line 109: Control structure",
          "Line 111: Control structure",
          "Line 113: Control structure",
          "Line 117: Control structure",
          "Line 121: Control structure",
          "Line 127: Control structure",
          "Line 153: Control structure",
          "Line 171: Control structure",
          "Line 182: Control structure",
          "Line 187: Control structure"
        ],
        "variable_usage": {
          "manifest_content": [
            238
          ],
          "mut": [
            24
          ],
          "cargo_path": [
            62
          ],
          "output": [
            75
          ],
          "stderr": [
            80
          ],
          "lints": [
            67
          ],
          "_report": [
            251
          ],
          "current_edition": [
            66
          ],
          "temp_dir": [
            234
          ],
          "analyzer": [
            235
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 45: Error handling point",
          "Line 49: Error handling point",
          "Line 64: Error handling point",
          "Line 67: Error handling point",
          "Line 79: Error handling point",
          "Line 235: Error handling point",
          "Line 248: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "walkdir",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/analyzer.rs",
        "line": 23,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        Self {",
          "            project_path: project_path.as_ref().to_path_buf(),",
          "        }",
          "    }",
          "",
          "    /// Analyze the project for edition compatibility issues",
          "    pub async fn analyze(&self, target_edition: Edition) -> Result<AnalysisReport> {",
          "        let mut report = AnalysisReport {",
          "            target_edition,",
          "            total_files: 0,",
          "            issues: Vec::new(),"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use std::process::Command;",
          "use walkdir::WalkDir;",
          "use super::Edition;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 23: /// Analyze the project for edition compatibility issues"
        ],
        "control_flow": [
          "Line 10: Control structure",
          "Line 23: Control structure",
          "Line 34: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 66: Control structure",
          "Line 70: Control structure",
          "Line 75: Control structure",
          "Line 83: Control structure",
          "Line 84: Control structure",
          "Line 85: Control structure",
          "Line 90: Control structure",
          "Line 103: Control structure",
          "Line 109: Control structure",
          "Line 111: Control structure",
          "Line 113: Control structure",
          "Line 117: Control structure",
          "Line 121: Control structure",
          "Line 127: Control structure",
          "Line 153: Control structure",
          "Line 171: Control structure",
          "Line 182: Control structure",
          "Line 187: Control structure"
        ],
        "variable_usage": {
          "_report": [
            251
          ],
          "cargo_path": [
            62
          ],
          "manifest_content": [
            238
          ],
          "mut": [
            24
          ],
          "output": [
            75
          ],
          "current_edition": [
            66
          ],
          "lints": [
            67
          ],
          "temp_dir": [
            234
          ],
          "stderr": [
            80
          ],
          "analyzer": [
            235
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 45: Error handling point",
          "Line 49: Error handling point",
          "Line 64: Error handling point",
          "Line 67: Error handling point",
          "Line 79: Error handling point",
          "Line 235: Error handling point",
          "Line 248: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "walkdir",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/analyzer.rs",
        "line": 138,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        }",
          "",
          "        Ok(())",
          "    }",
          "",
          "    /// Add migration suggestions",
          "    fn add_suggestions(&self, target_edition: Edition, report: &mut AnalysisReport) {",
          "        report.suggestions.push(format!(",
          "            \"Run `cargo fix --edition` to automatically fix most edition issues\"",
          "        ));",
          ""
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use std::process::Command;",
          "use walkdir::WalkDir;",
          "use super::Edition;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 138: /// Add migration suggestions"
        ],
        "control_flow": [
          "Line 10: Control structure",
          "Line 23: Control structure",
          "Line 34: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 66: Control structure",
          "Line 70: Control structure",
          "Line 75: Control structure",
          "Line 83: Control structure",
          "Line 84: Control structure",
          "Line 85: Control structure",
          "Line 90: Control structure",
          "Line 103: Control structure",
          "Line 109: Control structure",
          "Line 111: Control structure",
          "Line 113: Control structure",
          "Line 117: Control structure",
          "Line 121: Control structure",
          "Line 127: Control structure",
          "Line 153: Control structure",
          "Line 171: Control structure",
          "Line 182: Control structure",
          "Line 187: Control structure"
        ],
        "variable_usage": {
          "cargo_path": [
            62
          ],
          "output": [
            75
          ],
          "stderr": [
            80
          ],
          "_report": [
            251
          ],
          "temp_dir": [
            234
          ],
          "mut": [
            24
          ],
          "current_edition": [
            66
          ],
          "lints": [
            67
          ],
          "analyzer": [
            235
          ],
          "manifest_content": [
            238
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 45: Error handling point",
          "Line 49: Error handling point",
          "Line 64: Error handling point",
          "Line 67: Error handling point",
          "Line 79: Error handling point",
          "Line 235: Error handling point",
          "Line 248: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "walkdir",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/migrator.rs",
        "line": 17,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    project_path: PathBuf,",
          "    backup_dir: Option<PathBuf>,",
          "}",
          "",
          "impl EditionMigrator {",
          "    /// Create a new edition migrator",
          "    pub fn new(project_path: impl AsRef<Path>) -> Self {",
          "        Self {",
          "            project_path: project_path.as_ref().to_path_buf(),",
          "            backup_dir: None,",
          "        }"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::{Path, PathBuf};",
          "use std::process::Command;",
          "use tokio::fs;",
          "use super::Edition;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 17: /// Create a new edition migrator"
        ],
        "control_flow": [
          "Line 10: Control structure",
          "Line 43: Control structure",
          "Line 48: Control structure",
          "Line 49: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 65: Control structure",
          "Line 69: Control structure",
          "Line 70: Control structure",
          "Line 103: Control structure",
          "Line 125: Control structure",
          "Line 129: Control structure",
          "Line 133: Control structure",
          "Line 137: Control structure",
          "Line 146: Control structure",
          "Line 151: Control structure",
          "Line 178: Control structure",
          "Line 179: Control structure",
          "Line 206: Control structure",
          "Line 222: Control structure",
          "Line 227: Control structure",
          "Line 233: Control structure",
          "Line 243: Control structure",
          "Line 261: Control structure",
          "Line 284: Control structure",
          "Line 309: Control structure"
        ],
        "variable_usage": {
          "mut": [
            36,
            122,
            174
          ],
          "output": [
            104,
            140,
            200
          ],
          "current_edition": [
            40
          ],
          "manifest_src": [
            90
          ],
          "stderr": [
            146
          ],
          "backup_dir": [
            81
          ],
          "cargo_path": [
            119
          ],
          "project_manifest": [
            224
          ],
          "options": [
            322
          ],
          "manifest_path": [
            39,
            171
          ],
          "new_contents": [
            186
          ],
          "stdout": [
            159
          ],
          "Some(table)": [
            178
          ],
          "Some(package)": [
            177
          ],
          "temp_dir": [
            331
          ],
          "migrator": [
            332
          ],
          "backup_manifest": [
            223
          ],
          "contents": [
            172
          ],
          "Some(backup_dir)": [
            221
          ],
          "manifest_dst": [
            91
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 41: Error handling point",
          "Line 50: Error handling point",
          "Line 54: Error handling point",
          "Line 62: Error handling point",
          "Line 66: Error handling point",
          "Line 71: Error handling point",
          "Line 88: Error handling point",
          "Line 93: Error handling point",
          "Line 108: Error handling point",
          "Line 121: Error handling point",
          "Line 144: Error handling point",
          "Line 173: Error handling point",
          "Line 175: Error handling point",
          "Line 188: Error handling point",
          "Line 189: Error handling point",
          "Line 204: Error handling point",
          "Line 228: Error handling point",
          "Line 332: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "tokio",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/migrator.rs",
        "line": 25,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "            project_path: project_path.as_ref().to_path_buf(),",
          "            backup_dir: None,",
          "        }",
          "    }",
          "",
          "    /// Set backup directory",
          "    pub fn with_backup(mut self, backup_dir: impl AsRef<Path>) -> Self {",
          "        self.backup_dir = Some(backup_dir.as_ref().to_path_buf());",
          "        self",
          "    }",
          ""
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::{Path, PathBuf};",
          "use std::process::Command;",
          "use tokio::fs;",
          "use super::Edition;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 25: /// Set backup directory"
        ],
        "control_flow": [
          "Line 10: Control structure",
          "Line 43: Control structure",
          "Line 48: Control structure",
          "Line 49: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 65: Control structure",
          "Line 69: Control structure",
          "Line 70: Control structure",
          "Line 103: Control structure",
          "Line 125: Control structure",
          "Line 129: Control structure",
          "Line 133: Control structure",
          "Line 137: Control structure",
          "Line 146: Control structure",
          "Line 151: Control structure",
          "Line 178: Control structure",
          "Line 179: Control structure",
          "Line 206: Control structure",
          "Line 222: Control structure",
          "Line 227: Control structure",
          "Line 233: Control structure",
          "Line 243: Control structure",
          "Line 261: Control structure",
          "Line 284: Control structure",
          "Line 309: Control structure"
        ],
        "variable_usage": {
          "new_contents": [
            186
          ],
          "manifest_dst": [
            91
          ],
          "stdout": [
            159
          ],
          "project_manifest": [
            224
          ],
          "migrator": [
            332
          ],
          "backup_dir": [
            81
          ],
          "manifest_src": [
            90
          ],
          "stderr": [
            146
          ],
          "manifest_path": [
            39,
            171
          ],
          "Some(package)": [
            177
          ],
          "mut": [
            36,
            122,
            174
          ],
          "Some(backup_dir)": [
            221
          ],
          "output": [
            104,
            140,
            200
          ],
          "backup_manifest": [
            223
          ],
          "options": [
            322
          ],
          "current_edition": [
            40
          ],
          "cargo_path": [
            119
          ],
          "contents": [
            172
          ],
          "Some(table)": [
            178
          ],
          "temp_dir": [
            331
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 41: Error handling point",
          "Line 50: Error handling point",
          "Line 54: Error handling point",
          "Line 62: Error handling point",
          "Line 66: Error handling point",
          "Line 71: Error handling point",
          "Line 88: Error handling point",
          "Line 93: Error handling point",
          "Line 108: Error handling point",
          "Line 121: Error handling point",
          "Line 144: Error handling point",
          "Line 173: Error handling point",
          "Line 175: Error handling point",
          "Line 188: Error handling point",
          "Line 189: Error handling point",
          "Line 204: Error handling point",
          "Line 228: Error handling point",
          "Line 332: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "tokio",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/edition/migrator.rs",
        "line": 331,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": "impl Default for MigrationStatus {",
        "surrounding_code": [
          "        assert!(options.update_manifest);",
          "        assert!(!options.run_tests);",
          "    }",
          "",
          "    #[tokio::test]",
          "    async fn test_migrator_creation() {",
          "        let temp_dir = TempDir::new().unwrap();",
          "        let migrator =",
          "            EditionMigrator::new(temp_dir.path()).with_backup(temp_dir.path().join(\"backup\"));",
          "",
          "        assert_eq!(migrator.project_path, temp_dir.path());"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::{Path, PathBuf};",
          "use std::process::Command;",
          "use tokio::fs;",
          "use super::Edition;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 331: async fn test_migrator_creation() {"
        ],
        "control_flow": [
          "Line 10: Control structure",
          "Line 43: Control structure",
          "Line 48: Control structure",
          "Line 49: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 65: Control structure",
          "Line 69: Control structure",
          "Line 70: Control structure",
          "Line 103: Control structure",
          "Line 125: Control structure",
          "Line 129: Control structure",
          "Line 133: Control structure",
          "Line 137: Control structure",
          "Line 146: Control structure",
          "Line 151: Control structure",
          "Line 178: Control structure",
          "Line 179: Control structure",
          "Line 206: Control structure",
          "Line 222: Control structure",
          "Line 227: Control structure",
          "Line 233: Control structure",
          "Line 243: Control structure",
          "Line 261: Control structure",
          "Line 284: Control structure",
          "Line 309: Control structure"
        ],
        "variable_usage": {
          "manifest_dst": [
            91
          ],
          "migrator": [
            332
          ],
          "manifest_src": [
            90
          ],
          "output": [
            104,
            140,
            200
          ],
          "current_edition": [
            40
          ],
          "cargo_path": [
            119
          ],
          "stdout": [
            159
          ],
          "mut": [
            36,
            122,
            174
          ],
          "contents": [
            172
          ],
          "Some(table)": [
            178
          ],
          "temp_dir": [
            331
          ],
          "backup_manifest": [
            223
          ],
          "backup_dir": [
            81
          ],
          "new_contents": [
            186
          ],
          "manifest_path": [
            39,
            171
          ],
          "options": [
            322
          ],
          "stderr": [
            146
          ],
          "Some(package)": [
            177
          ],
          "Some(backup_dir)": [
            221
          ],
          "project_manifest": [
            224
          ]
        },
        "function_calls": [
          "async fn test_migrator_creation"
        ],
        "error_propagation_path": [
          "Line 41: Error handling point",
          "Line 50: Error handling point",
          "Line 54: Error handling point",
          "Line 62: Error handling point",
          "Line 66: Error handling point",
          "Line 71: Error handling point",
          "Line 88: Error handling point",
          "Line 93: Error handling point",
          "Line 108: Error handling point",
          "Line 121: Error handling point",
          "Line 144: Error handling point",
          "Line 173: Error handling point",
          "Line 175: Error handling point",
          "Line 188: Error handling point",
          "Line 189: Error handling point",
          "Line 204: Error handling point",
          "Line 228: Error handling point",
          "Line 332: Error handling point"
        ]
      },
      "fix_complexity": "Complex",
      "dependencies": [
        "crate",
        "std",
        "std",
        "tokio",
        "super",
        "async fn test_migrator_creation"
      ],
      "side_effects": [],
      "confidence_score": 0.75
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/mod.rs",
        "line": 105,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_edition",
        "function_signature": "# [doc = \" Detect edition from Cargo.toml\"] pub async fn detect_edition (manifest_path : & Path) -> Result < Edition > { if ! manifest_path . exists () { return Err (Error :: file_not_found (format ! (\"Cargo.toml not found at {}\" , manifest_path . display ()))) ; } let contents = fs :: read_to_string (manifest_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; let edition_str = manifest . get (\"package\") . and_then (| p | p . get (\"edition\")) . and_then (| e | e . as_str ()) . unwrap_or (\"2015\") ; Edition :: parse_edition (edition_str) } . sig",
        "return_type": "Result < Edition >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl std::fmt::Display for Edition {",
        "surrounding_code": [
          "    /// Recommended migration path",
          "    pub migration_path: Vec<Edition>,",
          "}",
          "",
          "impl EditionStatus {",
          "    /// Create a new edition status",
          "    pub fn new(current: Edition, manifest_path: PathBuf) -> Self {",
          "        let latest = Edition::latest();",
          "        let is_latest = current == latest;",
          "",
          "        // Build migration path"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::{Path, PathBuf};",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 105: /// Create a new edition status"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 33: Control structure",
          "Line 44: Control structure",
          "Line 57: Control structure",
          "Line 64: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 83: Control structure",
          "Line 115: Control structure",
          "Line 135: Control structure",
          "Line 151: Control structure",
          "Line 156: Control structure",
          "Line 168: Control structure",
          "Line 174: Control structure"
        ],
        "variable_usage": {
          "edition": [
            158,
            262
          ],
          "edition_str": [
            146
          ],
          "is_latest": [
            107
          ],
          "mut": [
            110,
            111,
            165
          ],
          "manifest_path": [
            157,
            251
          ],
          "latest": [
            106
          ],
          "manifest": [
            142
          ],
          "Some(next)": [
            113
          ],
          "contents": [
            141
          ],
          "temp_dir": [
            250
          ],
          "manifest_content": [
            253
          ],
          "status": [
            241
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 96: Error handling point",
          "Line 142: Error handling point",
          "Line 144: Error handling point",
          "Line 159: Error handling point",
          "Line 207: Error handling point",
          "Line 211: Error handling point",
          "Line 215: Error handling point",
          "Line 219: Error handling point",
          "Line 251: Error handling point",
          "Line 261: Error handling point",
          "Line 263: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/mod.rs",
        "line": 133,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_edition",
        "function_signature": "# [doc = \" Detect edition from Cargo.toml\"] pub async fn detect_edition (manifest_path : & Path) -> Result < Edition > { if ! manifest_path . exists () { return Err (Error :: file_not_found (format ! (\"Cargo.toml not found at {}\" , manifest_path . display ()))) ; } let contents = fs :: read_to_string (manifest_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; let edition_str = manifest . get (\"package\") . and_then (| p | p . get (\"edition\")) . and_then (| e | e . as_str ()) . unwrap_or (\"2015\") ; Edition :: parse_edition (edition_str) } . sig",
        "return_type": "Result < Edition >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl std::fmt::Display for Edition {",
        "surrounding_code": [
          "            migration_path,",
          "        }",
          "    }",
          "}",
          "",
          "/// Detect edition from Cargo.toml",
          "pub async fn detect_edition(manifest_path: &Path) -> Result<Edition> {",
          "    if !manifest_path.exists() {",
          "        return Err(Error::file_not_found(format!(",
          "            \"Cargo.toml not found at {}\",",
          "            manifest_path.display()"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::{Path, PathBuf};",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 133: /// Detect edition from Cargo.toml"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 33: Control structure",
          "Line 44: Control structure",
          "Line 57: Control structure",
          "Line 64: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 83: Control structure",
          "Line 115: Control structure",
          "Line 135: Control structure",
          "Line 151: Control structure",
          "Line 156: Control structure",
          "Line 168: Control structure",
          "Line 174: Control structure"
        ],
        "variable_usage": {
          "is_latest": [
            107
          ],
          "mut": [
            110,
            111,
            165
          ],
          "Some(next)": [
            113
          ],
          "contents": [
            141
          ],
          "status": [
            241
          ],
          "manifest_path": [
            157,
            251
          ],
          "temp_dir": [
            250
          ],
          "manifest": [
            142
          ],
          "latest": [
            106
          ],
          "manifest_content": [
            253
          ],
          "edition": [
            158,
            262
          ],
          "edition_str": [
            146
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 96: Error handling point",
          "Line 142: Error handling point",
          "Line 144: Error handling point",
          "Line 159: Error handling point",
          "Line 207: Error handling point",
          "Line 211: Error handling point",
          "Line 215: Error handling point",
          "Line 219: Error handling point",
          "Line 251: Error handling point",
          "Line 261: Error handling point",
          "Line 263: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/edition/mod.rs",
        "line": 156,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_edition",
        "function_signature": "# [doc = \" Detect edition from Cargo.toml\"] pub async fn detect_edition (manifest_path : & Path) -> Result < Edition > { if ! manifest_path . exists () { return Err (Error :: file_not_found (format ! (\"Cargo.toml not found at {}\" , manifest_path . display ()))) ; } let contents = fs :: read_to_string (manifest_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; let edition_str = manifest . get (\"package\") . and_then (| p | p . get (\"edition\")) . and_then (| e | e . as_str ()) . unwrap_or (\"2015\") ; Edition :: parse_edition (edition_str) } . sig",
        "return_type": "Result < Edition >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl std::fmt::Display for Edition {",
        "surrounding_code": [
          "        .unwrap_or(\"2015\"); // Default to 2015 if not specified",
          "",
          "    Edition::parse_edition(edition_str)",
          "}",
          "",
          "/// Check edition compliance for a project",
          "pub async fn check_compliance(project_path: &Path) -> Result<EditionStatus> {",
          "    let manifest_path = project_path.join(\"Cargo.toml\");",
          "    let edition = detect_edition(&manifest_path).await?;",
          "",
          "    Ok(EditionStatus::new(edition, manifest_path))"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::{Path, PathBuf};",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 156: /// Check edition compliance for a project"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 33: Control structure",
          "Line 44: Control structure",
          "Line 57: Control structure",
          "Line 64: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 83: Control structure",
          "Line 115: Control structure",
          "Line 135: Control structure",
          "Line 151: Control structure",
          "Line 156: Control structure",
          "Line 168: Control structure",
          "Line 174: Control structure"
        ],
        "variable_usage": {
          "latest": [
            106
          ],
          "status": [
            241
          ],
          "manifest_content": [
            253
          ],
          "manifest_path": [
            157,
            251
          ],
          "mut": [
            110,
            111,
            165
          ],
          "temp_dir": [
            250
          ],
          "manifest": [
            142
          ],
          "Some(next)": [
            113
          ],
          "contents": [
            141
          ],
          "edition_str": [
            146
          ],
          "edition": [
            158,
            262
          ],
          "is_latest": [
            107
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 96: Error handling point",
          "Line 142: Error handling point",
          "Line 144: Error handling point",
          "Line 159: Error handling point",
          "Line 207: Error handling point",
          "Line 211: Error handling point",
          "Line 215: Error handling point",
          "Line 219: Error handling point",
          "Line 251: Error handling point",
          "Line 261: Error handling point",
          "Line 263: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/edition/mod.rs",
        "line": 250,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_edition",
        "function_signature": "# [doc = \" Detect edition from Cargo.toml\"] pub async fn detect_edition (manifest_path : & Path) -> Result < Edition > { if ! manifest_path . exists () { return Err (Error :: file_not_found (format ! (\"Cargo.toml not found at {}\" , manifest_path . display ()))) ; } let contents = fs :: read_to_string (manifest_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; let edition_str = manifest . get (\"package\") . and_then (| p | p . get (\"edition\")) . and_then (| e | e . as_str ()) . unwrap_or (\"2015\") ; Edition :: parse_edition (edition_str) } . sig",
        "return_type": "Result < Edition >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl std::fmt::Display for Edition {",
        "surrounding_code": [
          "        assert_eq!(status.migration_path[1], Edition::Edition2021);",
          "        assert_eq!(status.migration_path[2], Edition::Edition2024);",
          "    }",
          "",
          "    #[tokio::test]",
          "    async fn test_detect_edition() {",
          "        let temp_dir = TempDir::new().unwrap();",
          "        let manifest_path = temp_dir.path().join(\"Cargo.toml\");",
          "",
          "        let manifest_content = r#\"",
          "[package]"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::{Path, PathBuf};",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 250: async fn test_detect_edition() {"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 33: Control structure",
          "Line 44: Control structure",
          "Line 57: Control structure",
          "Line 64: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 83: Control structure",
          "Line 115: Control structure",
          "Line 135: Control structure",
          "Line 151: Control structure",
          "Line 156: Control structure",
          "Line 168: Control structure",
          "Line 174: Control structure"
        ],
        "variable_usage": {
          "edition_str": [
            146
          ],
          "status": [
            241
          ],
          "temp_dir": [
            250
          ],
          "manifest_content": [
            253
          ],
          "manifest": [
            142
          ],
          "Some(next)": [
            113
          ],
          "mut": [
            110,
            111,
            165
          ],
          "manifest_path": [
            157,
            251
          ],
          "is_latest": [
            107
          ],
          "latest": [
            106
          ],
          "contents": [
            141
          ],
          "edition": [
            158,
            262
          ]
        },
        "function_calls": [
          "async fn test_detect_edition"
        ],
        "error_propagation_path": [
          "Line 96: Error handling point",
          "Line 142: Error handling point",
          "Line 144: Error handling point",
          "Line 159: Error handling point",
          "Line 207: Error handling point",
          "Line 211: Error handling point",
          "Line 215: Error handling point",
          "Line 219: Error handling point",
          "Line 251: Error handling point",
          "Line 261: Error handling point",
          "Line 263: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "tokio",
        "async fn test_detect_edition"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/edition/mod.rs",
        "line": 260,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_edition",
        "function_signature": "# [doc = \" Detect edition from Cargo.toml\"] pub async fn detect_edition (manifest_path : & Path) -> Result < Edition > { if ! manifest_path . exists () { return Err (Error :: file_not_found (format ! (\"Cargo.toml not found at {}\" , manifest_path . display ()))) ; } let contents = fs :: read_to_string (manifest_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; let edition_str = manifest . get (\"package\") . and_then (| p | p . get (\"edition\")) . and_then (| e | e . as_str ()) . unwrap_or (\"2015\") ; Edition :: parse_edition (edition_str) } . sig",
        "return_type": "Result < Edition >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl std::fmt::Display for Edition {",
        "surrounding_code": [
          "[package]",
          "name = \"test\"",
          "version = \"0.1.0\"",
          "edition = \"2021\"",
          "\"#;",
          "",
          "        fs::write(&manifest_path, manifest_content).await.unwrap();",
          "",
          "        let edition = detect_edition(&manifest_path).await.unwrap();",
          "        assert_eq!(edition, Edition::Edition2021);",
          "    }"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::{Path, PathBuf};",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 260: "
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 33: Control structure",
          "Line 44: Control structure",
          "Line 57: Control structure",
          "Line 64: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 83: Control structure",
          "Line 115: Control structure",
          "Line 135: Control structure",
          "Line 151: Control structure",
          "Line 156: Control structure",
          "Line 168: Control structure",
          "Line 174: Control structure"
        ],
        "variable_usage": {
          "mut": [
            110,
            111,
            165
          ],
          "manifest": [
            142
          ],
          "edition_str": [
            146
          ],
          "temp_dir": [
            250
          ],
          "contents": [
            141
          ],
          "latest": [
            106
          ],
          "is_latest": [
            107
          ],
          "status": [
            241
          ],
          "Some(next)": [
            113
          ],
          "edition": [
            158,
            262
          ],
          "manifest_content": [
            253
          ],
          "manifest_path": [
            157,
            251
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 96: Error handling point",
          "Line 142: Error handling point",
          "Line 144: Error handling point",
          "Line 159: Error handling point",
          "Line 207: Error handling point",
          "Line 211: Error handling point",
          "Line 215: Error handling point",
          "Line 219: Error handling point",
          "Line 251: Error handling point",
          "Line 261: Error handling point",
          "Line 263: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/edition/mod.rs",
        "line": 262,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_edition",
        "function_signature": "# [doc = \" Detect edition from Cargo.toml\"] pub async fn detect_edition (manifest_path : & Path) -> Result < Edition > { if ! manifest_path . exists () { return Err (Error :: file_not_found (format ! (\"Cargo.toml not found at {}\" , manifest_path . display ()))) ; } let contents = fs :: read_to_string (manifest_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; let edition_str = manifest . get (\"package\") . and_then (| p | p . get (\"edition\")) . and_then (| e | e . as_str ()) . unwrap_or (\"2015\") ; Edition :: parse_edition (edition_str) } . sig",
        "return_type": "Result < Edition >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl std::fmt::Display for Edition {",
        "surrounding_code": [
          "version = \"0.1.0\"",
          "edition = \"2021\"",
          "\"#;",
          "",
          "        fs::write(&manifest_path, manifest_content).await.unwrap();",
          "",
          "        let edition = detect_edition(&manifest_path).await.unwrap();",
          "        assert_eq!(edition, Edition::Edition2021);",
          "    }",
          "}"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::{Path, PathBuf};",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 262: "
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 33: Control structure",
          "Line 44: Control structure",
          "Line 57: Control structure",
          "Line 64: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 83: Control structure",
          "Line 115: Control structure",
          "Line 135: Control structure",
          "Line 151: Control structure",
          "Line 156: Control structure",
          "Line 168: Control structure",
          "Line 174: Control structure"
        ],
        "variable_usage": {
          "mut": [
            110,
            111,
            165
          ],
          "manifest": [
            142
          ],
          "manifest_content": [
            253
          ],
          "edition": [
            158,
            262
          ],
          "status": [
            241
          ],
          "Some(next)": [
            113
          ],
          "manifest_path": [
            157,
            251
          ],
          "edition_str": [
            146
          ],
          "contents": [
            141
          ],
          "temp_dir": [
            250
          ],
          "is_latest": [
            107
          ],
          "latest": [
            106
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 96: Error handling point",
          "Line 142: Error handling point",
          "Line 144: Error handling point",
          "Line 159: Error handling point",
          "Line 207: Error handling point",
          "Line 211: Error handling point",
          "Line 215: Error handling point",
          "Line 219: Error handling point",
          "Line 251: Error handling point",
          "Line 261: Error handling point",
          "Line 263: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/error.rs",
        "line": 156,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    /// Create a new file not found error",
          "    pub fn file_not_found(msg: impl Into<String>) -> Self {",
          "        Self::FileNotFound(msg.into())",
          "    }",
          "",
          "    /// Create a new rate limited error",
          "    pub fn rate_limited(retry_after: u64) -> Self {",
          "        Self::RateLimited(retry_after)",
          "    }",
          "",
          "    /// Create a new migration error"
        ],
        "imports": [],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 156: /// Create a new rate limited error"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 3: Control structure",
          "Line 97: Control structure",
          "Line 183: Control structure",
          "Line 190: Control structure"
        ],
        "variable_usage": {},
        "function_calls": [],
        "error_propagation_path": []
      },
      "fix_complexity": "Moderate",
      "dependencies": [],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/formatting.rs",
        "line": 77,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_formatting",
        "function_signature": "# [doc = \" Check code formatting\"] pub async fn check_formatting (project_path : & Path) -> Result < FormatResult > { ensure_rustfmt_installed () . await ? ; let output = Command :: new (\"cargo\") . args (& [\"fmt\" , \"--\" , \"--check\" , \"--verbose\"]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo fmt: {}\" , e))) ? ; parse_format_output (& output . stdout , & output . stderr , output . status . success ()) } . sig",
        "return_type": "Result < FormatResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "",
          "        report",
          "    }",
          "}",
          "",
          "/// Check code formatting",
          "pub async fn check_formatting(project_path: &Path) -> Result<FormatResult> {",
          "    // Ensure rustfmt is installed",
          "    ensure_rustfmt_installed().await?;",
          "",
          "    // Run cargo fmt with check mode"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 77: /// Check code formatting"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 22: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 51: Control structure",
          "Line 53: Control structure",
          "Line 60: Control structure",
          "Line 107: Control structure",
          "Line 116: Control structure",
          "Line 150: Control structure",
          "Line 181: Control structure",
          "Line 192: Control structure",
          "Line 204: Control structure",
          "Line 219: Control structure",
          "Line 220: Control structure",
          "Line 221: Control structure",
          "Line 229: Control structure",
          "Line 230: Control structure",
          "Line 231: Control structure",
          "Line 232: Control structure",
          "Line 233: Control structure",
          "Line 238: Control structure",
          "Line 264: Control structure"
        ],
        "variable_usage": {
          "start": [
            233
          ],
          "install": [
            186
          ],
          "rustfmt_toml": [
            261
          ],
          "file": [
            221,
            222,
            234
          ],
          "output": [
            82,
            100,
            121,
            140,
            167
          ],
          "stdout_str": [
            212
          ],
          "Some(file)": [
            220
          ],
          "mut": [
            35,
            214,
            215
          ],
          "config": [
            265
          ],
          "result": [
            312,
            325
          ],
          "line_num": [
            237
          ],
          "stderr": [
            110,
            152
          ],
          "check": [
            178
          ],
          "stderr_str": [
            211
          ],
          "Some(pos)": [
            232
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 80: Error handling point",
          "Line 87: Error handling point",
          "Line 96: Error handling point",
          "Line 105: Error handling point",
          "Line 119: Error handling point",
          "Line 127: Error handling point",
          "Line 130: Error handling point",
          "Line 138: Error handling point",
          "Line 145: Error handling point",
          "Line 148: Error handling point",
          "Line 165: Error handling point",
          "Line 172: Error handling point",
          "Line 190: Error handling point",
          "Line 298: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/formatting.rs",
        "line": 93,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_formatting",
        "function_signature": "# [doc = \" Check code formatting\"] pub async fn check_formatting (project_path : & Path) -> Result < FormatResult > { ensure_rustfmt_installed () . await ? ; let output = Command :: new (\"cargo\") . args (& [\"fmt\" , \"--\" , \"--check\" , \"--verbose\"]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo fmt: {}\" , e))) ? ; parse_format_output (& output . stdout , & output . stderr , output . status . success ()) } . sig",
        "return_type": "Result < FormatResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "",
          "    // Parse the output",
          "    parse_format_output(&output.stdout, &output.stderr, output.status.success())",
          "}",
          "",
          "/// Auto-format code",
          "pub async fn auto_format(project_path: &Path) -> Result<()> {",
          "    // Ensure rustfmt is installed",
          "    ensure_rustfmt_installed().await?;",
          "",
          "    println!(\"🔧 Auto-formatting code...\");"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 93: /// Auto-format code"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 22: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 51: Control structure",
          "Line 53: Control structure",
          "Line 60: Control structure",
          "Line 107: Control structure",
          "Line 116: Control structure",
          "Line 150: Control structure",
          "Line 181: Control structure",
          "Line 192: Control structure",
          "Line 204: Control structure",
          "Line 219: Control structure",
          "Line 220: Control structure",
          "Line 221: Control structure",
          "Line 229: Control structure",
          "Line 230: Control structure",
          "Line 231: Control structure",
          "Line 232: Control structure",
          "Line 233: Control structure",
          "Line 238: Control structure",
          "Line 264: Control structure"
        ],
        "variable_usage": {
          "stderr_str": [
            211
          ],
          "file": [
            221,
            222,
            234
          ],
          "install": [
            186
          ],
          "rustfmt_toml": [
            261
          ],
          "start": [
            233
          ],
          "result": [
            312,
            325
          ],
          "check": [
            178
          ],
          "config": [
            265
          ],
          "output": [
            82,
            100,
            121,
            140,
            167
          ],
          "stderr": [
            110,
            152
          ],
          "stdout_str": [
            212
          ],
          "Some(file)": [
            220
          ],
          "Some(pos)": [
            232
          ],
          "mut": [
            35,
            214,
            215
          ],
          "line_num": [
            237
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 80: Error handling point",
          "Line 87: Error handling point",
          "Line 96: Error handling point",
          "Line 105: Error handling point",
          "Line 119: Error handling point",
          "Line 127: Error handling point",
          "Line 130: Error handling point",
          "Line 138: Error handling point",
          "Line 145: Error handling point",
          "Line 148: Error handling point",
          "Line 165: Error handling point",
          "Line 172: Error handling point",
          "Line 190: Error handling point",
          "Line 298: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/formatting.rs",
        "line": 116,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_formatting",
        "function_signature": "# [doc = \" Check code formatting\"] pub async fn check_formatting (project_path : & Path) -> Result < FormatResult > { ensure_rustfmt_installed () . await ? ; let output = Command :: new (\"cargo\") . args (& [\"fmt\" , \"--\" , \"--check\" , \"--verbose\"]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo fmt: {}\" , e))) ? ; parse_format_output (& output . stdout , & output . stderr , output . status . success ()) } . sig",
        "return_type": "Result < FormatResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        let stderr = String::from_utf8_lossy(&output.stderr);",
          "        Err(Error::process(format!(\"Formatting failed: {}\", stderr)))",
          "    }",
          "}",
          "",
          "/// Check formatting for a specific file",
          "pub async fn check_file_formatting(file_path: &Path) -> Result<bool> {",
          "    // Ensure rustfmt is installed",
          "    ensure_rustfmt_installed().await?;",
          "",
          "    // Run rustfmt with check mode on single file"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 116: /// Check formatting for a specific file"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 22: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 51: Control structure",
          "Line 53: Control structure",
          "Line 60: Control structure",
          "Line 107: Control structure",
          "Line 116: Control structure",
          "Line 150: Control structure",
          "Line 181: Control structure",
          "Line 192: Control structure",
          "Line 204: Control structure",
          "Line 219: Control structure",
          "Line 220: Control structure",
          "Line 221: Control structure",
          "Line 229: Control structure",
          "Line 230: Control structure",
          "Line 231: Control structure",
          "Line 232: Control structure",
          "Line 233: Control structure",
          "Line 238: Control structure",
          "Line 264: Control structure"
        ],
        "variable_usage": {
          "stderr": [
            110,
            152
          ],
          "Some(file)": [
            220
          ],
          "config": [
            265
          ],
          "Some(pos)": [
            232
          ],
          "stdout_str": [
            212
          ],
          "stderr_str": [
            211
          ],
          "file": [
            221,
            222,
            234
          ],
          "start": [
            233
          ],
          "install": [
            186
          ],
          "check": [
            178
          ],
          "line_num": [
            237
          ],
          "result": [
            312,
            325
          ],
          "rustfmt_toml": [
            261
          ],
          "mut": [
            35,
            214,
            215
          ],
          "output": [
            82,
            100,
            121,
            140,
            167
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 80: Error handling point",
          "Line 87: Error handling point",
          "Line 96: Error handling point",
          "Line 105: Error handling point",
          "Line 119: Error handling point",
          "Line 127: Error handling point",
          "Line 130: Error handling point",
          "Line 138: Error handling point",
          "Line 145: Error handling point",
          "Line 148: Error handling point",
          "Line 165: Error handling point",
          "Line 172: Error handling point",
          "Line 190: Error handling point",
          "Line 298: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/formatting.rs",
        "line": 135,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_formatting",
        "function_signature": "# [doc = \" Check code formatting\"] pub async fn check_formatting (project_path : & Path) -> Result < FormatResult > { ensure_rustfmt_installed () . await ? ; let output = Command :: new (\"cargo\") . args (& [\"fmt\" , \"--\" , \"--check\" , \"--verbose\"]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo fmt: {}\" , e))) ? ; parse_format_output (& output . stdout , & output . stderr , output . status . success ()) } . sig",
        "return_type": "Result < FormatResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        .map_err(|e| Error::process(format!(\"Failed to run rustfmt: {}\", e)))?;",
          "",
          "    Ok(output.status.success())",
          "}",
          "",
          "/// Format a specific file",
          "pub async fn format_file(file_path: &Path) -> Result<()> {",
          "    // Ensure rustfmt is installed",
          "    ensure_rustfmt_installed().await?;",
          "",
          "    // Run rustfmt on single file"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 135: /// Format a specific file"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 22: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 51: Control structure",
          "Line 53: Control structure",
          "Line 60: Control structure",
          "Line 107: Control structure",
          "Line 116: Control structure",
          "Line 150: Control structure",
          "Line 181: Control structure",
          "Line 192: Control structure",
          "Line 204: Control structure",
          "Line 219: Control structure",
          "Line 220: Control structure",
          "Line 221: Control structure",
          "Line 229: Control structure",
          "Line 230: Control structure",
          "Line 231: Control structure",
          "Line 232: Control structure",
          "Line 233: Control structure",
          "Line 238: Control structure",
          "Line 264: Control structure"
        ],
        "variable_usage": {
          "stderr_str": [
            211
          ],
          "file": [
            221,
            222,
            234
          ],
          "Some(file)": [
            220
          ],
          "install": [
            186
          ],
          "stderr": [
            110,
            152
          ],
          "result": [
            312,
            325
          ],
          "rustfmt_toml": [
            261
          ],
          "config": [
            265
          ],
          "start": [
            233
          ],
          "check": [
            178
          ],
          "mut": [
            35,
            214,
            215
          ],
          "stdout_str": [
            212
          ],
          "output": [
            82,
            100,
            121,
            140,
            167
          ],
          "line_num": [
            237
          ],
          "Some(pos)": [
            232
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 80: Error handling point",
          "Line 87: Error handling point",
          "Line 96: Error handling point",
          "Line 105: Error handling point",
          "Line 119: Error handling point",
          "Line 127: Error handling point",
          "Line 130: Error handling point",
          "Line 138: Error handling point",
          "Line 145: Error handling point",
          "Line 148: Error handling point",
          "Line 165: Error handling point",
          "Line 172: Error handling point",
          "Line 190: Error handling point",
          "Line 298: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/formatting.rs",
        "line": 162,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_formatting",
        "function_signature": "# [doc = \" Check code formatting\"] pub async fn check_formatting (project_path : & Path) -> Result < FormatResult > { ensure_rustfmt_installed () . await ? ; let output = Command :: new (\"cargo\") . args (& [\"fmt\" , \"--\" , \"--check\" , \"--verbose\"]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo fmt: {}\" , e))) ? ; parse_format_output (& output . stdout , & output . stderr , output . status . success ()) } . sig",
        "return_type": "Result < FormatResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "            stderr",
          "        )))",
          "    }",
          "}",
          "",
          "/// Get formatting diff without applying changes",
          "pub async fn get_format_diff(project_path: &Path) -> Result<String> {",
          "    // Ensure rustfmt is installed",
          "    ensure_rustfmt_installed().await?;",
          "",
          "    // Run cargo fmt with diff output"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 162: /// Get formatting diff without applying changes"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 22: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 51: Control structure",
          "Line 53: Control structure",
          "Line 60: Control structure",
          "Line 107: Control structure",
          "Line 116: Control structure",
          "Line 150: Control structure",
          "Line 181: Control structure",
          "Line 192: Control structure",
          "Line 204: Control structure",
          "Line 219: Control structure",
          "Line 220: Control structure",
          "Line 221: Control structure",
          "Line 229: Control structure",
          "Line 230: Control structure",
          "Line 231: Control structure",
          "Line 232: Control structure",
          "Line 233: Control structure",
          "Line 238: Control structure",
          "Line 264: Control structure"
        ],
        "variable_usage": {
          "result": [
            312,
            325
          ],
          "stderr_str": [
            211
          ],
          "Some(file)": [
            220
          ],
          "Some(pos)": [
            232
          ],
          "install": [
            186
          ],
          "stderr": [
            110,
            152
          ],
          "mut": [
            35,
            214,
            215
          ],
          "check": [
            178
          ],
          "file": [
            221,
            222,
            234
          ],
          "line_num": [
            237
          ],
          "stdout_str": [
            212
          ],
          "rustfmt_toml": [
            261
          ],
          "output": [
            82,
            100,
            121,
            140,
            167
          ],
          "start": [
            233
          ],
          "config": [
            265
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 80: Error handling point",
          "Line 87: Error handling point",
          "Line 96: Error handling point",
          "Line 105: Error handling point",
          "Line 119: Error handling point",
          "Line 127: Error handling point",
          "Line 130: Error handling point",
          "Line 138: Error handling point",
          "Line 145: Error handling point",
          "Line 148: Error handling point",
          "Line 165: Error handling point",
          "Line 172: Error handling point",
          "Line 190: Error handling point",
          "Line 298: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/formatting.rs",
        "line": 260,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "check_formatting",
        "function_signature": "# [doc = \" Check code formatting\"] pub async fn check_formatting (project_path : & Path) -> Result < FormatResult > { ensure_rustfmt_installed () . await ? ; let output = Command :: new (\"cargo\") . args (& [\"fmt\" , \"--\" , \"--check\" , \"--verbose\"]) . current_dir (project_path) . output () . map_err (| e | Error :: process (format ! (\"Failed to run cargo fmt: {}\" , e))) ? ; parse_format_output (& output . stdout , & output . stderr , output . status . success ()) } . sig",
        "return_type": "Result < FormatResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        unformatted_files,",
          "        suggestions,",
          "    })",
          "}",
          "",
          "/// Apply formatting configuration",
          "pub async fn apply_rustfmt_config(project_path: &Path) -> Result<()> {",
          "    let rustfmt_toml = project_path.join(\"rustfmt.toml\");",
          "",
          "    if !rustfmt_toml.exists() {",
          "        // Create default rustfmt.toml"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::Path;",
          "use std::process::Command;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 260: /// Apply formatting configuration"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 22: Control structure",
          "Line 38: Control structure",
          "Line 47: Control structure",
          "Line 51: Control structure",
          "Line 53: Control structure",
          "Line 60: Control structure",
          "Line 107: Control structure",
          "Line 116: Control structure",
          "Line 150: Control structure",
          "Line 181: Control structure",
          "Line 192: Control structure",
          "Line 204: Control structure",
          "Line 219: Control structure",
          "Line 220: Control structure",
          "Line 221: Control structure",
          "Line 229: Control structure",
          "Line 230: Control structure",
          "Line 231: Control structure",
          "Line 232: Control structure",
          "Line 233: Control structure",
          "Line 238: Control structure",
          "Line 264: Control structure"
        ],
        "variable_usage": {
          "install": [
            186
          ],
          "Some(pos)": [
            232
          ],
          "rustfmt_toml": [
            261
          ],
          "mut": [
            35,
            214,
            215
          ],
          "stderr": [
            110,
            152
          ],
          "stdout_str": [
            212
          ],
          "start": [
            233
          ],
          "result": [
            312,
            325
          ],
          "config": [
            265
          ],
          "line_num": [
            237
          ],
          "Some(file)": [
            220
          ],
          "file": [
            221,
            222,
            234
          ],
          "stderr_str": [
            211
          ],
          "output": [
            82,
            100,
            121,
            140,
            167
          ],
          "check": [
            178
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 80: Error handling point",
          "Line 87: Error handling point",
          "Line 96: Error handling point",
          "Line 105: Error handling point",
          "Line 119: Error handling point",
          "Line 127: Error handling point",
          "Line 130: Error handling point",
          "Line 138: Error handling point",
          "Line 145: Error handling point",
          "Line 148: Error handling point",
          "Line 165: Error handling point",
          "Line 172: Error handling point",
          "Line 190: Error handling point",
          "Line 298: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "serde",
        "std",
        "std"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/git_hooks.rs",
        "line": 136,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "install_git_hooks",
        "function_signature": "# [doc = \" Install git hooks in a project\"] pub async fn install_git_hooks (project_path : & Path) -> Result < () > { let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (Error :: validation (\"Not a git repository. Run 'git init' first.\" ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) . await . map_err (| e | Error :: process (format ! (\"Failed to create hooks directory: {}\" , e))) ? ; println ! (\"📝 Installing git hooks...\") ; install_hook (& hooks_dir , \"pre-commit\" , PRE_COMMIT_HOOK) . await ? ; println ! (\"  ✅ Installed pre-commit hook\") ; install_hook (& hooks_dir , \"pre-push\" , PRE_PUSH_HOOK) . await ? ; println ! (\"  ✅ Installed pre-push hook\") ; install_hook (& hooks_dir , \"commit-msg\" , COMMIT_MSG_HOOK) . await ? ; println ! (\"  ✅ Installed commit-msg hook\") ; println ! (\"🎉 Git hooks installed successfully!\") ; println ! () ; println ! (\"Hooks will now run automatically:\") ; println ! (\"  • pre-commit: Validates code before each commit\") ; println ! (\"  • pre-push: Runs tests and full validation before push\") ; println ! (\"  • commit-msg: Ensures conventional commit format\") ; println ! () ; println ! (\"To bypass hooks temporarily, use: git commit --no-verify\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "fi",
          "",
          "echo \"✅ Commit message format valid\"",
          "\"#;",
          "",
          "/// Install git hooks in a project",
          "pub async fn install_git_hooks(project_path: &Path) -> Result<()> {",
          "    // Check if it's a git repository",
          "    let git_dir = project_path.join(\".git\");",
          "    if !git_dir.exists() {",
          "        return Err(Error::validation("
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 136: /// Install git hooks in a project"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 19: Control structure",
          "Line 20: Control structure",
          "Line 29: Control structure",
          "Line 37: Control structure",
          "Line 46: Control structure",
          "Line 52: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 55: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 77: Control structure",
          "Line 85: Control structure",
          "Line 92: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 128: Control structure",
          "Line 138: Control structure",
          "Line 140: Control structure",
          "Line 148: Control structure",
          "Line 183: Control structure",
          "Line 184: Control structure",
          "Line 189: Control structure",
          "Line 232: Control structure",
          "Line 240: Control structure",
          "Line 243: Control structure",
          "Line 244: Control structure",
          "Line 247: Control structure",
          "Line 253: Control structure",
          "Line 255: Control structure",
          "Line 270: Control structure",
          "Line 273: Control structure",
          "Line 280: Control structure",
          "Line 296: Control structure",
          "Line 307: Control structure"
        ],
        "variable_usage": {
          "hook_path": [
            180,
            240
          ],
          "existing": [
            184
          ],
          "mut": [
            215
          ],
          "pre_commit": [
            277
          ],
          "temp_dir": [
            295,
            306
          ],
          "backup_path": [
            194,
            253
          ],
          "content": [
            244,
            280
          ],
          "git_dir": [
            138,
            230,
            271
          ],
          "result": [
            296
          ],
          "installed": [
            307
          ],
          "hooks_dir": [
            145,
            235,
            276
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 110: Error handling point",
          "Line 151: Error handling point",
          "Line 156: Error handling point",
          "Line 160: Error handling point",
          "Line 164: Error handling point",
          "Line 187: Error handling point",
          "Line 198: Error handling point",
          "Line 210: Error handling point",
          "Line 218: Error handling point",
          "Line 223: Error handling point",
          "Line 250: Error handling point",
          "Line 258: Error handling point",
          "Line 296: Error handling point",
          "Line 307: Error handling point",
          "Line 310: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/git_hooks.rs",
        "line": 179,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "install_git_hooks",
        "function_signature": "# [doc = \" Install git hooks in a project\"] pub async fn install_git_hooks (project_path : & Path) -> Result < () > { let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (Error :: validation (\"Not a git repository. Run 'git init' first.\" ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) . await . map_err (| e | Error :: process (format ! (\"Failed to create hooks directory: {}\" , e))) ? ; println ! (\"📝 Installing git hooks...\") ; install_hook (& hooks_dir , \"pre-commit\" , PRE_COMMIT_HOOK) . await ? ; println ! (\"  ✅ Installed pre-commit hook\") ; install_hook (& hooks_dir , \"pre-push\" , PRE_PUSH_HOOK) . await ? ; println ! (\"  ✅ Installed pre-push hook\") ; install_hook (& hooks_dir , \"commit-msg\" , COMMIT_MSG_HOOK) . await ? ; println ! (\"  ✅ Installed commit-msg hook\") ; println ! (\"🎉 Git hooks installed successfully!\") ; println ! () ; println ! (\"Hooks will now run automatically:\") ; println ! (\"  • pre-commit: Validates code before each commit\") ; println ! (\"  • pre-push: Runs tests and full validation before push\") ; println ! (\"  • commit-msg: Ensures conventional commit format\") ; println ! () ; println ! (\"To bypass hooks temporarily, use: git commit --no-verify\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    println!(\"To bypass hooks temporarily, use: git commit --no-verify\");",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Install a single hook",
          "async fn install_hook(hooks_dir: &Path, name: &str, content: &str) -> Result<()> {",
          "    let hook_path = hooks_dir.join(name);",
          "",
          "    // Check if hook already exists",
          "    if hook_path.exists() {"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 179: /// Install a single hook"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 19: Control structure",
          "Line 20: Control structure",
          "Line 29: Control structure",
          "Line 37: Control structure",
          "Line 46: Control structure",
          "Line 52: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 55: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 77: Control structure",
          "Line 85: Control structure",
          "Line 92: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 128: Control structure",
          "Line 138: Control structure",
          "Line 140: Control structure",
          "Line 148: Control structure",
          "Line 183: Control structure",
          "Line 184: Control structure",
          "Line 189: Control structure",
          "Line 232: Control structure",
          "Line 240: Control structure",
          "Line 243: Control structure",
          "Line 244: Control structure",
          "Line 247: Control structure",
          "Line 253: Control structure",
          "Line 255: Control structure",
          "Line 270: Control structure",
          "Line 273: Control structure",
          "Line 280: Control structure",
          "Line 296: Control structure",
          "Line 307: Control structure"
        ],
        "variable_usage": {
          "hooks_dir": [
            145,
            235,
            276
          ],
          "result": [
            296
          ],
          "pre_commit": [
            277
          ],
          "installed": [
            307
          ],
          "mut": [
            215
          ],
          "existing": [
            184
          ],
          "git_dir": [
            138,
            230,
            271
          ],
          "temp_dir": [
            295,
            306
          ],
          "hook_path": [
            180,
            240
          ],
          "content": [
            244,
            280
          ],
          "backup_path": [
            194,
            253
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 110: Error handling point",
          "Line 151: Error handling point",
          "Line 156: Error handling point",
          "Line 160: Error handling point",
          "Line 164: Error handling point",
          "Line 187: Error handling point",
          "Line 198: Error handling point",
          "Line 210: Error handling point",
          "Line 218: Error handling point",
          "Line 223: Error handling point",
          "Line 250: Error handling point",
          "Line 258: Error handling point",
          "Line 296: Error handling point",
          "Line 307: Error handling point",
          "Line 310: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/git_hooks.rs",
        "line": 229,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "install_git_hooks",
        "function_signature": "# [doc = \" Install git hooks in a project\"] pub async fn install_git_hooks (project_path : & Path) -> Result < () > { let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (Error :: validation (\"Not a git repository. Run 'git init' first.\" ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) . await . map_err (| e | Error :: process (format ! (\"Failed to create hooks directory: {}\" , e))) ? ; println ! (\"📝 Installing git hooks...\") ; install_hook (& hooks_dir , \"pre-commit\" , PRE_COMMIT_HOOK) . await ? ; println ! (\"  ✅ Installed pre-commit hook\") ; install_hook (& hooks_dir , \"pre-push\" , PRE_PUSH_HOOK) . await ? ; println ! (\"  ✅ Installed pre-push hook\") ; install_hook (& hooks_dir , \"commit-msg\" , COMMIT_MSG_HOOK) . await ? ; println ! (\"  ✅ Installed commit-msg hook\") ; println ! (\"🎉 Git hooks installed successfully!\") ; println ! () ; println ! (\"Hooks will now run automatically:\") ; println ! (\"  • pre-commit: Validates code before each commit\") ; println ! (\"  • pre-push: Runs tests and full validation before push\") ; println ! (\"  • commit-msg: Ensures conventional commit format\") ; println ! () ; println ! (\"To bypass hooks temporarily, use: git commit --no-verify\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    }",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Remove git hooks from a project",
          "pub async fn uninstall_git_hooks(project_path: &Path) -> Result<()> {",
          "    let git_dir = project_path.join(\".git\");",
          "    if !git_dir.exists() {",
          "        return Ok(()); // No git repo, nothing to uninstall",
          "    }"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 229: /// Remove git hooks from a project"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 19: Control structure",
          "Line 20: Control structure",
          "Line 29: Control structure",
          "Line 37: Control structure",
          "Line 46: Control structure",
          "Line 52: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 55: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 77: Control structure",
          "Line 85: Control structure",
          "Line 92: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 128: Control structure",
          "Line 138: Control structure",
          "Line 140: Control structure",
          "Line 148: Control structure",
          "Line 183: Control structure",
          "Line 184: Control structure",
          "Line 189: Control structure",
          "Line 232: Control structure",
          "Line 240: Control structure",
          "Line 243: Control structure",
          "Line 244: Control structure",
          "Line 247: Control structure",
          "Line 253: Control structure",
          "Line 255: Control structure",
          "Line 270: Control structure",
          "Line 273: Control structure",
          "Line 280: Control structure",
          "Line 296: Control structure",
          "Line 307: Control structure"
        ],
        "variable_usage": {
          "existing": [
            184
          ],
          "content": [
            244,
            280
          ],
          "git_dir": [
            138,
            230,
            271
          ],
          "hooks_dir": [
            145,
            235,
            276
          ],
          "mut": [
            215
          ],
          "backup_path": [
            194,
            253
          ],
          "pre_commit": [
            277
          ],
          "result": [
            296
          ],
          "hook_path": [
            180,
            240
          ],
          "temp_dir": [
            295,
            306
          ],
          "installed": [
            307
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 110: Error handling point",
          "Line 151: Error handling point",
          "Line 156: Error handling point",
          "Line 160: Error handling point",
          "Line 164: Error handling point",
          "Line 187: Error handling point",
          "Line 198: Error handling point",
          "Line 210: Error handling point",
          "Line 218: Error handling point",
          "Line 223: Error handling point",
          "Line 250: Error handling point",
          "Line 258: Error handling point",
          "Line 296: Error handling point",
          "Line 307: Error handling point",
          "Line 310: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/git_hooks.rs",
        "line": 270,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "install_git_hooks",
        "function_signature": "# [doc = \" Install git hooks in a project\"] pub async fn install_git_hooks (project_path : & Path) -> Result < () > { let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (Error :: validation (\"Not a git repository. Run 'git init' first.\" ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) . await . map_err (| e | Error :: process (format ! (\"Failed to create hooks directory: {}\" , e))) ? ; println ! (\"📝 Installing git hooks...\") ; install_hook (& hooks_dir , \"pre-commit\" , PRE_COMMIT_HOOK) . await ? ; println ! (\"  ✅ Installed pre-commit hook\") ; install_hook (& hooks_dir , \"pre-push\" , PRE_PUSH_HOOK) . await ? ; println ! (\"  ✅ Installed pre-push hook\") ; install_hook (& hooks_dir , \"commit-msg\" , COMMIT_MSG_HOOK) . await ? ; println ! (\"  ✅ Installed commit-msg hook\") ; println ! (\"🎉 Git hooks installed successfully!\") ; println ! () ; println ! (\"Hooks will now run automatically:\") ; println ! (\"  • pre-commit: Validates code before each commit\") ; println ! (\"  • pre-push: Runs tests and full validation before push\") ; println ! (\"  • commit-msg: Ensures conventional commit format\") ; println ! () ; println ! (\"To bypass hooks temporarily, use: git commit --no-verify\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    println!(\"✅ Git hooks removed\");",
          "",
          "    Ok(())",
          "}",
          "",
          "/// Check if git hooks are installed",
          "pub async fn check_hooks_installed(project_path: &Path) -> Result<bool> {",
          "    let git_dir = project_path.join(\".git\");",
          "    if !git_dir.exists() {",
          "        return Ok(false);",
          "    }"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 270: /// Check if git hooks are installed"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 19: Control structure",
          "Line 20: Control structure",
          "Line 29: Control structure",
          "Line 37: Control structure",
          "Line 46: Control structure",
          "Line 52: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 55: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 77: Control structure",
          "Line 85: Control structure",
          "Line 92: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 128: Control structure",
          "Line 138: Control structure",
          "Line 140: Control structure",
          "Line 148: Control structure",
          "Line 183: Control structure",
          "Line 184: Control structure",
          "Line 189: Control structure",
          "Line 232: Control structure",
          "Line 240: Control structure",
          "Line 243: Control structure",
          "Line 244: Control structure",
          "Line 247: Control structure",
          "Line 253: Control structure",
          "Line 255: Control structure",
          "Line 270: Control structure",
          "Line 273: Control structure",
          "Line 280: Control structure",
          "Line 296: Control structure",
          "Line 307: Control structure"
        ],
        "variable_usage": {
          "pre_commit": [
            277
          ],
          "existing": [
            184
          ],
          "hooks_dir": [
            145,
            235,
            276
          ],
          "git_dir": [
            138,
            230,
            271
          ],
          "hook_path": [
            180,
            240
          ],
          "installed": [
            307
          ],
          "temp_dir": [
            295,
            306
          ],
          "result": [
            296
          ],
          "backup_path": [
            194,
            253
          ],
          "mut": [
            215
          ],
          "content": [
            244,
            280
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 110: Error handling point",
          "Line 151: Error handling point",
          "Line 156: Error handling point",
          "Line 160: Error handling point",
          "Line 164: Error handling point",
          "Line 187: Error handling point",
          "Line 198: Error handling point",
          "Line 210: Error handling point",
          "Line 218: Error handling point",
          "Line 223: Error handling point",
          "Line 250: Error handling point",
          "Line 258: Error handling point",
          "Line 296: Error handling point",
          "Line 307: Error handling point",
          "Line 310: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/git_hooks.rs",
        "line": 306,
        "message": "BANNED: .expect() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "install_git_hooks",
        "function_signature": "# [doc = \" Install git hooks in a project\"] pub async fn install_git_hooks (project_path : & Path) -> Result < () > { let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (Error :: validation (\"Not a git repository. Run 'git init' first.\" ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) . await . map_err (| e | Error :: process (format ! (\"Failed to create hooks directory: {}\" , e))) ? ; println ! (\"📝 Installing git hooks...\") ; install_hook (& hooks_dir , \"pre-commit\" , PRE_COMMIT_HOOK) . await ? ; println ! (\"  ✅ Installed pre-commit hook\") ; install_hook (& hooks_dir , \"pre-push\" , PRE_PUSH_HOOK) . await ? ; println ! (\"  ✅ Installed pre-push hook\") ; install_hook (& hooks_dir , \"commit-msg\" , COMMIT_MSG_HOOK) . await ? ; println ! (\"  ✅ Installed commit-msg hook\") ; println ! (\"🎉 Git hooks installed successfully!\") ; println ! () ; println ! (\"Hooks will now run automatically:\") ; println ! (\"  • pre-commit: Validates code before each commit\") ; println ! (\"  • pre-push: Runs tests and full validation before push\") ; println ! (\"  • commit-msg: Ensures conventional commit format\") ; println ! () ; println ! (\"To bypass hooks temporarily, use: git commit --no-verify\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "            .to_string()",
          "            .contains(\"Not a git repository\"));",
          "    }",
          "",
          "    #[tokio::test]",
          "    async fn test_check_hooks_not_installed() {",
          "        let temp_dir = TempDir::new().expect(\"Failed to create temp dir for test\");",
          "        let installed = check_hooks_installed(temp_dir.path())",
          "            .await",
          "            .expect(\"Check should succeed\");",
          "        assert!(!installed);"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 306: async fn test_check_hooks_not_installed() {"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 19: Control structure",
          "Line 20: Control structure",
          "Line 29: Control structure",
          "Line 37: Control structure",
          "Line 46: Control structure",
          "Line 52: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 55: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 77: Control structure",
          "Line 85: Control structure",
          "Line 92: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 128: Control structure",
          "Line 138: Control structure",
          "Line 140: Control structure",
          "Line 148: Control structure",
          "Line 183: Control structure",
          "Line 184: Control structure",
          "Line 189: Control structure",
          "Line 232: Control structure",
          "Line 240: Control structure",
          "Line 243: Control structure",
          "Line 244: Control structure",
          "Line 247: Control structure",
          "Line 253: Control structure",
          "Line 255: Control structure",
          "Line 270: Control structure",
          "Line 273: Control structure",
          "Line 280: Control structure",
          "Line 296: Control structure",
          "Line 307: Control structure"
        ],
        "variable_usage": {
          "hooks_dir": [
            145,
            235,
            276
          ],
          "hook_path": [
            180,
            240
          ],
          "installed": [
            307
          ],
          "backup_path": [
            194,
            253
          ],
          "content": [
            244,
            280
          ],
          "mut": [
            215
          ],
          "pre_commit": [
            277
          ],
          "existing": [
            184
          ],
          "result": [
            296
          ],
          "temp_dir": [
            295,
            306
          ],
          "git_dir": [
            138,
            230,
            271
          ]
        },
        "function_calls": [
          "async fn test_check_hooks_not_installed"
        ],
        "error_propagation_path": [
          "Line 110: Error handling point",
          "Line 151: Error handling point",
          "Line 156: Error handling point",
          "Line 160: Error handling point",
          "Line 164: Error handling point",
          "Line 187: Error handling point",
          "Line 198: Error handling point",
          "Line 210: Error handling point",
          "Line 218: Error handling point",
          "Line 223: Error handling point",
          "Line 250: Error handling point",
          "Line 258: Error handling point",
          "Line 296: Error handling point",
          "Line 307: Error handling point",
          "Line 310: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "tokio",
        "async fn test_check_hooks_not_installed"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/git_hooks.rs",
        "line": 309,
        "message": "BANNED: .expect() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "install_git_hooks",
        "function_signature": "# [doc = \" Install git hooks in a project\"] pub async fn install_git_hooks (project_path : & Path) -> Result < () > { let git_dir = project_path . join (\".git\") ; if ! git_dir . exists () { return Err (Error :: validation (\"Not a git repository. Run 'git init' first.\" ,)) ; } let hooks_dir = git_dir . join (\"hooks\") ; fs :: create_dir_all (& hooks_dir) . await . map_err (| e | Error :: process (format ! (\"Failed to create hooks directory: {}\" , e))) ? ; println ! (\"📝 Installing git hooks...\") ; install_hook (& hooks_dir , \"pre-commit\" , PRE_COMMIT_HOOK) . await ? ; println ! (\"  ✅ Installed pre-commit hook\") ; install_hook (& hooks_dir , \"pre-push\" , PRE_PUSH_HOOK) . await ? ; println ! (\"  ✅ Installed pre-push hook\") ; install_hook (& hooks_dir , \"commit-msg\" , COMMIT_MSG_HOOK) . await ? ; println ! (\"  ✅ Installed commit-msg hook\") ; println ! (\"🎉 Git hooks installed successfully!\") ; println ! () ; println ! (\"Hooks will now run automatically:\") ; println ! (\"  • pre-commit: Validates code before each commit\") ; println ! (\"  • pre-push: Runs tests and full validation before push\") ; println ! (\"  • commit-msg: Ensures conventional commit format\") ; println ! () ; println ! (\"To bypass hooks temporarily, use: git commit --no-verify\") ; Ok (()) } . sig",
        "return_type": "Result < () >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "",
          "    #[tokio::test]",
          "    async fn test_check_hooks_not_installed() {",
          "        let temp_dir = TempDir::new().expect(\"Failed to create temp dir for test\");",
          "        let installed = check_hooks_installed(temp_dir.path())",
          "            .await",
          "            .expect(\"Check should succeed\");",
          "        assert!(!installed);",
          "    }",
          "}"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use std::path::Path;",
          "use tokio::fs;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 309: .await"
        ],
        "control_flow": [
          "Line 4: Control structure",
          "Line 19: Control structure",
          "Line 20: Control structure",
          "Line 29: Control structure",
          "Line 37: Control structure",
          "Line 46: Control structure",
          "Line 52: Control structure",
          "Line 53: Control structure",
          "Line 54: Control structure",
          "Line 55: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 77: Control structure",
          "Line 85: Control structure",
          "Line 92: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 128: Control structure",
          "Line 138: Control structure",
          "Line 140: Control structure",
          "Line 148: Control structure",
          "Line 183: Control structure",
          "Line 184: Control structure",
          "Line 189: Control structure",
          "Line 232: Control structure",
          "Line 240: Control structure",
          "Line 243: Control structure",
          "Line 244: Control structure",
          "Line 247: Control structure",
          "Line 253: Control structure",
          "Line 255: Control structure",
          "Line 270: Control structure",
          "Line 273: Control structure",
          "Line 280: Control structure",
          "Line 296: Control structure",
          "Line 307: Control structure"
        ],
        "variable_usage": {
          "content": [
            244,
            280
          ],
          "git_dir": [
            138,
            230,
            271
          ],
          "hooks_dir": [
            145,
            235,
            276
          ],
          "temp_dir": [
            295,
            306
          ],
          "mut": [
            215
          ],
          "hook_path": [
            180,
            240
          ],
          "pre_commit": [
            277
          ],
          "installed": [
            307
          ],
          "backup_path": [
            194,
            253
          ],
          "result": [
            296
          ],
          "existing": [
            184
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 110: Error handling point",
          "Line 151: Error handling point",
          "Line 156: Error handling point",
          "Line 160: Error handling point",
          "Line 164: Error handling point",
          "Line 187: Error handling point",
          "Line 198: Error handling point",
          "Line 210: Error handling point",
          "Line 218: Error handling point",
          "Line 223: Error handling point",
          "Line 250: Error handling point",
          "Line 258: Error handling point",
          "Line 296: Error handling point",
          "Line 307: Error handling point",
          "Line 310: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "tokio"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/rust_version/detector.rs",
        "line": 31,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_rust_version",
        "function_signature": "# [doc = \" Detect the currently installed Rust version\"] pub fn detect_rust_version () -> Result < RustVersion > { let rustc_path = which :: which (\"rustc\") . map_err (| _ | { Error :: rust_not_found (\"rustc not found. Please install Rust from https://rustup.rs\") }) ? ; let output = Command :: new (rustc_path) . arg (\"--version\") . output () . map_err (| e | Error :: command (format ! (\"Failed to run rustc: {}\" , e))) ? ; if ! output . status . success () { let stderr = String :: from_utf8_lossy (& output . stderr) ; return Err (Error :: command (format ! (\"rustc failed: {}\" , stderr))) ; } let stdout = str :: from_utf8 (& output . stdout) . map_err (| e | Error :: parse (format ! (\"Invalid UTF-8 in rustc output: {}\" , e))) ? ; RustVersion :: parse (stdout) } . sig",
        "return_type": "Result < RustVersion >",
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "    /// Raw version string from rustc",
          "    pub raw_string: String,",
          "}",
          "",
          "impl RustVersion {",
          "    /// Parse rustc version output",
          "    pub fn parse(version_output: &str) -> Result<Self> {",
          "        // Example: rustc 1.90.0 (4b06a43a1 2025-08-07)",
          "        let regex = Regex::new(",
          "            r\"rustc (\\d+\\.\\d+\\.\\d+(?:-[\\w.]+)?)\\s*\\(([a-f0-9]+)\\s+(\\d{4}-\\d{2}-\\d{2})\\)\",",
          "        )?;"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::NaiveDate;",
          "use regex::Regex;",
          "use semver::Version;",
          "use serde::{Deserialize, Serialize};",
          "use std::process::Command;",
          "use std::str;",
          "use super::Channel;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 31: /// Parse rustc version output"
        ],
        "control_flow": [
          "Line 62: Control structure",
          "Line 70: Control structure",
          "Line 81: Control structure",
          "Line 94: Control structure",
          "Line 96: Control structure",
          "Line 98: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 111: Control structure",
          "Line 131: Control structure",
          "Line 142: Control structure",
          "Line 148: Control structure",
          "Line 163: Control structure"
        ],
        "variable_usage": {
          "version": [
            42,
            184,
            195,
            206
          ],
          "commit_date": [
            44
          ],
          "regex": [
            33
          ],
          "channel": [
            47
          ],
          "rustc_path": [
            70
          ],
          "version_str": [
            41
          ],
          "commit_hash": [
            43
          ],
          "rustup_path": [
            122,
            154
          ],
          "Ok(host)": [
            110
          ],
          "host": [
            48
          ],
          "output": [
            75,
            125,
            157,
            183,
            194,
            205
          ],
          "Ok(output)": [
            108
          ],
          "stderr": [
            81,
            131,
            163
          ],
          "stdout": [
            85,
            135,
            167
          ],
          "captures": [
            37
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 35: Error handling point",
          "Line 36: Error handling point",
          "Line 40: Error handling point",
          "Line 43: Error handling point",
          "Line 46: Error handling point",
          "Line 73: Error handling point",
          "Line 79: Error handling point",
          "Line 87: Error handling point",
          "Line 124: Error handling point",
          "Line 129: Error handling point",
          "Line 136: Error handling point",
          "Line 156: Error handling point",
          "Line 161: Error handling point",
          "Line 168: Error handling point",
          "Line 185: Error handling point",
          "Line 196: Error handling point",
          "Line 207: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "chrono",
        "regex",
        "semver",
        "serde",
        "std",
        "std",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/rust_version/detector.rs",
        "line": 92,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "detect_rust_version",
        "function_signature": "# [doc = \" Detect the currently installed Rust version\"] pub fn detect_rust_version () -> Result < RustVersion > { let rustc_path = which :: which (\"rustc\") . map_err (| _ | { Error :: rust_not_found (\"rustc not found. Please install Rust from https://rustup.rs\") }) ? ; let output = Command :: new (rustc_path) . arg (\"--version\") . output () . map_err (| e | Error :: command (format ! (\"Failed to run rustc: {}\" , e))) ? ; if ! output . status . success () { let stderr = String :: from_utf8_lossy (& output . stderr) ; return Err (Error :: command (format ! (\"rustc failed: {}\" , stderr))) ; } let stdout = str :: from_utf8 (& output . stdout) . map_err (| e | Error :: parse (format ! (\"Invalid UTF-8 in rustc output: {}\" , e))) ? ; RustVersion :: parse (stdout) } . sig",
        "return_type": "Result < RustVersion >",
        "is_async": false,
        "is_generic": false,
        "trait_impl": "impl std::fmt::Display for RustVersion {",
        "surrounding_code": [
          "        .map_err(|e| Error::parse(format!(\"Invalid UTF-8 in rustc output: {}\", e)))?;",
          "",
          "    RustVersion::parse(stdout)",
          "}",
          "",
          "/// Detect the channel from version string",
          "fn detect_channel(version_str: &str) -> Channel {",
          "    if version_str.contains(\"nightly\") {",
          "        Channel::Nightly",
          "    } else if version_str.contains(\"beta\") {",
          "        Channel::Beta"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::NaiveDate;",
          "use regex::Regex;",
          "use semver::Version;",
          "use serde::{Deserialize, Serialize};",
          "use std::process::Command;",
          "use std::str;",
          "use super::Channel;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 92: /// Detect the channel from version string"
        ],
        "control_flow": [
          "Line 62: Control structure",
          "Line 70: Control structure",
          "Line 81: Control structure",
          "Line 94: Control structure",
          "Line 96: Control structure",
          "Line 98: Control structure",
          "Line 109: Control structure",
          "Line 110: Control structure",
          "Line 111: Control structure",
          "Line 131: Control structure",
          "Line 142: Control structure",
          "Line 148: Control structure",
          "Line 163: Control structure"
        ],
        "variable_usage": {
          "captures": [
            37
          ],
          "commit_date": [
            44
          ],
          "stdout": [
            85,
            135,
            167
          ],
          "rustc_path": [
            70
          ],
          "host": [
            48
          ],
          "Ok(host)": [
            110
          ],
          "version": [
            42,
            184,
            195,
            206
          ],
          "version_str": [
            41
          ],
          "output": [
            75,
            125,
            157,
            183,
            194,
            205
          ],
          "channel": [
            47
          ],
          "regex": [
            33
          ],
          "stderr": [
            81,
            131,
            163
          ],
          "commit_hash": [
            43
          ],
          "Ok(output)": [
            108
          ],
          "rustup_path": [
            122,
            154
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 35: Error handling point",
          "Line 36: Error handling point",
          "Line 40: Error handling point",
          "Line 43: Error handling point",
          "Line 46: Error handling point",
          "Line 73: Error handling point",
          "Line 79: Error handling point",
          "Line 87: Error handling point",
          "Line 124: Error handling point",
          "Line 129: Error handling point",
          "Line 136: Error handling point",
          "Line 156: Error handling point",
          "Line 161: Error handling point",
          "Line 168: Error handling point",
          "Line 185: Error handling point",
          "Line 196: Error handling point",
          "Line 207: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "chrono",
        "regex",
        "semver",
        "serde",
        "std",
        "std",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/rust_version/github.rs",
        "line": 60,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "default_version",
        "function_signature": "# [doc = \" Default version for deserialization\"] fn default_version () -> Version { Version :: new (0 , 0 , 0) } . sig",
        "return_type": "Version",
        "is_async": false,
        "is_generic": false,
        "trait_impl": "/// Simplified author information",
        "surrounding_code": [
          "    client: Client,",
          "    auth_token: Option<String>,",
          "}",
          "",
          "impl GitHubClient {",
          "    /// Create a new GitHub client",
          "    pub fn new(auth_token: Option<String>) -> Result<Self> {",
          "        let client = Client::builder()",
          "            .timeout(std::time::Duration::from_secs(30))",
          "            .user_agent(format!(\"ferrous-forge/{}\", env!(\"CARGO_PKG_VERSION\")))",
          "            .build()"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::{DateTime, Utc};",
          "use reqwest::Client;",
          "use semver::Version;",
          "use serde::{Deserialize, Serialize};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 60: /// Create a new GitHub client"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 13: Control structure",
          "Line 83: Control structure",
          "Line 92: Control structure",
          "Line 93: Control structure",
          "Line 104: Control structure",
          "Line 134: Control structure",
          "Line 143: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure"
        ],
        "variable_usage": {
          "release": [
            206
          ],
          "version_str": [
            176
          ],
          "url": [
            72,
            123
          ],
          "mut": [
            77,
            110,
            128,
            160
          ],
          "client": [
            61,
            189,
            205
          ],
          "Some(token)": [
            82,
            133
          ],
          "response": [
            86,
            137
          ],
          "retry_after": [
            93,
            143
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 29: Error handling point",
          "Line 31: Error handling point",
          "Line 66: Error handling point",
          "Line 90: Error handling point",
          "Line 114: Error handling point",
          "Line 117: Error handling point",
          "Line 125: Error handling point",
          "Line 141: Error handling point",
          "Line 164: Error handling point",
          "Line 168: Error handling point",
          "Line 190: Error handling point",
          "Line 193: Error handling point",
          "Line 198: Error handling point",
          "Line 206: Error handling point",
          "Line 207: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "chrono",
        "reqwest",
        "semver",
        "serde"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/rust_version/github.rs",
        "line": 206,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "default_version",
        "function_signature": "# [doc = \" Default version for deserialization\"] fn default_version () -> Version { Version :: new (0 , 0 , 0) } . sig",
        "return_type": "Version",
        "is_async": false,
        "is_generic": false,
        "trait_impl": "/// Simplified author information",
        "surrounding_code": [
          "    }",
          "",
          "    #[tokio::test]",
          "    #[ignore] // Requires network access",
          "    async fn test_get_latest_release() {",
          "        let client = GitHubClient::new(None)?;",
          "        let release = client.get_latest_release().await.unwrap();",
          "",
          "        assert!(!release.tag_name.is_empty());",
          "        assert!(release.version.major >= 1);",
          "    }"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::{DateTime, Utc};",
          "use reqwest::Client;",
          "use semver::Version;",
          "use serde::{Deserialize, Serialize};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 206: let client = GitHubClient::new(None)?;"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 13: Control structure",
          "Line 83: Control structure",
          "Line 92: Control structure",
          "Line 93: Control structure",
          "Line 104: Control structure",
          "Line 134: Control structure",
          "Line 143: Control structure",
          "Line 154: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure"
        ],
        "variable_usage": {
          "Some(token)": [
            82,
            133
          ],
          "retry_after": [
            93,
            143
          ],
          "url": [
            72,
            123
          ],
          "client": [
            61,
            189,
            205
          ],
          "mut": [
            77,
            110,
            128,
            160
          ],
          "response": [
            86,
            137
          ],
          "release": [
            206
          ],
          "version_str": [
            176
          ]
        },
        "function_calls": [
          "let client = GitHubClient::new"
        ],
        "error_propagation_path": [
          "Line 29: Error handling point",
          "Line 31: Error handling point",
          "Line 66: Error handling point",
          "Line 90: Error handling point",
          "Line 114: Error handling point",
          "Line 117: Error handling point",
          "Line 125: Error handling point",
          "Line 141: Error handling point",
          "Line 164: Error handling point",
          "Line 168: Error handling point",
          "Line 190: Error handling point",
          "Line 193: Error handling point",
          "Line 198: Error handling point",
          "Line 206: Error handling point",
          "Line 207: Error handling point"
        ]
      },
      "fix_complexity": "Complex",
      "dependencies": [
        "crate",
        "chrono",
        "reqwest",
        "semver",
        "serde",
        "let client = GitHubClient::new"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/bypass.rs",
        "line": 123,
        "message": "BANNED: Underscore assignment (let _ =) - handle errors properly",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "        let bypass: ActiveBypass = serde_json::from_str(&contents)",
          "            .map_err(|e| Error::parse(format!(\"Failed to parse bypass: {}\", e)))?;",
          "",
          "        // Check if bypass has expired",
          "        if Utc::now() > bypass.expires_at {",
          "            // Remove expired bypass",
          "            let _ = fs::remove_file(&bypass_path).await;",
          "            return Ok(None);",
          "        }",
          "",
          "        Ok(Some(bypass))"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::{DateTime, Utc};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::PathBuf;",
          "use tokio::fs;",
          "use super::{config::BypassConfig, PipelineStage};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 123: // Remove expired bypass"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 11: Control structure",
          "Line 21: Control structure",
          "Line 36: Control structure",
          "Line 54: Control structure",
          "Line 67: Control structure",
          "Line 71: Control structure",
          "Line 76: Control structure",
          "Line 78: Control structure",
          "Line 98: Control structure",
          "Line 105: Control structure",
          "Line 107: Control structure",
          "Line 113: Control structure",
          "Line 121: Control structure",
          "Line 122: Control structure",
          "Line 135: Control structure",
          "Line 146: Control structure",
          "Line 163: Control structure",
          "Line 180: Control structure",
          "Line 196: Control structure",
          "Line 212: Control structure",
          "Line 226: Control structure",
          "Line 234: Control structure"
        ],
        "variable_usage": {
          "bypass": [
            85,
            117,
            271
          ],
          "log_path": [
            143,
            193
          ],
          "today_count": [
            76
          ],
          "contents": [
            116,
            149,
            183
          ],
          "mut": [
            150,
            211
          ],
          "Some(parent)": [
            179,
            195
          ],
          "config": [
            247,
            261
          ],
          "_": [
            123
          ],
          "config_dir": [
            227,
            235
          ],
          "log": [
            165
          ],
          "today": [
            164
          ],
          "bypass_path": [
            110,
            132,
            177
          ],
          "log_line": [
            207
          ],
          "count": [
            167
          ],
          "manager": [
            255,
            269
          ],
          "entry": [
            199
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 77: Error handling point",
          "Line 95: Error handling point",
          "Line 99: Error handling point",
          "Line 111: Error handling point",
          "Line 117: Error handling point",
          "Line 119: Error handling point",
          "Line 133: Error handling point",
          "Line 136: Error handling point",
          "Line 144: Error handling point",
          "Line 150: Error handling point",
          "Line 166: Error handling point",
          "Line 178: Error handling point",
          "Line 181: Error handling point",
          "Line 185: Error handling point",
          "Line 187: Error handling point",
          "Line 194: Error handling point",
          "Line 197: Error handling point",
          "Line 209: Error handling point",
          "Line 213: Error handling point",
          "Line 221: Error handling point",
          "Line 228: Error handling point",
          "Line 236: Error handling point",
          "Line 256: Error handling point",
          "Line 270: Error handling point",
          "Line 280: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "chrono",
        "serde",
        "std",
        "tokio",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/bypass.rs",
        "line": 255,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "            require_reason: true,",
          "            require_confirmation: true,",
          "            log_bypasses: true,",
          "            max_bypasses_per_day: 3,",
          "        };",
          "",
          "        let manager = BypassManager::new(&config).unwrap();",
          "        assert!(manager.is_enabled());",
          "    }",
          "",
          "    #[tokio::test]"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::{DateTime, Utc};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::PathBuf;",
          "use tokio::fs;",
          "use super::{config::BypassConfig, PipelineStage};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 255: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 11: Control structure",
          "Line 21: Control structure",
          "Line 36: Control structure",
          "Line 54: Control structure",
          "Line 67: Control structure",
          "Line 71: Control structure",
          "Line 76: Control structure",
          "Line 78: Control structure",
          "Line 98: Control structure",
          "Line 105: Control structure",
          "Line 107: Control structure",
          "Line 113: Control structure",
          "Line 121: Control structure",
          "Line 122: Control structure",
          "Line 135: Control structure",
          "Line 146: Control structure",
          "Line 163: Control structure",
          "Line 180: Control structure",
          "Line 196: Control structure",
          "Line 212: Control structure",
          "Line 226: Control structure",
          "Line 234: Control structure"
        ],
        "variable_usage": {
          "contents": [
            116,
            149,
            183
          ],
          "log": [
            165
          ],
          "log_path": [
            143,
            193
          ],
          "config": [
            247,
            261
          ],
          "manager": [
            255,
            269
          ],
          "bypass_path": [
            110,
            132,
            177
          ],
          "today": [
            164
          ],
          "_": [
            123
          ],
          "Some(parent)": [
            179,
            195
          ],
          "mut": [
            150,
            211
          ],
          "count": [
            167
          ],
          "config_dir": [
            227,
            235
          ],
          "bypass": [
            85,
            117,
            271
          ],
          "entry": [
            199
          ],
          "today_count": [
            76
          ],
          "log_line": [
            207
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 77: Error handling point",
          "Line 95: Error handling point",
          "Line 99: Error handling point",
          "Line 111: Error handling point",
          "Line 117: Error handling point",
          "Line 119: Error handling point",
          "Line 133: Error handling point",
          "Line 136: Error handling point",
          "Line 144: Error handling point",
          "Line 150: Error handling point",
          "Line 166: Error handling point",
          "Line 178: Error handling point",
          "Line 181: Error handling point",
          "Line 185: Error handling point",
          "Line 187: Error handling point",
          "Line 194: Error handling point",
          "Line 197: Error handling point",
          "Line 209: Error handling point",
          "Line 213: Error handling point",
          "Line 221: Error handling point",
          "Line 228: Error handling point",
          "Line 236: Error handling point",
          "Line 256: Error handling point",
          "Line 270: Error handling point",
          "Line 280: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "chrono",
        "serde",
        "std",
        "tokio",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/bypass.rs",
        "line": 269,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "            require_reason: true,",
          "            require_confirmation: false,",
          "            log_bypasses: false,",
          "            max_bypasses_per_day: 0, // No limit",
          "        };",
          "",
          "        let manager = BypassManager::new(&config).unwrap();",
          "",
          "        let bypass = manager",
          "            .create_bypass(",
          "                PipelineStage::PreCommit,"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::{DateTime, Utc};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::PathBuf;",
          "use tokio::fs;",
          "use super::{config::BypassConfig, PipelineStage};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 269: "
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 11: Control structure",
          "Line 21: Control structure",
          "Line 36: Control structure",
          "Line 54: Control structure",
          "Line 67: Control structure",
          "Line 71: Control structure",
          "Line 76: Control structure",
          "Line 78: Control structure",
          "Line 98: Control structure",
          "Line 105: Control structure",
          "Line 107: Control structure",
          "Line 113: Control structure",
          "Line 121: Control structure",
          "Line 122: Control structure",
          "Line 135: Control structure",
          "Line 146: Control structure",
          "Line 163: Control structure",
          "Line 180: Control structure",
          "Line 196: Control structure",
          "Line 212: Control structure",
          "Line 226: Control structure",
          "Line 234: Control structure"
        ],
        "variable_usage": {
          "_": [
            123
          ],
          "manager": [
            255,
            269
          ],
          "today": [
            164
          ],
          "bypass": [
            85,
            117,
            271
          ],
          "log_path": [
            143,
            193
          ],
          "log": [
            165
          ],
          "today_count": [
            76
          ],
          "config": [
            247,
            261
          ],
          "bypass_path": [
            110,
            132,
            177
          ],
          "Some(parent)": [
            179,
            195
          ],
          "config_dir": [
            227,
            235
          ],
          "contents": [
            116,
            149,
            183
          ],
          "mut": [
            150,
            211
          ],
          "log_line": [
            207
          ],
          "count": [
            167
          ],
          "entry": [
            199
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 77: Error handling point",
          "Line 95: Error handling point",
          "Line 99: Error handling point",
          "Line 111: Error handling point",
          "Line 117: Error handling point",
          "Line 119: Error handling point",
          "Line 133: Error handling point",
          "Line 136: Error handling point",
          "Line 144: Error handling point",
          "Line 150: Error handling point",
          "Line 166: Error handling point",
          "Line 178: Error handling point",
          "Line 181: Error handling point",
          "Line 185: Error handling point",
          "Line 187: Error handling point",
          "Line 194: Error handling point",
          "Line 197: Error handling point",
          "Line 209: Error handling point",
          "Line 213: Error handling point",
          "Line 221: Error handling point",
          "Line 228: Error handling point",
          "Line 236: Error handling point",
          "Line 256: Error handling point",
          "Line 270: Error handling point",
          "Line 280: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "chrono",
        "serde",
        "std",
        "tokio",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/bypass.rs",
        "line": 279,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "                PipelineStage::PreCommit,",
          "                \"test reason\".to_string(),",
          "                \"test_user\".to_string(),",
          "                1, // 1 hour",
          "            )",
          "            .await",
          "            .unwrap();",
          "",
          "        assert_eq!(bypass.stage, PipelineStage::PreCommit);",
          "        assert_eq!(bypass.reason, \"test reason\");",
          "        assert_eq!(bypass.user, \"test_user\");"
        ],
        "imports": [
          "use crate::{Error, Result};",
          "use chrono::{DateTime, Utc};",
          "use serde::{Deserialize, Serialize};",
          "use std::path::PathBuf;",
          "use tokio::fs;",
          "use super::{config::BypassConfig, PipelineStage};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 279: .await"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 11: Control structure",
          "Line 21: Control structure",
          "Line 36: Control structure",
          "Line 54: Control structure",
          "Line 67: Control structure",
          "Line 71: Control structure",
          "Line 76: Control structure",
          "Line 78: Control structure",
          "Line 98: Control structure",
          "Line 105: Control structure",
          "Line 107: Control structure",
          "Line 113: Control structure",
          "Line 121: Control structure",
          "Line 122: Control structure",
          "Line 135: Control structure",
          "Line 146: Control structure",
          "Line 163: Control structure",
          "Line 180: Control structure",
          "Line 196: Control structure",
          "Line 212: Control structure",
          "Line 226: Control structure",
          "Line 234: Control structure"
        ],
        "variable_usage": {
          "log": [
            165
          ],
          "count": [
            167
          ],
          "config": [
            247,
            261
          ],
          "today_count": [
            76
          ],
          "bypass_path": [
            110,
            132,
            177
          ],
          "today": [
            164
          ],
          "log_line": [
            207
          ],
          "entry": [
            199
          ],
          "_": [
            123
          ],
          "mut": [
            150,
            211
          ],
          "bypass": [
            85,
            117,
            271
          ],
          "manager": [
            255,
            269
          ],
          "contents": [
            116,
            149,
            183
          ],
          "log_path": [
            143,
            193
          ],
          "Some(parent)": [
            179,
            195
          ],
          "config_dir": [
            227,
            235
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 77: Error handling point",
          "Line 95: Error handling point",
          "Line 99: Error handling point",
          "Line 111: Error handling point",
          "Line 117: Error handling point",
          "Line 119: Error handling point",
          "Line 133: Error handling point",
          "Line 136: Error handling point",
          "Line 144: Error handling point",
          "Line 150: Error handling point",
          "Line 166: Error handling point",
          "Line 178: Error handling point",
          "Line 181: Error handling point",
          "Line 185: Error handling point",
          "Line 187: Error handling point",
          "Line 194: Error handling point",
          "Line 197: Error handling point",
          "Line 209: Error handling point",
          "Line 213: Error handling point",
          "Line 221: Error handling point",
          "Line 228: Error handling point",
          "Line 236: Error handling point",
          "Line 256: Error handling point",
          "Line 270: Error handling point",
          "Line 280: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "chrono",
        "serde",
        "std",
        "tokio",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/audit.rs",
        "line": 14,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo audit\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Audit) ; let audit_check = Command :: new (\"cargo\") . args (& [\"audit\" , \"--version\"]) . output () ; if audit_check . as_ref () . map_or (true , | output | ! output . status . success ()) { result . add_error (\"cargo-audit not available\") ; result . add_suggestion (\"Install with: cargo install cargo-audit\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"audit\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Security vulnerabilities found\") ; result . add_suggestion (\"Update vulnerable dependencies\") ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut vuln_count = 0 ; for line in stdout . lines () . chain (stderr . lines ()) { if line . contains (\"vulnerability\") || line . contains (\"RUSTSEC\") { if vuln_count < 3 { result . add_error (format ! (\"Security: {}\" , line . trim ())) ; vuln_count += 1 ; } } else if line . contains (\"Crate:\") || line . contains (\"Version:\") { result . add_context (line . trim () . to_string ()) ; } } if vuln_count >= 3 { result . add_error (\"... and more vulnerabilities (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo audit fix' to attempt automatic fixes\") ; result . add_suggestion (\"Check https://rustsec.org for vulnerability details\") ; } else { result . add_context (\"No security vulnerabilities found\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// Audit check implementation",
          "pub struct AuditCheck;",
          "",
          "impl SafetyCheck for AuditCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 14: impl SafetyCheck for AuditCheck {"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 24: Control structure",
          "Line 33: Control structure",
          "Line 36: Control structure",
          "Line 54: Control structure",
          "Line 64: Control structure",
          "Line 65: Control structure",
          "Line 66: Control structure",
          "Line 70: Control structure",
          "Line 75: Control structure",
          "Line 80: Control structure"
        ],
        "variable_usage": {
          "start": [
            29
          ],
          "audit_check": [
            33
          ],
          "mut": [
            30,
            61
          ],
          "stdout": [
            58
          ],
          "stderr": [
            59
          ],
          "output": [
            46
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 50: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/audit.rs",
        "line": 28,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo audit\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Audit) ; let audit_check = Command :: new (\"cargo\") . args (& [\"audit\" , \"--version\"]) . output () ; if audit_check . as_ref () . map_or (true , | output | ! output . status . success ()) { result . add_error (\"cargo-audit not available\") ; result . add_suggestion (\"Install with: cargo install cargo-audit\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"audit\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Security vulnerabilities found\") ; result . add_suggestion (\"Update vulnerable dependencies\") ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut vuln_count = 0 ; for line in stdout . lines () . chain (stderr . lines ()) { if line . contains (\"vulnerability\") || line . contains (\"RUSTSEC\") { if vuln_count < 3 { result . add_error (format ! (\"Security: {}\" , line . trim ())) ; vuln_count += 1 ; } } else if line . contains (\"Crate:\") || line . contains (\"Version:\") { result . add_context (line . trim () . to_string ()) ; } } if vuln_count >= 3 { result . add_error (\"... and more vulnerabilities (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo audit fix' to attempt automatic fixes\") ; result . add_suggestion (\"Check https://rustsec.org for vulnerability details\") ; } else { result . add_context (\"No security vulnerabilities found\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for AuditCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Scans for security vulnerabilities in dependencies\"",
          "    }",
          "}",
          "",
          "/// Run cargo audit",
          "pub async fn run(project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::Audit);",
          "",
          "    // Check if cargo-audit is available"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 28: /// Run cargo audit"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 24: Control structure",
          "Line 33: Control structure",
          "Line 36: Control structure",
          "Line 54: Control structure",
          "Line 64: Control structure",
          "Line 65: Control structure",
          "Line 66: Control structure",
          "Line 70: Control structure",
          "Line 75: Control structure",
          "Line 80: Control structure"
        ],
        "variable_usage": {
          "start": [
            29
          ],
          "stdout": [
            58
          ],
          "stderr": [
            59
          ],
          "audit_check": [
            33
          ],
          "output": [
            46
          ],
          "mut": [
            30,
            61
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 50: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/build.rs",
        "line": 14,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo build --release\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Build) ; let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"build\" , \"--release\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Build failed\") ; result . add_suggestion (\"Fix compilation errors before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; for line in stderr . lines () { if line . starts_with (\"error\") && error_count < 3 { result . add_error (format ! (\"Build: {}\" , line . trim ())) ; error_count += 1 ; } else if line . trim () . starts_with (\"-->\") && error_count <= 3 { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; } } if error_count >= 3 { result . add_error (\"... and more build errors (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo build' to see detailed error messages\") ; result . add_suggestion (\"Check for missing dependencies or syntax errors\") ; } else { result . add_context (\"Project builds successfully in release mode\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let warning_count = stderr . lines () . filter (| line | line . starts_with (\"warning:\")) . count () ; if warning_count > 0 { result . add_context (format ! (\"Build completed with {} warnings\" , warning_count)) ; } } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// Build check implementation",
          "pub struct BuildCheck;",
          "",
          "impl SafetyCheck for BuildCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 14: impl SafetyCheck for BuildCheck {"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 41: Control structure",
          "Line 49: Control structure",
          "Line 50: Control structure",
          "Line 53: Control structure",
          "Line 58: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 74: Control structure",
          "Line 120: Control structure"
        ],
        "variable_usage": {
          "temp_dir": [
            90
          ],
          "main_rs": [
            109
          ],
          "output": [
            33
          ],
          "result": [
            117
          ],
          "warning_count": [
            68
          ],
          "stderr": [
            45,
            67
          ],
          "cargo_toml": [
            93
          ],
          "start": [
            29
          ],
          "mut": [
            30,
            46
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 37: Error handling point",
          "Line 91: Error handling point",
          "Line 102: Error handling point",
          "Line 107: Error handling point",
          "Line 116: Error handling point",
          "Line 118: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/build.rs",
        "line": 28,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo build --release\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Build) ; let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"build\" , \"--release\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Build failed\") ; result . add_suggestion (\"Fix compilation errors before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; for line in stderr . lines () { if line . starts_with (\"error\") && error_count < 3 { result . add_error (format ! (\"Build: {}\" , line . trim ())) ; error_count += 1 ; } else if line . trim () . starts_with (\"-->\") && error_count <= 3 { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; } } if error_count >= 3 { result . add_error (\"... and more build errors (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo build' to see detailed error messages\") ; result . add_suggestion (\"Check for missing dependencies or syntax errors\") ; } else { result . add_context (\"Project builds successfully in release mode\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let warning_count = stderr . lines () . filter (| line | line . starts_with (\"warning:\")) . count () ; if warning_count > 0 { result . add_context (format ! (\"Build completed with {} warnings\" , warning_count)) ; } } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for BuildCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Ensures project builds successfully in release mode\"",
          "    }",
          "}",
          "",
          "/// Run cargo build --release",
          "pub async fn run(project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::Build);",
          "",
          "    // Run cargo build --release"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 28: /// Run cargo build --release"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 41: Control structure",
          "Line 49: Control structure",
          "Line 50: Control structure",
          "Line 53: Control structure",
          "Line 58: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 74: Control structure",
          "Line 120: Control structure"
        ],
        "variable_usage": {
          "warning_count": [
            68
          ],
          "output": [
            33
          ],
          "stderr": [
            45,
            67
          ],
          "start": [
            29
          ],
          "cargo_toml": [
            93
          ],
          "mut": [
            30,
            46
          ],
          "main_rs": [
            109
          ],
          "temp_dir": [
            90
          ],
          "result": [
            117
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 37: Error handling point",
          "Line 91: Error handling point",
          "Line 102: Error handling point",
          "Line 107: Error handling point",
          "Line 116: Error handling point",
          "Line 118: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/build.rs",
        "line": 115,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo build --release\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Build) ; let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"build\" , \"--release\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Build failed\") ; result . add_suggestion (\"Fix compilation errors before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; for line in stderr . lines () { if line . starts_with (\"error\") && error_count < 3 { result . add_error (format ! (\"Build: {}\" , line . trim ())) ; error_count += 1 ; } else if line . trim () . starts_with (\"-->\") && error_count <= 3 { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; } } if error_count >= 3 { result . add_error (\"... and more build errors (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo build' to see detailed error messages\") ; result . add_suggestion (\"Check for missing dependencies or syntax errors\") ; } else { result . add_context (\"Project builds successfully in release mode\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let warning_count = stderr . lines () . filter (| line | line . starts_with (\"warning:\")) . count () ; if warning_count > 0 { result . add_context (format ! (\"Build completed with {} warnings\" , warning_count)) ; } } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for BuildCheck {",
        "surrounding_code": [
          "        let main_rs = r#\"fn main() {",
          "    println!(\"Hello, world!\");",
          "}",
          "\"#;",
          "        fs::write(temp_dir.path().join(\"src/main.rs\"), main_rs)",
          "            .await",
          "            .unwrap();",
          "",
          "        let result = run(temp_dir.path()).await.unwrap();",
          "",
          "        // Should pass for valid code"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 115: .await"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 41: Control structure",
          "Line 49: Control structure",
          "Line 50: Control structure",
          "Line 53: Control structure",
          "Line 58: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 74: Control structure",
          "Line 120: Control structure"
        ],
        "variable_usage": {
          "start": [
            29
          ],
          "output": [
            33
          ],
          "result": [
            117
          ],
          "mut": [
            30,
            46
          ],
          "main_rs": [
            109
          ],
          "stderr": [
            45,
            67
          ],
          "warning_count": [
            68
          ],
          "temp_dir": [
            90
          ],
          "cargo_toml": [
            93
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 37: Error handling point",
          "Line 91: Error handling point",
          "Line 102: Error handling point",
          "Line 107: Error handling point",
          "Line 116: Error handling point",
          "Line 118: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/build.rs",
        "line": 117,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo build --release\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Build) ; let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"build\" , \"--release\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Build failed\") ; result . add_suggestion (\"Fix compilation errors before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; for line in stderr . lines () { if line . starts_with (\"error\") && error_count < 3 { result . add_error (format ! (\"Build: {}\" , line . trim ())) ; error_count += 1 ; } else if line . trim () . starts_with (\"-->\") && error_count <= 3 { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; } } if error_count >= 3 { result . add_error (\"... and more build errors (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo build' to see detailed error messages\") ; result . add_suggestion (\"Check for missing dependencies or syntax errors\") ; } else { result . add_context (\"Project builds successfully in release mode\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let warning_count = stderr . lines () . filter (| line | line . starts_with (\"warning:\")) . count () ; if warning_count > 0 { result . add_context (format ! (\"Build completed with {} warnings\" , warning_count)) ; } } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for BuildCheck {",
        "surrounding_code": [
          "}",
          "\"#;",
          "        fs::write(temp_dir.path().join(\"src/main.rs\"), main_rs)",
          "            .await",
          "            .unwrap();",
          "",
          "        let result = run(temp_dir.path()).await.unwrap();",
          "",
          "        // Should pass for valid code",
          "        assert!(result.passed);",
          "    }"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 117: "
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 41: Control structure",
          "Line 49: Control structure",
          "Line 50: Control structure",
          "Line 53: Control structure",
          "Line 58: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 74: Control structure",
          "Line 120: Control structure"
        ],
        "variable_usage": {
          "output": [
            33
          ],
          "main_rs": [
            109
          ],
          "mut": [
            30,
            46
          ],
          "warning_count": [
            68
          ],
          "start": [
            29
          ],
          "stderr": [
            45,
            67
          ],
          "temp_dir": [
            90
          ],
          "cargo_toml": [
            93
          ],
          "result": [
            117
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 37: Error handling point",
          "Line 91: Error handling point",
          "Line 102: Error handling point",
          "Line 107: Error handling point",
          "Line 116: Error handling point",
          "Line 118: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/clippy.rs",
        "line": 14,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo clippy with strict warnings\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Clippy) ; let clippy_check = Command :: new (\"cargo\") . args (& [\"clippy\" , \"--version\"]) . output () ; if clippy_check . as_ref () . map_or (true , | output | ! output . status . success ()) { result . add_error (\"clippy not available\") ; result . add_suggestion (\"Install clippy with: rustup component add clippy\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"clippy\" , \"--all-targets\" , \"--all-features\" , \"--\" , \"-D\" , \"warnings\" ,]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Clippy lints found\") ; result . add_suggestion (\"Fix clippy warnings before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; let mut in_error = false ; for line in stderr . lines () { if (line . starts_with (\"error:\") || line . starts_with (\"warning:\")) && error_count < 5 { result . add_error (format ! (\"Clippy: {}\" , line . trim ())) ; error_count += 1 ; in_error = true ; } else if in_error && line . trim () . starts_with (\"-->\") { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; in_error = false ; } else if line . contains (\"help:\") && ! line . trim () . is_empty () { result . add_suggestion (line . trim () . strip_prefix (\"help: \") . unwrap_or (line . trim ()) . to_string () ,) ; } } if error_count >= 5 { result . add_error (\"... and more clippy issues (showing first 5)\") ; result . add_suggestion (\"Fix the issues above first, then run again\") ; } result . add_suggestion (\"Run 'cargo clippy --fix' to auto-fix some issues\") ; result . add_suggestion (\"Check https://rust-lang.github.io/rust-clippy/ for lint explanations\") ; } else { result . add_context (\"All clippy lints passed\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// Clippy check implementation",
          "pub struct ClippyCheck;",
          "",
          "impl SafetyCheck for ClippyCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 14: impl SafetyCheck for ClippyCheck {"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 38: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 73: Control structure",
          "Line 77: Control structure",
          "Line 81: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 145: Control structure",
          "Line 146: Control structure"
        ],
        "variable_usage": {
          "cargo_toml": [
            118
          ],
          "temp_dir": [
            115
          ],
          "mut": [
            30,
            68,
            69
          ],
          "start": [
            29
          ],
          "stderr": [
            67
          ],
          "output": [
            48
          ],
          "clippy_check": [
            33
          ],
          "main_rs": [
            134
          ],
          "_result": [
            142
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 59: Error handling point",
          "Line 116: Error handling point",
          "Line 127: Error handling point",
          "Line 132: Error handling point",
          "Line 141: Error handling point",
          "Line 143: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/clippy.rs",
        "line": 28,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo clippy with strict warnings\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Clippy) ; let clippy_check = Command :: new (\"cargo\") . args (& [\"clippy\" , \"--version\"]) . output () ; if clippy_check . as_ref () . map_or (true , | output | ! output . status . success ()) { result . add_error (\"clippy not available\") ; result . add_suggestion (\"Install clippy with: rustup component add clippy\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"clippy\" , \"--all-targets\" , \"--all-features\" , \"--\" , \"-D\" , \"warnings\" ,]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Clippy lints found\") ; result . add_suggestion (\"Fix clippy warnings before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; let mut in_error = false ; for line in stderr . lines () { if (line . starts_with (\"error:\") || line . starts_with (\"warning:\")) && error_count < 5 { result . add_error (format ! (\"Clippy: {}\" , line . trim ())) ; error_count += 1 ; in_error = true ; } else if in_error && line . trim () . starts_with (\"-->\") { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; in_error = false ; } else if line . contains (\"help:\") && ! line . trim () . is_empty () { result . add_suggestion (line . trim () . strip_prefix (\"help: \") . unwrap_or (line . trim ()) . to_string () ,) ; } } if error_count >= 5 { result . add_error (\"... and more clippy issues (showing first 5)\") ; result . add_suggestion (\"Fix the issues above first, then run again\") ; } result . add_suggestion (\"Run 'cargo clippy --fix' to auto-fix some issues\") ; result . add_suggestion (\"Check https://rust-lang.github.io/rust-clippy/ for lint explanations\") ; } else { result . add_context (\"All clippy lints passed\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for ClippyCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Runs clippy lints with strict warnings\"",
          "    }",
          "}",
          "",
          "/// Run cargo clippy with strict warnings",
          "pub async fn run(project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::Clippy);",
          "",
          "    // Check if clippy is available"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 28: /// Run cargo clippy with strict warnings"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 38: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 73: Control structure",
          "Line 77: Control structure",
          "Line 81: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 145: Control structure",
          "Line 146: Control structure"
        ],
        "variable_usage": {
          "mut": [
            30,
            68,
            69
          ],
          "stderr": [
            67
          ],
          "output": [
            48
          ],
          "temp_dir": [
            115
          ],
          "clippy_check": [
            33
          ],
          "_result": [
            142
          ],
          "cargo_toml": [
            118
          ],
          "start": [
            29
          ],
          "main_rs": [
            134
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 59: Error handling point",
          "Line 116: Error handling point",
          "Line 127: Error handling point",
          "Line 132: Error handling point",
          "Line 141: Error handling point",
          "Line 143: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/clippy.rs",
        "line": 140,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo clippy with strict warnings\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Clippy) ; let clippy_check = Command :: new (\"cargo\") . args (& [\"clippy\" , \"--version\"]) . output () ; if clippy_check . as_ref () . map_or (true , | output | ! output . status . success ()) { result . add_error (\"clippy not available\") ; result . add_suggestion (\"Install clippy with: rustup component add clippy\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"clippy\" , \"--all-targets\" , \"--all-features\" , \"--\" , \"-D\" , \"warnings\" ,]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Clippy lints found\") ; result . add_suggestion (\"Fix clippy warnings before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; let mut in_error = false ; for line in stderr . lines () { if (line . starts_with (\"error:\") || line . starts_with (\"warning:\")) && error_count < 5 { result . add_error (format ! (\"Clippy: {}\" , line . trim ())) ; error_count += 1 ; in_error = true ; } else if in_error && line . trim () . starts_with (\"-->\") { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; in_error = false ; } else if line . contains (\"help:\") && ! line . trim () . is_empty () { result . add_suggestion (line . trim () . strip_prefix (\"help: \") . unwrap_or (line . trim ()) . to_string () ,) ; } } if error_count >= 5 { result . add_error (\"... and more clippy issues (showing first 5)\") ; result . add_suggestion (\"Fix the issues above first, then run again\") ; } result . add_suggestion (\"Run 'cargo clippy --fix' to auto-fix some issues\") ; result . add_suggestion (\"Check https://rust-lang.github.io/rust-clippy/ for lint explanations\") ; } else { result . add_context (\"All clippy lints passed\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for ClippyCheck {",
        "surrounding_code": [
          "        let main_rs = r#\"fn main() {",
          "    println!(\"Hello, world!\");",
          "}",
          "\"#;",
          "        fs::write(temp_dir.path().join(\"src/main.rs\"), main_rs)",
          "            .await",
          "            .unwrap();",
          "",
          "        let _result = run(temp_dir.path()).await.unwrap();",
          "",
          "        // Should pass for clean code (assuming clippy is available)"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 140: .await"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 38: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 73: Control structure",
          "Line 77: Control structure",
          "Line 81: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 145: Control structure",
          "Line 146: Control structure"
        ],
        "variable_usage": {
          "cargo_toml": [
            118
          ],
          "stderr": [
            67
          ],
          "mut": [
            30,
            68,
            69
          ],
          "main_rs": [
            134
          ],
          "_result": [
            142
          ],
          "start": [
            29
          ],
          "temp_dir": [
            115
          ],
          "clippy_check": [
            33
          ],
          "output": [
            48
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 59: Error handling point",
          "Line 116: Error handling point",
          "Line 127: Error handling point",
          "Line 132: Error handling point",
          "Line 141: Error handling point",
          "Line 143: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/clippy.rs",
        "line": 142,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo clippy with strict warnings\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Clippy) ; let clippy_check = Command :: new (\"cargo\") . args (& [\"clippy\" , \"--version\"]) . output () ; if clippy_check . as_ref () . map_or (true , | output | ! output . status . success ()) { result . add_error (\"clippy not available\") ; result . add_suggestion (\"Install clippy with: rustup component add clippy\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"clippy\" , \"--all-targets\" , \"--all-features\" , \"--\" , \"-D\" , \"warnings\" ,]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Clippy lints found\") ; result . add_suggestion (\"Fix clippy warnings before proceeding\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; let mut in_error = false ; for line in stderr . lines () { if (line . starts_with (\"error:\") || line . starts_with (\"warning:\")) && error_count < 5 { result . add_error (format ! (\"Clippy: {}\" , line . trim ())) ; error_count += 1 ; in_error = true ; } else if in_error && line . trim () . starts_with (\"-->\") { result . add_context (format ! (\"Location: {}\" , line . trim ())) ; in_error = false ; } else if line . contains (\"help:\") && ! line . trim () . is_empty () { result . add_suggestion (line . trim () . strip_prefix (\"help: \") . unwrap_or (line . trim ()) . to_string () ,) ; } } if error_count >= 5 { result . add_error (\"... and more clippy issues (showing first 5)\") ; result . add_suggestion (\"Fix the issues above first, then run again\") ; } result . add_suggestion (\"Run 'cargo clippy --fix' to auto-fix some issues\") ; result . add_suggestion (\"Check https://rust-lang.github.io/rust-clippy/ for lint explanations\") ; } else { result . add_context (\"All clippy lints passed\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for ClippyCheck {",
        "surrounding_code": [
          "}",
          "\"#;",
          "        fs::write(temp_dir.path().join(\"src/main.rs\"), main_rs)",
          "            .await",
          "            .unwrap();",
          "",
          "        let _result = run(temp_dir.path()).await.unwrap();",
          "",
          "        // Should pass for clean code (assuming clippy is available)",
          "        // Note: This might fail in CI if clippy isn't available",
          "    }"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 142: "
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 38: Control structure",
          "Line 63: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 73: Control structure",
          "Line 77: Control structure",
          "Line 81: Control structure",
          "Line 91: Control structure",
          "Line 99: Control structure",
          "Line 145: Control structure",
          "Line 146: Control structure"
        ],
        "variable_usage": {
          "output": [
            48
          ],
          "temp_dir": [
            115
          ],
          "cargo_toml": [
            118
          ],
          "start": [
            29
          ],
          "main_rs": [
            134
          ],
          "_result": [
            142
          ],
          "stderr": [
            67
          ],
          "mut": [
            30,
            68,
            69
          ],
          "clippy_check": [
            33
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 59: Error handling point",
          "Line 116: Error handling point",
          "Line 127: Error handling point",
          "Line 132: Error handling point",
          "Line 141: Error handling point",
          "Line 143: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/doc.rs",
        "line": 13,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run documentation build check (placeholder)\"] pub async fn run (_project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Doc) ; result . set_duration (start . elapsed ()) ; result . add_context (\"Documentation check placeholder - always passes\") ; Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// Doc check implementation",
          "pub struct DocCheck;",
          "",
          "impl SafetyCheck for DocCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 13: impl SafetyCheck for DocCheck {"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 13: Control structure"
        ],
        "variable_usage": {
          "mut": [
            29,
            38
          ],
          "start": [
            28,
            37
          ]
        },
        "function_calls": [],
        "error_propagation_path": []
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/doc.rs",
        "line": 27,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run documentation build check (placeholder)\"] pub async fn run (_project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Doc) ; result . set_duration (start . elapsed ()) ; result . add_context (\"Documentation check placeholder - always passes\") ; Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for DocCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Builds project documentation\"",
          "    }",
          "}",
          "",
          "/// Run documentation build check (placeholder)",
          "pub async fn run(_project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::Doc);",
          "    result.set_duration(start.elapsed());",
          "    result.add_context(\"Documentation check placeholder - always passes\");"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 27: /// Run documentation build check (placeholder)"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 13: Control structure"
        ],
        "variable_usage": {
          "start": [
            28,
            37
          ],
          "mut": [
            29,
            38
          ]
        },
        "function_calls": [
          "/// Run documentation build check"
        ],
        "error_propagation_path": []
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "super",
        "crate",
        "/// Run documentation build check"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/doc.rs",
        "line": 36,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run documentation build check (placeholder)\"] pub async fn run (_project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Doc) ; result . set_duration (start . elapsed ()) ; result . add_context (\"Documentation check placeholder - always passes\") ; Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for DocCheck {",
        "surrounding_code": [
          "    result.set_duration(start.elapsed());",
          "    result.add_context(\"Documentation check placeholder - always passes\");",
          "    Ok(result)",
          "}",
          "",
          "/// Check documentation coverage (placeholder)",
          "pub async fn coverage_check(_project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::DocCoverage);",
          "    result.set_duration(start.elapsed());",
          "    result.add_context(\"Documentation coverage check placeholder - always passes\");"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 36: /// Check documentation coverage (placeholder)"
        ],
        "control_flow": [
          "Line 1: Control structure",
          "Line 13: Control structure"
        ],
        "variable_usage": {
          "start": [
            28,
            37
          ],
          "mut": [
            29,
            38
          ]
        },
        "function_calls": [
          "/// Check documentation coverage"
        ],
        "error_propagation_path": []
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "super",
        "crate",
        "/// Check documentation coverage"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/format.rs",
        "line": 14,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo fmt --check\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Format) ; if which :: which (\"cargo\") . is_err () { result . add_error (\"cargo not found in PATH\") ; result . add_suggestion (\"Install Rust and cargo from https://rustup.rs\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"fmt\" , \"--check\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Code formatting violations found\") ; result . add_suggestion (\"Run 'cargo fmt' to fix formatting automatically\") ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let stderr = String :: from_utf8_lossy (& output . stderr) ; for line in stdout . lines () . chain (stderr . lines ()) { if line . starts_with (\"Diff in\") { result . add_error (format ! (\"Formatting issue: {}\" , line)) ; } else if line . contains (\"rustfmt\") && line . contains (\"failed\") { result . add_error (line . to_string ()) ; } } if result . errors . len () == 1 { result . add_context (\"Run 'cargo fmt' to see detailed formatting issues\") ; } } else { result . add_context (\"All code is properly formatted\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// Format check implementation",
          "pub struct FormatCheck;",
          "",
          "impl SafetyCheck for FormatCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 14: impl SafetyCheck for FormatCheck {"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 34: Control structure",
          "Line 49: Control structure",
          "Line 57: Control structure",
          "Line 58: Control structure",
          "Line 59: Control structure",
          "Line 61: Control structure",
          "Line 67: Control structure",
          "Line 115: Control structure"
        ],
        "variable_usage": {
          "main_rs": [
            104
          ],
          "stderr": [
            54
          ],
          "start": [
            29
          ],
          "stdout": [
            53
          ],
          "mut": [
            30
          ],
          "output": [
            41
          ],
          "cargo_toml": [
            88
          ],
          "result": [
            112
          ],
          "temp_dir": [
            85
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 45: Error handling point",
          "Line 86: Error handling point",
          "Line 97: Error handling point",
          "Line 102: Error handling point",
          "Line 111: Error handling point",
          "Line 113: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/format.rs",
        "line": 28,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo fmt --check\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Format) ; if which :: which (\"cargo\") . is_err () { result . add_error (\"cargo not found in PATH\") ; result . add_suggestion (\"Install Rust and cargo from https://rustup.rs\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"fmt\" , \"--check\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Code formatting violations found\") ; result . add_suggestion (\"Run 'cargo fmt' to fix formatting automatically\") ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let stderr = String :: from_utf8_lossy (& output . stderr) ; for line in stdout . lines () . chain (stderr . lines ()) { if line . starts_with (\"Diff in\") { result . add_error (format ! (\"Formatting issue: {}\" , line)) ; } else if line . contains (\"rustfmt\") && line . contains (\"failed\") { result . add_error (line . to_string ()) ; } } if result . errors . len () == 1 { result . add_context (\"Run 'cargo fmt' to see detailed formatting issues\") ; } } else { result . add_context (\"All code is properly formatted\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for FormatCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Validates code formatting with rustfmt\"",
          "    }",
          "}",
          "",
          "/// Run cargo fmt --check",
          "pub async fn run(project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::Format);",
          "",
          "    // Check if rustfmt is available"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 28: /// Run cargo fmt --check"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 34: Control structure",
          "Line 49: Control structure",
          "Line 57: Control structure",
          "Line 58: Control structure",
          "Line 59: Control structure",
          "Line 61: Control structure",
          "Line 67: Control structure",
          "Line 115: Control structure"
        ],
        "variable_usage": {
          "cargo_toml": [
            88
          ],
          "mut": [
            30
          ],
          "main_rs": [
            104
          ],
          "temp_dir": [
            85
          ],
          "stdout": [
            53
          ],
          "output": [
            41
          ],
          "start": [
            29
          ],
          "stderr": [
            54
          ],
          "result": [
            112
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 45: Error handling point",
          "Line 86: Error handling point",
          "Line 97: Error handling point",
          "Line 102: Error handling point",
          "Line 111: Error handling point",
          "Line 113: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/format.rs",
        "line": 110,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo fmt --check\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Format) ; if which :: which (\"cargo\") . is_err () { result . add_error (\"cargo not found in PATH\") ; result . add_suggestion (\"Install Rust and cargo from https://rustup.rs\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"fmt\" , \"--check\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Code formatting violations found\") ; result . add_suggestion (\"Run 'cargo fmt' to fix formatting automatically\") ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let stderr = String :: from_utf8_lossy (& output . stderr) ; for line in stdout . lines () . chain (stderr . lines ()) { if line . starts_with (\"Diff in\") { result . add_error (format ! (\"Formatting issue: {}\" , line)) ; } else if line . contains (\"rustfmt\") && line . contains (\"failed\") { result . add_error (line . to_string ()) ; } } if result . errors . len () == 1 { result . add_context (\"Run 'cargo fmt' to see detailed formatting issues\") ; } } else { result . add_context (\"All code is properly formatted\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for FormatCheck {",
        "surrounding_code": [
          "        let main_rs = r#\"fn main() {",
          "    println!(\"Hello, world!\");",
          "}",
          "\"#;",
          "        fs::write(temp_dir.path().join(\"src/main.rs\"), main_rs)",
          "            .await",
          "            .unwrap();",
          "",
          "        let result = run(temp_dir.path()).await.unwrap();",
          "",
          "        // Should pass for properly formatted code"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 110: .await"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 34: Control structure",
          "Line 49: Control structure",
          "Line 57: Control structure",
          "Line 58: Control structure",
          "Line 59: Control structure",
          "Line 61: Control structure",
          "Line 67: Control structure",
          "Line 115: Control structure"
        ],
        "variable_usage": {
          "mut": [
            30
          ],
          "stdout": [
            53
          ],
          "result": [
            112
          ],
          "start": [
            29
          ],
          "temp_dir": [
            85
          ],
          "stderr": [
            54
          ],
          "cargo_toml": [
            88
          ],
          "output": [
            41
          ],
          "main_rs": [
            104
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 45: Error handling point",
          "Line 86: Error handling point",
          "Line 97: Error handling point",
          "Line 102: Error handling point",
          "Line 111: Error handling point",
          "Line 113: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/format.rs",
        "line": 112,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo fmt --check\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Format) ; if which :: which (\"cargo\") . is_err () { result . add_error (\"cargo not found in PATH\") ; result . add_suggestion (\"Install Rust and cargo from https://rustup.rs\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"fmt\" , \"--check\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Code formatting violations found\") ; result . add_suggestion (\"Run 'cargo fmt' to fix formatting automatically\") ; let stdout = String :: from_utf8_lossy (& output . stdout) ; let stderr = String :: from_utf8_lossy (& output . stderr) ; for line in stdout . lines () . chain (stderr . lines ()) { if line . starts_with (\"Diff in\") { result . add_error (format ! (\"Formatting issue: {}\" , line)) ; } else if line . contains (\"rustfmt\") && line . contains (\"failed\") { result . add_error (line . to_string ()) ; } } if result . errors . len () == 1 { result . add_context (\"Run 'cargo fmt' to see detailed formatting issues\") ; } } else { result . add_context (\"All code is properly formatted\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for FormatCheck {",
        "surrounding_code": [
          "}",
          "\"#;",
          "        fs::write(temp_dir.path().join(\"src/main.rs\"), main_rs)",
          "            .await",
          "            .unwrap();",
          "",
          "        let result = run(temp_dir.path()).await.unwrap();",
          "",
          "        // Should pass for properly formatted code",
          "        assert!(result.passed);",
          "        assert!(result.errors.is_empty());"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 112: "
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 34: Control structure",
          "Line 49: Control structure",
          "Line 57: Control structure",
          "Line 58: Control structure",
          "Line 59: Control structure",
          "Line 61: Control structure",
          "Line 67: Control structure",
          "Line 115: Control structure"
        ],
        "variable_usage": {
          "output": [
            41
          ],
          "cargo_toml": [
            88
          ],
          "main_rs": [
            104
          ],
          "temp_dir": [
            85
          ],
          "result": [
            112
          ],
          "stderr": [
            54
          ],
          "start": [
            29
          ],
          "stdout": [
            53
          ],
          "mut": [
            30
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 45: Error handling point",
          "Line 86: Error handling point",
          "Line 97: Error handling point",
          "Line 102: Error handling point",
          "Line 111: Error handling point",
          "Line 113: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/license.rs",
        "line": 14,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Validate license configuration\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: License) ; let cargo_toml_path = project_path . join (\"Cargo.toml\") ; if ! cargo_toml_path . exists () { result . add_error (\"Cargo.toml not found\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let contents = fs :: read_to_string (& cargo_toml_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | crate :: Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; result . set_duration (start . elapsed ()) ; let license = manifest . get (\"package\") . and_then (| p | p . get (\"license\")) . and_then (| l | l . as_str ()) ; let license_file = manifest . get (\"package\") . and_then (| p | p . get (\"license-file\")) . and_then (| l | l . as_str ()) ; if license . is_none () && license_file . is_none () { result . add_error (\"No license specified in Cargo.toml\") ; result . add_suggestion (\"Add 'license = \\\"MIT OR Apache-2.0\\\"' to [package] section\") ; result . add_suggestion (\"Or add 'license-file = \\\"LICENSE\\\"' if using custom license\") ; } else if let Some (license_str) = license { let approved_licenses = [\"MIT\" , \"Apache-2.0\" , \"MIT OR Apache-2.0\" , \"Apache-2.0 OR MIT\" , \"BSD-3-Clause\" , \"BSD-2-Clause\" , \"ISC\" , \"MPL-2.0\" ,] ; if ! approved_licenses . iter () . any (| & approved | license_str . contains (approved)) { result . add_error (format ! (\"Uncommon license detected: {}\" , license_str)) ; result . add_suggestion (\"Consider using a standard license like 'MIT OR Apache-2.0'\") ; result . add_context (\"This may cause issues with some package managers\") ; } else { result . add_context (format ! (\"License: {}\" , license_str)) ; } if license_str . contains (\"MIT\") || license_str . contains (\"Apache\") { let license_files = [\"LICENSE\" , \"LICENSE.txt\" , \"LICENSE.md\" , \"LICENSE-MIT\" , \"LICENSE-APACHE\" ,] ; let has_license_file = license_files . iter () . any (| & file | project_path . join (file) . exists ()) ; if ! has_license_file { result . add_error (\"License specified but no LICENSE file found\") ; result . add_suggestion (\"Create a LICENSE file with the license text\") ; } } } let description = manifest . get (\"package\") . and_then (| p | p . get (\"description\")) . and_then (| d | d . as_str ()) ; if description . is_none_or (| d | d . trim () . is_empty ()) { result . add_error (\"Missing or empty description in Cargo.toml\") ; result . add_suggestion (\"Add a clear description of what your crate does\") ; } let repository = manifest . get (\"package\") . and_then (| p | p . get (\"repository\")) . and_then (| r | r . as_str ()) ; if repository . is_none () { result . add_error (\"Missing repository URL in Cargo.toml\") ; result . add_suggestion (\"Add 'repository = \\\"https://github.com/user/repo\\\"' to [package]\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// License check implementation",
          "pub struct LicenseCheck;",
          "",
          "impl SafetyCheck for LicenseCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use tokio::fs;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 14: impl SafetyCheck for LicenseCheck {"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 36: Control structure",
          "Line 48: Control structure",
          "Line 59: Control structure",
          "Line 62: Control structure",
          "Line 63: Control structure",
          "Line 76: Control structure",
          "Line 87: Control structure",
          "Line 88: Control structure",
          "Line 100: Control structure",
          "Line 107: Control structure",
          "Line 113: Control structure",
          "Line 123: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure"
        ],
        "variable_usage": {
          "manifest": [
            42
          ],
          "license_files": [
            88
          ],
          "result": [
            162
          ],
          "cargo_toml": [
            140
          ],
          "temp_dir": [
            138
          ],
          "license": [
            48
          ],
          "Some(license_str)": [
            62
          ],
          "description": [
            107
          ],
          "repository": [
            117
          ],
          "start": [
            29
          ],
          "contents": [
            41
          ],
          "mut": [
            30
          ],
          "has_license_file": [
            95
          ],
          "cargo_toml_path": [
            33
          ],
          "license_file": [
            53
          ],
          "approved_licenses": [
            64
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 42: Error handling point",
          "Line 44: Error handling point",
          "Line 139: Error handling point",
          "Line 153: Error handling point",
          "Line 161: Error handling point",
          "Line 163: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "tokio",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/license.rs",
        "line": 28,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Validate license configuration\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: License) ; let cargo_toml_path = project_path . join (\"Cargo.toml\") ; if ! cargo_toml_path . exists () { result . add_error (\"Cargo.toml not found\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let contents = fs :: read_to_string (& cargo_toml_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | crate :: Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; result . set_duration (start . elapsed ()) ; let license = manifest . get (\"package\") . and_then (| p | p . get (\"license\")) . and_then (| l | l . as_str ()) ; let license_file = manifest . get (\"package\") . and_then (| p | p . get (\"license-file\")) . and_then (| l | l . as_str ()) ; if license . is_none () && license_file . is_none () { result . add_error (\"No license specified in Cargo.toml\") ; result . add_suggestion (\"Add 'license = \\\"MIT OR Apache-2.0\\\"' to [package] section\") ; result . add_suggestion (\"Or add 'license-file = \\\"LICENSE\\\"' if using custom license\") ; } else if let Some (license_str) = license { let approved_licenses = [\"MIT\" , \"Apache-2.0\" , \"MIT OR Apache-2.0\" , \"Apache-2.0 OR MIT\" , \"BSD-3-Clause\" , \"BSD-2-Clause\" , \"ISC\" , \"MPL-2.0\" ,] ; if ! approved_licenses . iter () . any (| & approved | license_str . contains (approved)) { result . add_error (format ! (\"Uncommon license detected: {}\" , license_str)) ; result . add_suggestion (\"Consider using a standard license like 'MIT OR Apache-2.0'\") ; result . add_context (\"This may cause issues with some package managers\") ; } else { result . add_context (format ! (\"License: {}\" , license_str)) ; } if license_str . contains (\"MIT\") || license_str . contains (\"Apache\") { let license_files = [\"LICENSE\" , \"LICENSE.txt\" , \"LICENSE.md\" , \"LICENSE-MIT\" , \"LICENSE-APACHE\" ,] ; let has_license_file = license_files . iter () . any (| & file | project_path . join (file) . exists ()) ; if ! has_license_file { result . add_error (\"License specified but no LICENSE file found\") ; result . add_suggestion (\"Create a LICENSE file with the license text\") ; } } } let description = manifest . get (\"package\") . and_then (| p | p . get (\"description\")) . and_then (| d | d . as_str ()) ; if description . is_none_or (| d | d . trim () . is_empty ()) { result . add_error (\"Missing or empty description in Cargo.toml\") ; result . add_suggestion (\"Add a clear description of what your crate does\") ; } let repository = manifest . get (\"package\") . and_then (| p | p . get (\"repository\")) . and_then (| r | r . as_str ()) ; if repository . is_none () { result . add_error (\"Missing repository URL in Cargo.toml\") ; result . add_suggestion (\"Add 'repository = \\\"https://github.com/user/repo\\\"' to [package]\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for LicenseCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Validates license compatibility and presence\"",
          "    }",
          "}",
          "",
          "/// Validate license configuration",
          "pub async fn run(project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::License);",
          "",
          "    // Check Cargo.toml for license field"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use tokio::fs;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 28: /// Validate license configuration"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 33: Control structure",
          "Line 36: Control structure",
          "Line 48: Control structure",
          "Line 59: Control structure",
          "Line 62: Control structure",
          "Line 63: Control structure",
          "Line 76: Control structure",
          "Line 87: Control structure",
          "Line 88: Control structure",
          "Line 100: Control structure",
          "Line 107: Control structure",
          "Line 113: Control structure",
          "Line 123: Control structure",
          "Line 166: Control structure",
          "Line 167: Control structure"
        ],
        "variable_usage": {
          "manifest": [
            42
          ],
          "mut": [
            30
          ],
          "cargo_toml": [
            140
          ],
          "description": [
            107
          ],
          "Some(license_str)": [
            62
          ],
          "repository": [
            117
          ],
          "result": [
            162
          ],
          "license_file": [
            53
          ],
          "approved_licenses": [
            64
          ],
          "start": [
            29
          ],
          "contents": [
            41
          ],
          "license_files": [
            88
          ],
          "has_license_file": [
            95
          ],
          "cargo_toml_path": [
            33
          ],
          "temp_dir": [
            138
          ],
          "license": [
            48
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 42: Error handling point",
          "Line 44: Error handling point",
          "Line 139: Error handling point",
          "Line 153: Error handling point",
          "Line 161: Error handling point",
          "Line 163: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "tokio",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/mod.rs",
        "line": 26,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": "/// Trait for implementing safety checks",
        "surrounding_code": [
          "pub mod test_runner;",
          "",
          "/// Trait for implementing safety checks",
          "#[allow(async_fn_in_trait)]",
          "pub trait SafetyCheck {",
          "    /// Run the safety check",
          "    async fn run(project_path: &Path) -> Result<CheckResult>;",
          "",
          "    /// Get the name of this check",
          "    fn name() -> &'static str;",
          ""
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use super::report::CheckResult;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 26: /// Run the safety check"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 23: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 64: Control structure"
        ],
        "variable_usage": {},
        "function_calls": [],
        "error_propagation_path": []
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/mod.rs",
        "line": 57,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": null,
        "function_signature": null,
        "return_type": null,
        "is_async": false,
        "is_generic": false,
        "trait_impl": "/// Trait for implementing safety checks",
        "surrounding_code": [
          "            super::CheckType::License,",
          "            super::CheckType::Semver,",
          "        ]",
          "    }",
          "",
          "    /// Get description for a check type",
          "    pub fn get_description(check_type: super::CheckType) -> &'static str {",
          "        match check_type {",
          "            super::CheckType::Format => \"Validates code formatting with rustfmt\",",
          "            super::CheckType::Clippy => \"Runs clippy lints with strict warnings\",",
          "            super::CheckType::Build => \"Ensures project builds successfully\","
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use super::report::CheckResult;"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 57: /// Get description for a check type"
        ],
        "control_flow": [
          "Line 3: Control structure",
          "Line 23: Control structure",
          "Line 57: Control structure",
          "Line 59: Control structure",
          "Line 64: Control structure"
        ],
        "variable_usage": {},
        "function_calls": [],
        "error_propagation_path": []
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "super"
      ],
      "side_effects": [],
      "confidence_score": 0.65
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/publish.rs",
        "line": 14,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo publish --dry-run\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: PublishDryRun) ; let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"publish\" , \"--dry-run\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Publish dry run failed\") ; result . add_suggestion (\"Fix publish issues before attempting real publish\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; for line in stderr . lines () { if line . starts_with (\"error:\") && error_count < 3 { result . add_error (format ! (\"Publish: {}\" , line . trim ())) ; error_count += 1 ; } else if line . contains (\"warning:\") && line . contains (\"ignoring\") { result . add_context (line . trim () . to_string ()) ; } } if error_count >= 3 { result . add_error (\"... and more publish errors (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo publish --dry-run' to see detailed output\") ; result . add_suggestion (\"Check Cargo.toml metadata and file inclusions\") ; } else { result . add_context (\"Ready for crates.io publication\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let warning_count = stderr . lines () . filter (| line | line . starts_with (\"warning:\")) . count () ; if warning_count > 0 { result . add_context (format ! (\"Publish dry run completed with {} warnings\" , warning_count)) ; } } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// Publish dry run check implementation",
          "pub struct PublishCheck;",
          "",
          "impl SafetyCheck for PublishCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 14: impl SafetyCheck for PublishCheck {"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 41: Control structure",
          "Line 49: Control structure",
          "Line 50: Control structure",
          "Line 53: Control structure",
          "Line 58: Control structure",
          "Line 65: Control structure",
          "Line 67: Control structure",
          "Line 74: Control structure"
        ],
        "variable_usage": {
          "stderr": [
            45,
            67
          ],
          "output": [
            33
          ],
          "start": [
            29
          ],
          "mut": [
            30,
            46
          ],
          "warning_count": [
            68
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 37: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/publish.rs",
        "line": 28,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Run cargo publish --dry-run\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: PublishDryRun) ; let output = Command :: new (\"cargo\") . current_dir (project_path) . args (& [\"publish\" , \"--dry-run\"]) . output () ? ; result . set_duration (start . elapsed ()) ; if ! output . status . success () { result . add_error (\"Publish dry run failed\") ; result . add_suggestion (\"Fix publish issues before attempting real publish\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let mut error_count = 0 ; for line in stderr . lines () { if line . starts_with (\"error:\") && error_count < 3 { result . add_error (format ! (\"Publish: {}\" , line . trim ())) ; error_count += 1 ; } else if line . contains (\"warning:\") && line . contains (\"ignoring\") { result . add_context (line . trim () . to_string ()) ; } } if error_count >= 3 { result . add_error (\"... and more publish errors (showing first 3)\") ; } result . add_suggestion (\"Run 'cargo publish --dry-run' to see detailed output\") ; result . add_suggestion (\"Check Cargo.toml metadata and file inclusions\") ; } else { result . add_context (\"Ready for crates.io publication\") ; let stderr = String :: from_utf8_lossy (& output . stderr) ; let warning_count = stderr . lines () . filter (| line | line . starts_with (\"warning:\")) . count () ; if warning_count > 0 { result . add_context (format ! (\"Publish dry run completed with {} warnings\" , warning_count)) ; } } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for PublishCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Validates crates.io publication readiness\"",
          "    }",
          "}",
          "",
          "/// Run cargo publish --dry-run",
          "pub async fn run(project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::PublishDryRun);",
          "",
          "    // Run cargo publish --dry-run"
        ],
        "imports": [
          "use crate::Result;",
          "use std::path::Path;",
          "use std::process::Command;",
          "use std::time::Instant;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 28: /// Run cargo publish --dry-run"
        ],
        "control_flow": [
          "Line 14: Control structure",
          "Line 41: Control structure",
          "Line 49: Control structure",
          "Line 50: Control structure",
          "Line 53: Control structure",
          "Line 58: Control structure",
          "Line 65: Control structure",
          "Line 67: Control structure",
          "Line 74: Control structure"
        ],
        "variable_usage": {
          "warning_count": [
            68
          ],
          "mut": [
            30,
            46
          ],
          "output": [
            33
          ],
          "start": [
            29
          ],
          "stderr": [
            45,
            67
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 37: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "std",
        "std",
        "std",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/semver.rs",
        "line": 15,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Check semantic versioning compliance\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Semver) ; let cargo_toml_path = project_path . join (\"Cargo.toml\") ; if ! cargo_toml_path . exists () { result . add_error (\"Cargo.toml not found\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let contents = fs :: read_to_string (& cargo_toml_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | crate :: Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; result . set_duration (start . elapsed ()) ; let version_str = manifest . get (\"package\") . and_then (| p | p . get (\"version\")) . and_then (| v | v . as_str ()) ; if let Some (version_str) = version_str { match Version :: parse (version_str) { Ok (version) => { result . add_context (format ! (\"Current version: {}\" , version)) ; if ! version . pre . is_empty () { result . add_context (format ! (\"Pre-release version: {}\" , version . pre)) ; result . add_suggestion (\"Consider if this should be published as pre-release\") ; } if ! version . build . is_empty () { result . add_context (format ! (\"Build metadata: {}\" , version . build)) ; } if version . major == 0 && version . minor == 0 && version . patch == 0 { result . add_error (\"Version 0.0.0 should not be published\") ; result . add_suggestion (\"Use a proper version like 0.1.0 for initial release\") ; } else if version . major > 10 { result . add_context (\"High major version detected - ensure this is intentional\") ; } } Err (e) => { result . add_error (format ! (\"Invalid semantic version: {}\" , e)) ; result . add_suggestion (\"Use format: MAJOR.MINOR.PATCH (e.g., 1.0.0)\") ; result . add_suggestion (\"See https://semver.org for semantic versioning rules\") ; } } } else { result . add_error (\"No version field found in Cargo.toml\") ; result . add_suggestion (\"Add 'version = \\\"0.1.0\\\"' to [package] section\") ; } let changelog_path = project_path . join (\"CHANGELOG.md\") ; if changelog_path . exists () { result . add_context (\"CHANGELOG.md found\") ; } else { result . add_context (\"No CHANGELOG.md found\") ; result . add_suggestion (\"Consider adding CHANGELOG.md to track changes\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": null,
        "surrounding_code": [
          "use crate::safety::{report::CheckResult, CheckType};",
          "",
          "/// Semver check implementation",
          "pub struct SemverCheck;",
          "",
          "impl SafetyCheck for SemverCheck {",
          "    async fn run(project_path: &Path) -> Result<CheckResult> {",
          "        run(project_path).await",
          "    }",
          "",
          "    fn name() -> &'static str {"
        ],
        "imports": [
          "use crate::Result;",
          "use semver::Version;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use tokio::fs;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 15: impl SafetyCheck for SemverCheck {"
        ],
        "control_flow": [
          "Line 15: Control structure",
          "Line 37: Control structure",
          "Line 55: Control structure",
          "Line 56: Control structure",
          "Line 60: Control structure",
          "Line 61: Control structure",
          "Line 63: Control structure",
          "Line 66: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 75: Control structure",
          "Line 85: Control structure",
          "Line 93: Control structure",
          "Line 95: Control structure",
          "Line 98: Control structure"
        ],
        "variable_usage": {
          "cargo_toml_path": [
            34
          ],
          "manifest": [
            43
          ],
          "temp_dir": [
            114,
            135
          ],
          "cargo_toml": [
            116,
            137
          ],
          "changelog_path": [
            93
          ],
          "result": [
            127,
            148
          ],
          "mut": [
            31
          ],
          "start": [
            30
          ],
          "Some(version_str)": [
            54
          ],
          "version_str": [
            49
          ],
          "contents": [
            42
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 43: Error handling point",
          "Line 45: Error handling point",
          "Line 115: Error handling point",
          "Line 126: Error handling point",
          "Line 128: Error handling point",
          "Line 136: Error handling point",
          "Line 147: Error handling point",
          "Line 149: Error handling point"
        ]
      },
      "fix_complexity": "Moderate",
      "dependencies": [
        "crate",
        "semver",
        "std",
        "std",
        "tokio",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnderscoreBandaid",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/semver.rs",
        "line": 29,
        "message": "BANNED: Underscore parameter (_param) - fix the design instead of hiding warnings",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Check semantic versioning compliance\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Semver) ; let cargo_toml_path = project_path . join (\"Cargo.toml\") ; if ! cargo_toml_path . exists () { result . add_error (\"Cargo.toml not found\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let contents = fs :: read_to_string (& cargo_toml_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | crate :: Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; result . set_duration (start . elapsed ()) ; let version_str = manifest . get (\"package\") . and_then (| p | p . get (\"version\")) . and_then (| v | v . as_str ()) ; if let Some (version_str) = version_str { match Version :: parse (version_str) { Ok (version) => { result . add_context (format ! (\"Current version: {}\" , version)) ; if ! version . pre . is_empty () { result . add_context (format ! (\"Pre-release version: {}\" , version . pre)) ; result . add_suggestion (\"Consider if this should be published as pre-release\") ; } if ! version . build . is_empty () { result . add_context (format ! (\"Build metadata: {}\" , version . build)) ; } if version . major == 0 && version . minor == 0 && version . patch == 0 { result . add_error (\"Version 0.0.0 should not be published\") ; result . add_suggestion (\"Use a proper version like 0.1.0 for initial release\") ; } else if version . major > 10 { result . add_context (\"High major version detected - ensure this is intentional\") ; } } Err (e) => { result . add_error (format ! (\"Invalid semantic version: {}\" , e)) ; result . add_suggestion (\"Use format: MAJOR.MINOR.PATCH (e.g., 1.0.0)\") ; result . add_suggestion (\"See https://semver.org for semantic versioning rules\") ; } } } else { result . add_error (\"No version field found in Cargo.toml\") ; result . add_suggestion (\"Add 'version = \\\"0.1.0\\\"' to [package] section\") ; } let changelog_path = project_path . join (\"CHANGELOG.md\") ; if changelog_path . exists () { result . add_context (\"CHANGELOG.md found\") ; } else { result . add_context (\"No CHANGELOG.md found\") ; result . add_suggestion (\"Consider adding CHANGELOG.md to track changes\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for SemverCheck {",
        "surrounding_code": [
          "    fn description() -> &'static str {",
          "        \"Checks semantic versioning compliance\"",
          "    }",
          "}",
          "",
          "/// Check semantic versioning compliance",
          "pub async fn run(project_path: &Path) -> Result<CheckResult> {",
          "    let start = Instant::now();",
          "    let mut result = CheckResult::new(CheckType::Semver);",
          "",
          "    // Read Cargo.toml"
        ],
        "imports": [
          "use crate::Result;",
          "use semver::Version;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use tokio::fs;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": null,
        "data_flow": [
          "Line 29: /// Check semantic versioning compliance"
        ],
        "control_flow": [
          "Line 15: Control structure",
          "Line 37: Control structure",
          "Line 55: Control structure",
          "Line 56: Control structure",
          "Line 60: Control structure",
          "Line 61: Control structure",
          "Line 63: Control structure",
          "Line 66: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 75: Control structure",
          "Line 85: Control structure",
          "Line 93: Control structure",
          "Line 95: Control structure",
          "Line 98: Control structure"
        ],
        "variable_usage": {
          "contents": [
            42
          ],
          "manifest": [
            43
          ],
          "version_str": [
            49
          ],
          "mut": [
            31
          ],
          "cargo_toml_path": [
            34
          ],
          "Some(version_str)": [
            54
          ],
          "changelog_path": [
            93
          ],
          "cargo_toml": [
            116,
            137
          ],
          "start": [
            30
          ],
          "temp_dir": [
            114,
            135
          ],
          "result": [
            127,
            148
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 43: Error handling point",
          "Line 45: Error handling point",
          "Line 115: Error handling point",
          "Line 126: Error handling point",
          "Line 128: Error handling point",
          "Line 136: Error handling point",
          "Line 147: Error handling point",
          "Line 149: Error handling point"
        ]
      },
      "fix_complexity": "Architectural",
      "dependencies": [
        "crate",
        "semver",
        "std",
        "std",
        "tokio",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/semver.rs",
        "line": 135,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Check semantic versioning compliance\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Semver) ; let cargo_toml_path = project_path . join (\"Cargo.toml\") ; if ! cargo_toml_path . exists () { result . add_error (\"Cargo.toml not found\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let contents = fs :: read_to_string (& cargo_toml_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | crate :: Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; result . set_duration (start . elapsed ()) ; let version_str = manifest . get (\"package\") . and_then (| p | p . get (\"version\")) . and_then (| v | v . as_str ()) ; if let Some (version_str) = version_str { match Version :: parse (version_str) { Ok (version) => { result . add_context (format ! (\"Current version: {}\" , version)) ; if ! version . pre . is_empty () { result . add_context (format ! (\"Pre-release version: {}\" , version . pre)) ; result . add_suggestion (\"Consider if this should be published as pre-release\") ; } if ! version . build . is_empty () { result . add_context (format ! (\"Build metadata: {}\" , version . build)) ; } if version . major == 0 && version . minor == 0 && version . patch == 0 { result . add_error (\"Version 0.0.0 should not be published\") ; result . add_suggestion (\"Use a proper version like 0.1.0 for initial release\") ; } else if version . major > 10 { result . add_context (\"High major version detected - ensure this is intentional\") ; } } Err (e) => { result . add_error (format ! (\"Invalid semantic version: {}\" , e)) ; result . add_suggestion (\"Use format: MAJOR.MINOR.PATCH (e.g., 1.0.0)\") ; result . add_suggestion (\"See https://semver.org for semantic versioning rules\") ; } } } else { result . add_error (\"No version field found in Cargo.toml\") ; result . add_suggestion (\"Add 'version = \\\"0.1.0\\\"' to [package] section\") ; } let changelog_path = project_path . join (\"CHANGELOG.md\") ; if changelog_path . exists () { result . add_context (\"CHANGELOG.md found\") ; } else { result . add_context (\"No CHANGELOG.md found\") ; result . add_suggestion (\"Consider adding CHANGELOG.md to track changes\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for SemverCheck {",
        "surrounding_code": [
          "        // Should pass with valid version",
          "        assert!(result.passed);",
          "    }",
          "",
          "    #[tokio::test]",
          "    async fn test_semver_check_with_invalid_version() {",
          "        let temp_dir = TempDir::new().unwrap();",
          "",
          "        let cargo_toml = r#\"",
          "[package]",
          "name = \"test\""
        ],
        "imports": [
          "use crate::Result;",
          "use semver::Version;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use tokio::fs;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 135: async fn test_semver_check_with_invalid_version() {"
        ],
        "control_flow": [
          "Line 15: Control structure",
          "Line 37: Control structure",
          "Line 55: Control structure",
          "Line 56: Control structure",
          "Line 60: Control structure",
          "Line 61: Control structure",
          "Line 63: Control structure",
          "Line 66: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 75: Control structure",
          "Line 85: Control structure",
          "Line 93: Control structure",
          "Line 95: Control structure",
          "Line 98: Control structure"
        ],
        "variable_usage": {
          "start": [
            30
          ],
          "mut": [
            31
          ],
          "contents": [
            42
          ],
          "version_str": [
            49
          ],
          "Some(version_str)": [
            54
          ],
          "changelog_path": [
            93
          ],
          "manifest": [
            43
          ],
          "cargo_toml": [
            116,
            137
          ],
          "result": [
            127,
            148
          ],
          "cargo_toml_path": [
            34
          ],
          "temp_dir": [
            114,
            135
          ]
        },
        "function_calls": [
          "async fn test_semver_check_with_invalid_version"
        ],
        "error_propagation_path": [
          "Line 43: Error handling point",
          "Line 45: Error handling point",
          "Line 115: Error handling point",
          "Line 126: Error handling point",
          "Line 128: Error handling point",
          "Line 136: Error handling point",
          "Line 147: Error handling point",
          "Line 149: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "semver",
        "std",
        "std",
        "tokio",
        "super",
        "crate",
        "async fn test_semver_check_with_invalid_version"
      ],
      "side_effects": [],
      "confidence_score": 1.0
    },
    {
      "violation": {
        "violation_type": "UnwrapInProduction",
        "file": "/mnt/projects/ferrous-forge/src/safety/checks/semver.rs",
        "line": 146,
        "message": "BANNED: .unwrap() in production code - use proper error handling with ?",
        "severity": "Error"
      },
      "code_context": {
        "function_name": "run",
        "function_signature": "# [doc = \" Check semantic versioning compliance\"] pub async fn run (project_path : & Path) -> Result < CheckResult > { let start = Instant :: now () ; let mut result = CheckResult :: new (CheckType :: Semver) ; let cargo_toml_path = project_path . join (\"Cargo.toml\") ; if ! cargo_toml_path . exists () { result . add_error (\"Cargo.toml not found\") ; result . set_duration (start . elapsed ()) ; return Ok (result) ; } let contents = fs :: read_to_string (& cargo_toml_path) . await ? ; let manifest : toml :: Value = toml :: from_str (& contents) . map_err (| e | crate :: Error :: parse (format ! (\"Failed to parse Cargo.toml: {}\" , e))) ? ; result . set_duration (start . elapsed ()) ; let version_str = manifest . get (\"package\") . and_then (| p | p . get (\"version\")) . and_then (| v | v . as_str ()) ; if let Some (version_str) = version_str { match Version :: parse (version_str) { Ok (version) => { result . add_context (format ! (\"Current version: {}\" , version)) ; if ! version . pre . is_empty () { result . add_context (format ! (\"Pre-release version: {}\" , version . pre)) ; result . add_suggestion (\"Consider if this should be published as pre-release\") ; } if ! version . build . is_empty () { result . add_context (format ! (\"Build metadata: {}\" , version . build)) ; } if version . major == 0 && version . minor == 0 && version . patch == 0 { result . add_error (\"Version 0.0.0 should not be published\") ; result . add_suggestion (\"Use a proper version like 0.1.0 for initial release\") ; } else if version . major > 10 { result . add_context (\"High major version detected - ensure this is intentional\") ; } } Err (e) => { result . add_error (format ! (\"Invalid semantic version: {}\" , e)) ; result . add_suggestion (\"Use format: MAJOR.MINOR.PATCH (e.g., 1.0.0)\") ; result . add_suggestion (\"See https://semver.org for semantic versioning rules\") ; } } } else { result . add_error (\"No version field found in Cargo.toml\") ; result . add_suggestion (\"Add 'version = \\\"0.1.0\\\"' to [package] section\") ; } let changelog_path = project_path . join (\"CHANGELOG.md\") ; if changelog_path . exists () { result . add_context (\"CHANGELOG.md found\") ; } else { result . add_context (\"No CHANGELOG.md found\") ; result . add_suggestion (\"Consider adding CHANGELOG.md to track changes\") ; } Ok (result) } . sig",
        "return_type": "Result < CheckResult >",
        "is_async": true,
        "is_generic": false,
        "trait_impl": "impl SafetyCheck for SemverCheck {",
        "surrounding_code": [
          "version = \"0.0.0\"",
          "edition = \"2021\"",
          "\"#;",
          "",
          "        fs::write(temp_dir.path().join(\"Cargo.toml\"), cargo_toml)",
          "            .await",
          "            .unwrap();",
          "",
          "        let result = run(temp_dir.path()).await.unwrap();",
          "",
          "        // Should fail with 0.0.0 version"
        ],
        "imports": [
          "use crate::Result;",
          "use semver::Version;",
          "use std::path::Path;",
          "use std::time::Instant;",
          "use tokio::fs;",
          "use super::SafetyCheck;",
          "use crate::safety::{report::CheckResult, CheckType};"
        ],
        "error_handling_style": "StdResult"
      },
      "semantic_analysis": {
        "actual_type": null,
        "expected_type": "Result or Option",
        "data_flow": [
          "Line 146: .await"
        ],
        "control_flow": [
          "Line 15: Control structure",
          "Line 37: Control structure",
          "Line 55: Control structure",
          "Line 56: Control structure",
          "Line 60: Control structure",
          "Line 61: Control structure",
          "Line 63: Control structure",
          "Line 66: Control structure",
          "Line 67: Control structure",
          "Line 72: Control structure",
          "Line 74: Control structure",
          "Line 75: Control structure",
          "Line 85: Control structure",
          "Line 93: Control structure",
          "Line 95: Control structure",
          "Line 98: Control structure"
        ],
        "variable_usage": {
          "result": [
            127,
            148
          ],
          "cargo_toml_path": [
            34
          ],
          "manifest": [
            43
          ],
          "changelog_path": [
            93
          ],
          "temp_dir": [
            114,
            135
          ],
          "Some(version_str)": [
            54
          ],
          "start": [
            30
          ],
          "contents": [
            42
          ],
          "mut": [
            31
          ],
          "version_str": [
            49
          ],
          "cargo_toml": [
            116,
            137
          ]
        },
        "function_calls": [],
        "error_propagation_path": [
          "Line 43: Error handling point",
          "Line 45: Error handling point",
          "Line 115: Error handling point",
          "Line 126: Error handling point",
          "Line 128: Error handling point",
          "Line 136: Error handling point",
          "Line 147: Error handling point",
          "Line 149: Error handling point"
        ]
      },
      "fix_complexity": "Simple",
      "dependencies": [
        "crate",
        "semver",
        "std",
        "std",
        "tokio",
        "super",
        "crate"
      ],
      "side_effects": [],
      "confidence_score": 0.9
    }
  ],
  "code_patterns": {
    "common_patterns": [],
    "anti_patterns": [
      {
        "name": "Excessive Unwrapping",
        "occurrences": 127,
        "locations": [
          "/mnt/projects/ferrous-forge/src/ai_analyzer.rs:304",
          "/mnt/projects/ferrous-forge/src/ai_analyzer.rs:442",
          "/mnt/projects/ferrous-forge/src/ai_analyzer.rs:442",
          "/mnt/projects/ferrous-forge/src/ai_analyzer.rs:575",
          "/mnt/projects/ferrous-forge/src/ai_analyzer.rs:608"
        ],
        "description": "Heavy use of .unwrap() indicates poor error handling"
      }
    ],
    "architectural_style": "Modular",
    "error_handling_pattern": "PanicHeavy"
  },
  "fix_strategies": [
    {
      "violation_type": "UnwrapInProduction",
      "strategy_name": "Progressive Error Handling Migration",
      "description": "Gradually replace unwrap() with proper error handling",
      "steps": [
        "1. Identify function return types",
        "2. Add Result return types where missing",
        "3. Replace .unwrap() with ? operator",
        "4. Add context with anyhow::Context trait",
        "5. Implement custom error types for domain errors"
      ],
      "prerequisites": [
        "anyhow or thiserror dependency",
        "Understanding of error propagation paths"
      ],
      "risks": [
        "Breaking API changes if public functions modified",
        "Need to handle errors at call sites"
      ],
      "confidence": 0.8,
      "estimated_time_minutes": 15
    },
    {
      "violation_type": "UnderscoreBandaid",
      "strategy_name": "Implement Missing Functionality",
      "description": "Either use parameters properly or remove them",
      "steps": [
        "1. Analyze if parameter is actually needed",
        "2. If needed, implement the missing logic",
        "3. If not needed, remove from signature",
        "4. Update all call sites",
        "5. Add tests for new functionality"
      ],
      "prerequisites": [
        "Understanding of function's purpose",
        "Access to all call sites"
      ],
      "risks": [
        "May break existing code if signature changes",
        "Could introduce bugs if logic is complex"
      ],
      "confidence": 0.6,
      "estimated_time_minutes": 30
    }
  ],
  "ai_instructions": {
    "system_prompt": "You are an expert Rust developer tasked with fixing code violations identified by Ferrous Forge.\n\nYour goals:\n1. Fix violations while maintaining code functionality\n2. Improve error handling without breaking existing behavior\n3. Follow Rust best practices and idioms\n4. Ensure all changes compile and pass tests\n5. Add appropriate documentation for complex changes\n\nKey principles:\n- Preserve existing behavior unless explicitly broken\n- Prefer explicit error handling over panics\n- Use type system to prevent errors at compile time\n- Write self-documenting code\n- Consider performance implications",
    "violation_specific_prompts": [
      {
        "violation_id": "violation_0",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 304\nCurrent code: \"        ErrorHandlingStyle::OptionBased\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_1",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 358\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_2",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 374\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_3",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 381\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_4",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 390\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_5",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 438\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_6",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 442\nCurrent code: \"    for (i, line) in lines.iter().enumerate() {\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_7",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 442\nCurrent code: \"    for (i, line) in lines.iter().enumerate() {\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_8",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 575\nCurrent code: \"                .collect(),\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_9",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/ai_analyzer.rs\nLine: 608\nCurrent code: \"            \\\"2. Add Result return types where missing\\\".to_string(),\"\n\nContext:\n- Function: Some(\"analyze_violations_for_ai\")\n- Return type: Some(\"anyhow :: Result < AIAnalysisReport >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_10",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/edition.rs\nLine: 232\nCurrent code: \"/// Handle edition analyze command\"\n\nContext:\n- Function: Some(\"handle_check\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_11",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 470\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_12",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 515\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_13",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 521\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_14",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 528\nCurrent code: \"            if context.is_example_file || context.is_bin_file {\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_15",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 528\nCurrent code: \"            if context.is_example_file || context.is_bin_file {\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_16",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 535\nCurrent code: \"        // Safe to replace with ?\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_17",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 538\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_18",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 545\nCurrent code: \"        // Extract the expect message and convert to context\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_19",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 596\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_20",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 597\nCurrent code: \"    // Fix let _ = assignments\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_21",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/fix.rs\nLine: 599\nCurrent code: \"        // Check if the expression likely returns Result\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: Anyhow\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_22",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/rust.rs\nLine: 143\nCurrent code: \"/// Handle rust version recommend command\"\n\nContext:\n- Function: Some(\"handle_check\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_23",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/safety.rs\nLine: 9\nCurrent code: \"/// Handle safety install command\"\n\nContext:\n- Function: Some(\"handle_install\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_24",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/safety.rs\nLine: 99\nCurrent code: \"/// Handle safety check command\"\n\nContext:\n- Function: Some(\"handle_install\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_25",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/safety.rs\nLine: 226\nCurrent code: \"/// Test individual safety checks\"\n\nContext:\n- Function: Some(\"handle_install\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_26",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/update.rs\nLine: 6\nCurrent code: \"/// Execute the update command\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_27",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/update.rs\nLine: 32\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_28",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/update.rs\nLine: 48\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_29",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/validate.rs\nLine: 182\nCurrent code: \"/// Generate AI-friendly compliance report\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_30",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/validate.rs\nLine: 219\nCurrent code: \"                    (\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_31",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/validate.rs\nLine: 226\nCurrent code: \"            crate::validation::ViolationType::UnwrapInProduction => (\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_32",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/validate.rs\nLine: 266\nCurrent code: \"                \\\"1. Identify what functionality the parameter should provide\\\\n2. Either implement the functionality or remove the parameter\\\\n3. Update function signature and callers\\\".to_string(),\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_33",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/validate.rs\nLine: 271\nCurrent code: \"                \\\"1. Change function to return Result<T, Error>\\\\n2. Replace ? with ?\\\\n3. Handle errors at call sites\\\".to_string(),\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_34",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/validate.rs\nLine: 357\nCurrent code: \"/// Get code snippet around a violation\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_35",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/commands/validate.rs\nLine: 373\nCurrent code: \"/// Count Rust files in project\"\n\nContext:\n- Function: Some(\"execute\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_36",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/doc_coverage.rs\nLine: 26\nCurrent code: \"    /// Check if coverage meets minimum threshold\"\n\nContext:\n- Function: Some(\"check_documentation_coverage\")\n- Return type: Some(\"Result < DocCoverage >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_37",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/doc_coverage.rs\nLine: 66\nCurrent code: \"/// Check documentation coverage for a Rust project\"\n\nContext:\n- Function: Some(\"check_documentation_coverage\")\n- Return type: Some(\"Result < DocCoverage >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_38",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/doc_coverage.rs\nLine: 124\nCurrent code: \"/// Count documentation items in the project\"\n\nContext:\n- Function: Some(\"check_documentation_coverage\")\n- Return type: Some(\"Result < DocCoverage >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_39",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/doc_coverage.rs\nLine: 193\nCurrent code: \"/// Suggest documentation for missing items\"\n\nContext:\n- Function: Some(\"check_documentation_coverage\")\n- Return type: Some(\"Result < DocCoverage >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_40",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/analyzer.rs\nLine: 16\nCurrent code: \"    /// Create a new edition analyzer\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_41",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/analyzer.rs\nLine: 23\nCurrent code: \"    /// Analyze the project for edition compatibility issues\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_42",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/analyzer.rs\nLine: 138\nCurrent code: \"    /// Add migration suggestions\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_43",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/migrator.rs\nLine: 17\nCurrent code: \"    /// Create a new edition migrator\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_44",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/migrator.rs\nLine: 25\nCurrent code: \"    /// Set backup directory\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_45",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/migrator.rs\nLine: 331\nCurrent code: \"    async fn test_migrator_creation() {\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Complex\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 75.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_46",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/mod.rs\nLine: 105\nCurrent code: \"    /// Create a new edition status\"\n\nContext:\n- Function: Some(\"detect_edition\")\n- Return type: Some(\"Result < Edition >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_47",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/mod.rs\nLine: 133\nCurrent code: \"/// Detect edition from Cargo.toml\"\n\nContext:\n- Function: Some(\"detect_edition\")\n- Return type: Some(\"Result < Edition >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_48",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/mod.rs\nLine: 156\nCurrent code: \"/// Check edition compliance for a project\"\n\nContext:\n- Function: Some(\"detect_edition\")\n- Return type: Some(\"Result < Edition >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_49",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/mod.rs\nLine: 250\nCurrent code: \"    async fn test_detect_edition() {\"\n\nContext:\n- Function: Some(\"detect_edition\")\n- Return type: Some(\"Result < Edition >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_50",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/mod.rs\nLine: 260\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"detect_edition\")\n- Return type: Some(\"Result < Edition >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_51",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/edition/mod.rs\nLine: 262\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"detect_edition\")\n- Return type: Some(\"Result < Edition >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_52",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/error.rs\nLine: 156\nCurrent code: \"    /// Create a new rate limited error\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_53",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/formatting.rs\nLine: 77\nCurrent code: \"/// Check code formatting\"\n\nContext:\n- Function: Some(\"check_formatting\")\n- Return type: Some(\"Result < FormatResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_54",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/formatting.rs\nLine: 93\nCurrent code: \"/// Auto-format code\"\n\nContext:\n- Function: Some(\"check_formatting\")\n- Return type: Some(\"Result < FormatResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_55",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/formatting.rs\nLine: 116\nCurrent code: \"/// Check formatting for a specific file\"\n\nContext:\n- Function: Some(\"check_formatting\")\n- Return type: Some(\"Result < FormatResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_56",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/formatting.rs\nLine: 135\nCurrent code: \"/// Format a specific file\"\n\nContext:\n- Function: Some(\"check_formatting\")\n- Return type: Some(\"Result < FormatResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_57",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/formatting.rs\nLine: 162\nCurrent code: \"/// Get formatting diff without applying changes\"\n\nContext:\n- Function: Some(\"check_formatting\")\n- Return type: Some(\"Result < FormatResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_58",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/formatting.rs\nLine: 260\nCurrent code: \"/// Apply formatting configuration\"\n\nContext:\n- Function: Some(\"check_formatting\")\n- Return type: Some(\"Result < FormatResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_59",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/git_hooks.rs\nLine: 136\nCurrent code: \"/// Install git hooks in a project\"\n\nContext:\n- Function: Some(\"install_git_hooks\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_60",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/git_hooks.rs\nLine: 179\nCurrent code: \"/// Install a single hook\"\n\nContext:\n- Function: Some(\"install_git_hooks\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_61",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/git_hooks.rs\nLine: 229\nCurrent code: \"/// Remove git hooks from a project\"\n\nContext:\n- Function: Some(\"install_git_hooks\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_62",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/git_hooks.rs\nLine: 270\nCurrent code: \"/// Check if git hooks are installed\"\n\nContext:\n- Function: Some(\"install_git_hooks\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_63",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/git_hooks.rs\nLine: 306\nCurrent code: \"    async fn test_check_hooks_not_installed() {\"\n\nContext:\n- Function: Some(\"install_git_hooks\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_64",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/git_hooks.rs\nLine: 309\nCurrent code: \"            .await\"\n\nContext:\n- Function: Some(\"install_git_hooks\")\n- Return type: Some(\"Result < () >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_65",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/rust_version/detector.rs\nLine: 31\nCurrent code: \"    /// Parse rustc version output\"\n\nContext:\n- Function: Some(\"detect_rust_version\")\n- Return type: Some(\"Result < RustVersion >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_66",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/rust_version/detector.rs\nLine: 92\nCurrent code: \"/// Detect the channel from version string\"\n\nContext:\n- Function: Some(\"detect_rust_version\")\n- Return type: Some(\"Result < RustVersion >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_67",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/rust_version/github.rs\nLine: 60\nCurrent code: \"    /// Create a new GitHub client\"\n\nContext:\n- Function: Some(\"default_version\")\n- Return type: Some(\"Version\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_68",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/rust_version/github.rs\nLine: 206\nCurrent code: \"        let client = GitHubClient::new(None)?;\"\n\nContext:\n- Function: Some(\"default_version\")\n- Return type: Some(\"Version\")\n- Error handling style: StdResult\n- Complexity: Complex\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_69",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/bypass.rs\nLine: 123\nCurrent code: \"            // Remove expired bypass\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_70",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/bypass.rs\nLine: 255\nCurrent code: \"\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_71",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/bypass.rs\nLine: 269\nCurrent code: \"\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_72",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/bypass.rs\nLine: 279\nCurrent code: \"            .await\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_73",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/audit.rs\nLine: 14\nCurrent code: \"impl SafetyCheck for AuditCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_74",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/audit.rs\nLine: 28\nCurrent code: \"/// Run cargo audit\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_75",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/build.rs\nLine: 14\nCurrent code: \"impl SafetyCheck for BuildCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_76",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/build.rs\nLine: 28\nCurrent code: \"/// Run cargo build --release\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_77",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/build.rs\nLine: 115\nCurrent code: \"            .await\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_78",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/build.rs\nLine: 117\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_79",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/clippy.rs\nLine: 14\nCurrent code: \"impl SafetyCheck for ClippyCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_80",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/clippy.rs\nLine: 28\nCurrent code: \"/// Run cargo clippy with strict warnings\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_81",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/clippy.rs\nLine: 140\nCurrent code: \"            .await\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_82",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/clippy.rs\nLine: 142\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_83",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/doc.rs\nLine: 13\nCurrent code: \"impl SafetyCheck for DocCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_84",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/doc.rs\nLine: 27\nCurrent code: \"/// Run documentation build check (placeholder)\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_85",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/doc.rs\nLine: 36\nCurrent code: \"/// Check documentation coverage (placeholder)\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_86",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/format.rs\nLine: 14\nCurrent code: \"impl SafetyCheck for FormatCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_87",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/format.rs\nLine: 28\nCurrent code: \"/// Run cargo fmt --check\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_88",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/format.rs\nLine: 110\nCurrent code: \"            .await\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_89",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/format.rs\nLine: 112\nCurrent code: \"\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_90",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/license.rs\nLine: 14\nCurrent code: \"impl SafetyCheck for LicenseCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_91",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/license.rs\nLine: 28\nCurrent code: \"/// Validate license configuration\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_92",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/mod.rs\nLine: 26\nCurrent code: \"    /// Run the safety check\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_93",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/mod.rs\nLine: 57\nCurrent code: \"    /// Get description for a check type\"\n\nContext:\n- Function: None\n- Return type: None\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 65.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_94",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/publish.rs\nLine: 14\nCurrent code: \"impl SafetyCheck for PublishCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_95",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/publish.rs\nLine: 28\nCurrent code: \"/// Run cargo publish --dry-run\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_96",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/semver.rs\nLine: 15\nCurrent code: \"impl SafetyCheck for SemverCheck {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Moderate\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_97",
        "prompt": "Fix the following UnderscoreBandaid violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/semver.rs\nLine: 29\nCurrent code: \"/// Check semantic versioning compliance\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Architectural\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_98",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/semver.rs\nLine: 135\nCurrent code: \"    async fn test_semver_check_with_invalid_version() {\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 100.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      },
      {
        "violation_id": "violation_99",
        "prompt": "Fix the following UnwrapInProduction violation:\n        \nFile: /mnt/projects/ferrous-forge/src/safety/checks/semver.rs\nLine: 146\nCurrent code: \"            .await\"\n\nContext:\n- Function: Some(\"run\")\n- Return type: Some(\"Result < CheckResult >\")\n- Error handling style: StdResult\n- Complexity: Simple\n\nThe fix should:\n1. Resolve the violation\n2. Maintain existing behavior\n3. Use appropriate error handling for this context\n4. Be idiomatic Rust code\n\nConfidence in automated fix: 90.0%",
        "required_knowledge": [
          "Rust error handling patterns",
          "Function signatures and return types",
          "Trait implementations"
        ],
        "expected_output_format": "Rust code with explanatory comments"
      }
    ],
    "context_requirements": [
      "Full file content",
      "Function signatures",
      "Import statements",
      "Test coverage"
    ],
    "validation_criteria": [
      "Code must compile",
      "Tests must pass",
      "No new violations introduced",
      "Performance not degraded"
    ],
    "rollback_instructions": "If changes break compilation or tests, revert and mark for manual review"
  }
}