# Ferrous Forge v1.3.0 Implementation Plan
## Enhanced Safety Pipeline - "Never Break CI Again"

**Target Release Date**: October 10, 2025 (1 week development)  
**Version**: 1.3.0  
**Codename**: "Safety Shield"

---

## 🎯 **Mission Statement**

**Prevent broken code from EVER reaching GitHub or crates.io** by implementing mandatory local validation that blocks git operations and cargo publish until all CI checks pass locally.

---

## 🛡️ **Core Features**

### 1. **Mandatory Pre-Commit Pipeline** 
**Triggers**: Every `git commit`  
**Blocks commit if ANY check fails**

```bash
git commit -m "my changes"
# 🛡️ Ferrous Forge Safety Pipeline - Pre-Commit
# ✅ Format Check (0.1s) 
# ✅ Clippy Check (2.3s)
# ✅ Build Check (15.2s)
# ✅ Standards Check (1.1s)
# 🎉 All safety checks passed! Commit allowed.
```

### 2. **Mandatory Pre-Push Pipeline**
**Triggers**: Every `git push`  
**Blocks push if ANY check fails**

```bash
git push origin main
# 🛡️ Ferrous Forge Safety Pipeline - Pre-Push  
# ✅ All pre-commit checks (18.7s)
# ✅ Security Audit (0.8s)
# ✅ Full Test Suite (12.4s)
# ✅ Documentation Build (3.2s)
# 🎉 All safety checks passed! Push allowed.
```

### 3. **Cargo Publish Hijacking**
**Triggers**: `cargo publish` command  
**Blocks publish if ANY check fails**

```bash
cargo publish
# 🛡️ Ferrous Forge Safety Pipeline - Publish
# ✅ All pre-push checks (35.1s)
# ✅ Publish Dry Run (12.3s)
# ✅ Documentation Coverage (2.1s)
# ✅ License Validation (0.2s)
# ✅ Semver Check (1.1s)
# 🎉 All safety checks passed! Publishing to crates.io...
```

---

## 🏗️ **Implementation Architecture**

### Module Structure
```
src/
├── safety/
│   ├── mod.rs              # Safety pipeline coordinator
│   ├── pipeline.rs         # Main pipeline execution
│   ├── checks/
│   │   ├── mod.rs          # Check registry
│   │   ├── format.rs       # cargo fmt --check
│   │   ├── clippy.rs       # cargo clippy -- -D warnings
│   │   ├── test.rs         # cargo test --all-features
│   │   ├── build.rs        # cargo build --release
│   │   ├── audit.rs        # cargo audit
│   │   ├── doc.rs          # cargo doc
│   │   ├── publish.rs      # cargo publish --dry-run
│   │   └── standards.rs    # ferrous-forge validate
│   ├── config.rs           # Safety configuration
│   ├── report.rs           # Safety report generation
│   └── bypass.rs           # Emergency bypass system
├── git_hooks/ (enhanced)
│   ├── mod.rs              # Enhanced hook management
│   ├── mandatory.rs        # Mandatory hook installation
│   ├── pre_commit.rs       # Pre-commit hook logic
│   ├── pre_push.rs         # Pre-push hook logic
│   └── templates/          # Hook script templates
├── cargo_wrapper/
│   ├── mod.rs              # Cargo command hijacking
│   ├── publish.rs          # Publish command wrapper
│   ├── hijack.rs           # Command interception
│   └── proxy.rs            # Command proxying
└── commands/
    ├── safety.rs           # New safety CLI commands
    └── mod.rs              # Updated with safety commands
```

---

## 📋 **Implementation Tasks**

### **Week 1: Core Development (Oct 3-10)**

#### **Day 1-2: Foundation**
- [ ] Create `src/safety/` module structure
- [ ] Implement `SafetyPipeline` coordinator
- [ ] Create `SafetyConfig` with comprehensive settings
- [ ] Add safety-related error types

#### **Day 3-4: Check Implementation**
- [ ] Implement individual check modules (`format.rs`, `clippy.rs`, etc.)
- [ ] Create `CheckResult` and `SafetyReport` structures
- [ ] Add progress indicators and timing
- [ ] Handle check failures gracefully

#### **Day 5: Git Hooks Enhancement**
- [ ] Enhance existing git hooks system
- [ ] Create mandatory pre-commit hook
- [ ] Create mandatory pre-push hook
- [ ] Add hook installation to `ferrous-forge init`

#### **Day 6-7: Cargo Hijacking**
- [ ] Implement cargo command interception
- [ ] Create `cargo publish` wrapper
- [ ] Add safety checks before publish
- [ ] Handle emergency bypass system

---

## 🔧 **Technical Implementation Details**

### Safety Pipeline Coordinator

```rust
// src/safety/pipeline.rs

use crate::{Error, Result};
use std::path::Path;
use std::time::Instant;

pub struct SafetyPipeline {
    config: SafetyConfig,
    project_path: PathBuf,
    stage: PipelineStage,
}

#[derive(Debug, Clone)]
pub enum PipelineStage {
    PreCommit,
    PrePush,
    Publish,
}

impl SafetyPipeline {
    pub async fn run_stage(&self, stage: PipelineStage) -> Result<SafetyReport> {
        let start_time = Instant::now();
        let mut report = SafetyReport::new(&stage);
        
        match stage {
            PipelineStage::PreCommit => {
                report.add_check(checks::format::run(&self.project_path).await?);
                report.add_check(checks::clippy::run(&self.project_path).await?);
                report.add_check(checks::build::run(&self.project_path).await?);
                
                if self.config.pre_commit.run_standards_check {
                    report.add_check(checks::standards::run(&self.project_path).await?);
                }
            }
            PipelineStage::PrePush => {
                // Run all pre-commit checks first
                let pre_commit_report = self.run_stage(PipelineStage::PreCommit).await?;
                report.merge(pre_commit_report);
                
                // Additional pre-push checks
                report.add_check(checks::test::run_full(&self.project_path).await?);
                report.add_check(checks::audit::run(&self.project_path).await?);
                report.add_check(checks::doc::run(&self.project_path).await?);
            }
            PipelineStage::Publish => {
                // Run all pre-push checks first
                let pre_push_report = self.run_stage(PipelineStage::PrePush).await?;
                report.merge(pre_push_report);
                
                // Additional publish checks
                report.add_check(checks::publish::dry_run(&self.project_path).await?);
                report.add_check(checks::doc::coverage_check(&self.project_path).await?);
                report.add_check(checks::semver::compatibility_check(&self.project_path).await?);
            }
        }
        
        report.total_duration = start_time.elapsed();
        Ok(report)
    }
    
    /// Block operation if safety checks fail
    pub async fn enforce_safety(&self, stage: PipelineStage) -> Result<()> {
        let report = self.run_stage(stage).await?;
        
        // Print detailed report
        report.print_detailed();
        
        if !report.passed {
            // Check for bypass
            if self.check_bypass_conditions(&report).await? {
                println!("⚠️  Safety checks bypassed - proceeding with caution");
                return Ok(());
            }
            
            return Err(Error::safety_blocked(format!(
                "{} operation blocked by safety pipeline",
                stage.name()
            )));
        }
        
        println!("🎉 All safety checks passed! Operation allowed.");
        Ok(())
    }
}
```

### Enhanced Git Hooks

```bash
#!/bin/bash
# .git/hooks/pre-commit (installed by ferrous-forge init)

echo "🛡️  Ferrous Forge Safety Pipeline - Pre-Commit"
echo "=============================================="

# Run safety pipeline
ferrous-forge safety enforce --stage=pre-commit

# Exit with the same code as the safety pipeline
exit_code=$?

if [ $exit_code -ne 0 ]; then
    echo ""
    echo "🚨 COMMIT BLOCKED by safety pipeline!"
    echo "Fix the issues above and try again."
    echo ""
    echo "Emergency bypass (NOT recommended):"
    echo "  ferrous-forge safety bypass --stage=pre-commit --reason='urgent hotfix'"
fi

exit $exit_code
```

### Cargo Publish Hijacking

```rust
// src/cargo_wrapper/publish.rs

use std::env;
use std::process::Command;

pub async fn hijack_cargo_publish() -> Result<()> {
    // Detect if this is a cargo publish command
    let args: Vec<String> = env::args().collect();
    
    if args.len() >= 2 && args[1] == "publish" {
        println!("🛡️  Ferrous Forge intercepted cargo publish");
        
        // Run safety pipeline
        let pipeline = SafetyPipeline::new(env::current_dir()?)?;
        pipeline.enforce_safety(PipelineStage::Publish).await?;
        
        // If we get here, safety checks passed
        println!("🚀 Safety checks passed! Executing cargo publish...");
        
        // Execute original cargo publish
        let status = Command::new("cargo")
            .args(&args[1..])
            .status()?;
            
        if !status.success() {
            return Err(Error::process("cargo publish failed"));
        }
        
        println!("✅ Successfully published to crates.io!");
        return Ok(());
    }
    
    // Not a publish command, execute normally
    let status = Command::new("cargo")
        .args(&args[1..])
        .status()?;
        
    std::process::exit(status.code().unwrap_or(1));
}
```

---

## 🎮 **User Experience Design**

### Installation Experience
```bash
cargo install ferrous-forge
ferrous-forge init

# Output:
# 🛡️  Installing Enhanced Safety Pipeline...
# ✅ Pre-commit hooks installed
# ✅ Pre-push hooks installed  
# ✅ Cargo publish wrapper installed
# ✅ Safety configuration created
# 
# Your development workflow is now protected!
# Broken code cannot reach GitHub or crates.io.
```

### Developer Workflow
```bash
# Normal development - safety checks run automatically
git add .
git commit -m "add feature"
# 🛡️ Safety checks run automatically...
# ✅ All checks pass - commit allowed

git push origin main  
# 🛡️ Safety checks run automatically...
# ✅ All checks pass - push allowed

cargo publish
# 🛡️ Safety checks run automatically...
# ✅ All checks pass - publish allowed
```

### When Things Fail
```bash
git commit -m "broken code"
# 🛡️ Ferrous Forge Safety Pipeline - Pre-Commit
# ✅ Format Check (0.1s)
# ❌ Clippy Check (2.1s)
#   ⚠️  error: used `unwrap()` on a `Result` value
#   ⚠️  Fix clippy warnings before committing
# 🚨 COMMIT BLOCKED by safety pipeline!
# 
# Fix the issues above and try again.
```

---

## ⚙️ **Configuration System**

```toml
# ~/.config/ferrous-forge/safety.toml

[safety]
enabled = true
strict_mode = true              # Block operations on failure
show_progress = true            # Show progress indicators
parallel_checks = true         # Run checks in parallel when possible

[pre_commit]
enabled = true
timeout_seconds = 300           # 5 minute timeout
checks = [
    "format",                   # cargo fmt --check
    "clippy",                   # cargo clippy -- -D warnings  
    "build",                    # cargo build --release
    "standards"                 # ferrous-forge validate
]

[pre_push]
enabled = true  
timeout_seconds = 600           # 10 minute timeout
checks = [
    "all_pre_commit",           # All pre-commit checks
    "test_full",                # cargo test --all-features
    "audit",                    # cargo audit
    "doc_build"                 # cargo doc
]

[publish]
enabled = true
timeout_seconds = 900           # 15 minute timeout
checks = [
    "all_pre_push",             # All pre-push checks
    "publish_dry_run",          # cargo publish --dry-run
    "doc_coverage",             # Documentation coverage
    "license_check",            # License validation
    "semver_check"              # Semver compatibility
]

[bypass]
# Emergency bypass system
enabled = false                 # Disabled by default
require_reason = true           # Must provide reason
require_confirmation = true     # Must confirm bypass
log_all_bypasses = true        # Log for audit
max_bypasses_per_day = 3       # Rate limiting
```

---

## 🚀 **CLI Commands**

```bash
# Safety pipeline management
ferrous-forge safety install           # Install all safety hooks
ferrous-forge safety uninstall         # Remove safety hooks
ferrous-forge safety status            # Show safety pipeline status

# Manual safety checks
ferrous-forge safety check             # Run all checks for current stage
ferrous-forge safety check --stage=pre-commit
ferrous-forge safety check --stage=pre-push
ferrous-forge safety check --stage=publish

# Configuration
ferrous-forge safety config --show     # Show current config
ferrous-forge safety config --set pre_commit.timeout_seconds=600
ferrous-forge safety config --reset    # Reset to defaults

# Emergency bypass (requires confirmation)
ferrous-forge safety bypass --stage=pre-commit --reason="urgent hotfix"
ferrous-forge safety bypass --stage=publish --reason="security patch"

# Audit and reporting
ferrous-forge safety report --last=10  # Show last 10 safety reports
ferrous-forge safety audit             # Show bypass audit log
ferrous-forge safety stats             # Show safety statistics
```

---

## 📂 **File Structure**

```
src/
├── safety/
│   ├── mod.rs              # Main safety module
│   ├── pipeline.rs         # Pipeline coordinator
│   ├── config.rs           # Safety configuration
│   ├── report.rs           # Report generation
│   ├── bypass.rs           # Emergency bypass system
│   ├── installer.rs        # Hook installation
│   └── checks/
│       ├── mod.rs          # Check registry
│       ├── format.rs       # Format checking
│       ├── clippy.rs       # Clippy checking
│       ├── test.rs         # Test execution
│       ├── build.rs        # Build checking
│       ├── audit.rs        # Security audit
│       ├── doc.rs          # Documentation
│       ├── publish.rs      # Publish validation
│       ├── standards.rs    # Ferrous Forge standards
│       └── semver.rs       # Semver compatibility
├── git_hooks/ (enhanced)
│   ├── mod.rs              # Enhanced git hooks
│   ├── mandatory.rs        # Mandatory hook system
│   ├── templates/
│   │   ├── pre-commit.sh   # Pre-commit hook template
│   │   ├── pre-push.sh     # Pre-push hook template
│   │   └── commit-msg.sh   # Commit message hook
├── cargo_wrapper/
│   ├── mod.rs              # Cargo hijacking system
│   ├── publish.rs          # Publish wrapper
│   ├── hijack.rs           # Command interception
│   └── proxy.rs            # Command proxying
└── commands/
    ├── safety.rs           # Safety CLI commands
    └── mod.rs              # Updated with safety commands
```

---

## 🔍 **Individual Check Implementations**

### Format Check
```rust
// src/safety/checks/format.rs

pub async fn run(project_path: &Path) -> Result<CheckResult> {
    let start = Instant::now();
    
    let output = Command::new("cargo")
        .current_dir(project_path)
        .args(&["fmt", "--check"])
        .output()?;
    
    let mut result = CheckResult::new("Format Check");
    result.duration = start.elapsed();
    
    if !output.status.success() {
        result.passed = false;
        result.add_error("Code formatting violations found");
        result.add_suggestion("Run 'cargo fmt' to fix formatting");
        
        // Parse and include specific violations
        let stderr = String::from_utf8_lossy(&output.stderr);
        for line in stderr.lines().take(10) {
            if line.contains("Diff") {
                result.add_error(format!("Formatting issue: {}", line));
            }
        }
    }
    
    Ok(result)
}
```

### Clippy Check
```rust
// src/safety/checks/clippy.rs

pub async fn run(project_path: &Path) -> Result<CheckResult> {
    let start = Instant::now();
    
    let output = Command::new("cargo")
        .current_dir(project_path)
        .args(&["clippy", "--all-targets", "--all-features", "--", "-D", "warnings"])
        .output()?;
    
    let mut result = CheckResult::new("Clippy Check");
    result.duration = start.elapsed();
    
    if !output.status.success() {
        result.passed = false;
        result.add_error("Clippy lints found");
        result.add_suggestion("Fix clippy warnings before proceeding");
        
        // Parse clippy output for specific issues
        let stderr = String::from_utf8_lossy(&output.stderr);
        let mut error_count = 0;
        
        for line in stderr.lines() {
            if line.contains("error:") && error_count < 5 {
                result.add_error(format!("Clippy: {}", line.trim()));
                error_count += 1;
            }
        }
        
        if error_count == 5 {
            result.add_error("... and more clippy errors (showing first 5)");
        }
    }
    
    Ok(result)
}
```

---

## 🎯 **Integration Points**

### Enhanced Init Command
```rust
// Update src/commands/init.rs

pub async fn execute(force: bool) -> Result<()> {
    // ... existing init logic ...
    
    println!("🛡️  Installing Enhanced Safety Pipeline...");
    
    // Install safety hooks
    let installer = safety::installer::SafetyInstaller::new()?;
    installer.install_mandatory_hooks().await?;
    installer.setup_cargo_hijacking().await?;
    installer.create_safety_config().await?;
    
    println!("✅ Enhanced Safety Pipeline installed!");
    println!("\n🛡️  Your development workflow is now protected:");
    println!("  • git commit  → Automatic format/clippy/build checks");
    println!("  • git push    → Additional test/audit/doc checks");
    println!("  • cargo publish → Comprehensive validation pipeline");
    println!("\n🚨 Broken code CANNOT reach GitHub or crates.io!");
    
    Ok(())
}
```

### Safety CLI Commands
```rust
// src/commands/safety.rs

#[derive(Subcommand)]
pub enum SafetyCommand {
    /// Install safety pipeline
    Install {
        /// Force reinstallation
        #[arg(long)]
        force: bool,
    },
    /// Check safety pipeline status
    Status,
    /// Run safety checks manually
    Check {
        /// Pipeline stage to check
        #[arg(long, default_value = "pre-commit")]
        stage: String,
        /// Show verbose output
        #[arg(short, long)]
        verbose: bool,
    },
    /// Configure safety pipeline
    Config {
        /// Show current configuration
        #[arg(long)]
        show: bool,
        /// Set configuration value
        #[arg(long)]
        set: Option<String>,
    },
    /// Emergency bypass (requires confirmation)
    Bypass {
        /// Pipeline stage to bypass
        #[arg(long)]
        stage: String,
        /// Reason for bypass (required)
        #[arg(long)]
        reason: String,
        /// Skip confirmation prompt
        #[arg(long)]
        confirm: bool,
    },
    /// Show safety reports and audit log
    Report {
        /// Number of recent reports to show
        #[arg(long, default_value = "5")]
        last: usize,
    },
}
```

---

## 🧪 **Testing Strategy**

### Unit Tests
- [ ] Test each individual check function
- [ ] Test pipeline coordination
- [ ] Test configuration loading/saving
- [ ] Test bypass system
- [ ] Test report generation

### Integration Tests
- [ ] Test full pre-commit pipeline
- [ ] Test full pre-push pipeline
- [ ] Test cargo publish hijacking
- [ ] Test emergency bypass
- [ ] Test hook installation/removal

### Real-World Testing
- [ ] Test on projects with deliberate failures
- [ ] Test performance with large codebases
- [ ] Test bypass system in emergency scenarios
- [ ] Test with different git workflows

---

## 📊 **Success Metrics**

### Technical Metrics
- ✓ < 30s total time for pre-commit checks
- ✓ < 60s total time for pre-push checks
- ✓ < 120s total time for publish checks
- ✓ 100% block rate for failing CI checks
- ✓ < 1% false positive rate

### User Experience Metrics
- ✓ Clear, actionable error messages
- ✓ Helpful suggestions for fixes
- ✓ Progress indicators for long operations
- ✓ Emergency bypass available when needed

---

## 🎉 **Expected Impact**

### For Individual Developers
- ✅ **Never break CI again** - Impossible to push failing code
- ✅ **Faster feedback** - Catch issues immediately, not after push
- ✅ **Better habits** - Learn best practices through enforcement
- ✅ **Confidence** - Know your code will work before pushing

### For Teams
- ✅ **Reliable CI** - CI always passes because local checks ensure it
- ✅ **Faster reviews** - Code is pre-validated before review
- ✅ **Consistent quality** - Same standards enforced for everyone
- ✅ **Reduced debugging** - Less time fixing CI failures

### For the Rust Ecosystem
- ✅ **Higher quality crates** - Only validated code reaches crates.io
- ✅ **More reliable packages** - Fewer broken releases
- ✅ **Better developer experience** - Tools that prevent problems

---

## 🚨 **Risk Mitigation**

### Performance Concerns
- **Solution**: Parallel check execution, configurable timeouts
- **Fallback**: Ability to disable slow checks

### Emergency Situations
- **Solution**: Emergency bypass system with logging
- **Safeguard**: Rate limiting and required justification

### Developer Adoption
- **Solution**: Progressive enhancement, can be disabled
- **Education**: Clear benefits and usage documentation

---

This Enhanced Safety Pipeline will transform Ferrous Forge from a **reactive** tool into a **proactive guardian** that makes it physically impossible to break CI/CD pipelines or publish broken crates.

**Ready to start implementation?** 🛡️🚀
